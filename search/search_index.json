{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jaculus-machine - Embeddable JavaScript runtime","text":"<p>Jaculus-machine is a C++ centric JavaScript runtime that can be easily embedded into other applications. It is powered by the QuickJS JavaScript engine.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>The core concept of Jaculus-machine is a Machine type. A Machine is parametrized by MFeatures which specify the core functionality of the Machine and the JavaScript runtime. MFeatures are added to the Machine using stack inheritance. At the bottom of the stack, there is always a <code>jac::MachineBase</code> which provides the most basic functionality. For example, a Machine with some built-in MFeatures can be created like this:</p> <pre><code>#include &lt;jaculus/machine.h&gt;\n#include &lt;jaculus/features/stdioFeature.h&gt;\n#include &lt;jaculus/features/filesystemFeature.h&gt;\n#include &lt;jaculus/features/basicStreamFeature.h&gt;\n#include &lt;jaculus/features/moduleLoaderFeature.h&gt;\n#include &lt;jaculus/features/util/ostreamjs.h&gt;\n\n\nusing Machine = jac::ComposeMachine&lt;\n    jac::MachineBase\n    jac::BasicStreamFeature,\n    jac::StdioFeature,\n    jac::FilesystemFeature,\n    jac::ModuleLoaderFeature,\n&gt;;\n</code></pre> <p>To further extend the functionality of the Machine, we can use Plugins. Plugins are added to the runtime dynamically after the runtime initialization.</p> <p>After the Machine type is defined, we can instantiate it:</p> <pre><code>Machine machine;\n</code></pre> <p>Then we can configure the Machine - we can, for example, set the output streams of the stdio MFeature:</p> <pre><code>machine.stdio.out = machine.stdio.out = std::make_unique&lt;OsWritable&lt;Machine&gt;&gt;(std::cout);\nmachine.stdio.err = machine.stdio.err = std::make_unique&lt;OsWritable&lt;Machine&gt;&gt;(std::cerr);\n</code></pre> <p>At this point, we still can not run any JavaScript code, nor can we interact with the runtime in any way. For that, we first need to initialize the Machine:</p> <pre><code>machine.initialize();\n</code></pre> <p>At this point, we can add any Plugins to the Machine.</p> <p>After the Machine is initialized, we can finally run some JavaScript code:</p> <pre><code>jac::Value result = machine.eval(\"console.log('Hello, world!');\", \"&lt;stdin&gt;\", jac::EvalFlags::Global);\n</code></pre> <p>Or we can evaluate a JavaScript file using <code>ModuleLoaderFeature::evalFile</code> method:</p> <pre><code>jac::Value result = machine.evalFile(\"./main.js\", jac::EvalFlags::Global);\n</code></pre> <p>Both <code>eval</code> and <code>evalFile</code>, however, only evaluate the code and do not control the event loop. For that, we need to use the <code>EventLoopFeature</code>.</p>"},{"location":"getting-started/#mfeatures","title":"MFeatures","text":"<p>MFeatures are the core building blocks of a Machine. The stack design of a Machine allows interfacing with different MFeatures in C++ directly and to implement new MFeatures on top of existing ones without a large performance penalty.</p> <p>Only the most basic and necessary MFeatures are included with the library:</p> <ul> <li><code>jac::MachineBase</code> - the base class of all Machines. It provides the basic functionality of the runtime.</li> <li><code>jac::EventQueueFeature</code> - provides an event queue built on top of the standard library.</li> <li><code>jac::EventLoopFeature</code> - provides a default event loop implementation.</li> <li><code>jac::FileystemFeature</code> - provides filesystem access through <code>fs</code> and <code>path</code> modules</li> <li><code>jac::ModuleLoaderFeature</code> - provides module loading through <code>import</code>, and <code>evalFile</code> method</li> <li><code>jac::BasicStreamFeature</code> - provides <code>Readable</code> and <code>Writable</code> abstract classes</li> <li><code>jac::StdioFeature</code> - provides standard io streams and a simplified <code>console</code> interface</li> <li><code>jac::TimersFeature</code> - provides typical JavaScript timers (with a slight difference) and a <code>sleep</code> function</li> </ul>"},{"location":"getting-started/#plugins","title":"Plugins","text":"<p>Plugins are the primary way to extend the functionality of the JavaScript runtime. They are added to the machine dynamically after the runtime initialization.</p> <p>Compared to MFeatures, Plugins are more high-level and should be used to implement functionality that is not directly related to the JavaScript runtime.</p>"},{"location":"pitfalls/","title":"Pitfalls","text":""},{"location":"pitfalls/#only-one-context-per-machine","title":"Only one context per Machine","text":"<p>From the beginning, the design of Jaculus-machine was to have only one context per Machine instance. The honest reason is my lack of knowledge of QuickJS and JavaScript internals at the time. Now it starts to show it was a wrong decision and proves to be a limitation in some cases.</p> <p>For example, in REPL, all exceptions should be caught and reported to standard output. When starting REPL from a JavaScript program, the main program should crash on unhandled exceptions, whereas the REPL should not. Implementation of this would require REPL and the main program to be executed in separate contexts to distinguish between their behavior regarding exception handling.</p>"},{"location":"pitfalls/#unhandled-promise-rejections-not-being-reported","title":"Unhandled promise rejections not being reported","text":"<p>This is a limitation of QuickJS (might even be called a bug). QuickJS does have a mechanism for reporting unhandled promise rejections, but it reports some false positives. Consider this example:</p> <pre><code>new Promise((resolve, reject) =&gt; {\n    reject(null);\n}).then(() =&gt; {\n    console.log(\"ok\");\n}).catch(() =&gt; {\n    console.log(\"error\");\n});\n</code></pre> <p>The promise is created and immediately rejected. At that moment, the promise does not have a rejection handler, and thus QuickJS reports an unhandled promise rejection. However, the handler is added before the promise goes out of scope and handles the rejection.</p> <p>To fix this, diving into the divine magic of QuickJS internals would be required, which would mean a lot of work. As this does not pose any problem for running good JavaScript code and is problematic only when running bad code, it is not a priority.</p>"},{"location":"pitfalls/#conversion-of-javascript-value-to-int","title":"Conversion of JavaScript value to int","text":"<p>Standard JavaScript allows the dynamic conversion of values to number type. This means that the string <code>\"123\"</code> can be converted to the number <code>123</code> without specifying it explicitly. JavaScript numbers, however, may also contain values such as <code>NaN</code>. <code>Nan</code> is, among other uses, used to indicate that a conversion to a number failed. QuickJS function for converting a value to <code>int32_t</code> does not check for <code>NaN</code> and, on invalid conversion, returns <code>0</code> instead.</p>"},{"location":"reference/atom/","title":"Atom","text":"<p><code>jac::Atom</code> is a type that represents identifiers of a JavaScript properties, variables, functions etc. It can be used in place of <code>std::string</code> for better performance.</p>"},{"location":"reference/atom/#creating-atoms","title":"Creating atoms","text":"<p>Atoms can be created from a string using the <code>jac::Atom::create</code> method:</p> <pre><code>jac::ContextRef ctx = ...;\n\njac::Atom atom1 = jac::Atom::create(ctx, \"foo\");\njac::Atom atom2 = jac::Atom::create(ctx, 123);\n</code></pre>"},{"location":"reference/atom/#usage","title":"Usage","text":"<p>Most functions in Jaculus-machine that take a string identifier as an argument also have an overload that takes a <code>jac::Atom</code> argument.</p> <pre><code>jac::ContextRef ctx = ...;\n\njac::Object global = ctx.getGlobalObject();\n\njac::Atom atom = jac::Atom::create(ctx, \"foo\");\njac::Value value = global.get(atom);\n</code></pre>"},{"location":"reference/classes/","title":"Classes","text":"<p>Classes, in the context of Jaculus-machine are, similarly to JavaScript classes, templates for creating objects. Unlike raw JavaScript classes, however, classes defined in C++ can contain opaque C++ data, which can then be used through an interface defined in the class definition.</p>"},{"location":"reference/classes/#defining-a-class","title":"Defining a class","text":"<p>To create a class, you must first define a <code>ProtoBuilder</code> structure. A <code>ProtoBuilder</code> describes the class's behavior and prototype through a static interface. Features of the class are specified by inheriting from the structures in the <code>jac::ProtoBuilder</code> namespace and overriding their static interfaces. These structs contain a default implementation of their interface and some convenience functions for describing the class.</p> <p>The list of base structs and their interface/convenience functions can be found in the API documentation.</p> <p>An example of the <code>ProtoBuilder</code> structure is shown below:</p> <pre><code>/* Describes a simple JavaScript class with opaque object of type MyClass */\nstruct MyBuilder : public ProtoBuilder::Opaque&lt;MyClass&gt;, public ProtoBuilder::Properties {\n\n    /* describes how to construct the opaque object */\n    static MyClass* constructOpaque(ContextRef ctx, std::vector&lt;ValueWeak&gt; args) {\n        if (args.size() &lt; 1) {\n            throw std::runtime_error(\"MyClass constructor expects 1 argument\");\n        }\n        /* get the first argument as an integer */\n        int a = args[0].to&lt;int&gt;();\n        return new MyClass(a);\n    }\n\n    /* describes how to destruct the opaque object, copy-pasted from the\n       default implementation provided by the base class (can be omited) */\n    static void destructOpaque(JSRuntime* rt, MyClass* ptr) noexcept {\n        delete ptr;\n    }\n\n    /* describes which properties should be added to the prototype */\n    static void addProperties(ContextRef ctx, Object proto) {\n        /* a convenience function from ProtoBuilder::Opaque,\n           which allows simplified access to the opaque object */\n        addPropMember&lt;int, &amp;MyClass::foo&gt;(ctx, proto, \"foo\");\n\n        /* a convenience function from ProtoBuilder::Opaque */\n        addMethodMember&lt;decltype(&amp;MyClass::bar), &amp;MyClass::bar&gt;(ctx, proto, \"bar\");\n\n        /* a more roundabout way of adding a method to the prototype */\n        FunctionFactory ff(ctx);\n        proto.defineProperty(\"baz\", ff.newFunctionThis([](ContextRef ctx, ValueWeak thisValue) {\n            /* another convenience function from ProtoBuilder::Opaque */\n            MyClass&amp; self = *getOpaque(ctx, thisValue);\n            self.baz();\n        }));\n    }\n};\n</code></pre> <p>The <code>jac::Class</code> template can be then instantiated with the <code>ProtoBuilder</code> structure to create a class definition, and a name can be assigned to it using the <code>init</code> method. This method can be called repeatedly without any effect if called with the same name; otherwise, an exception will be thrown.</p> <pre><code>using MyClassJs = Class&lt;MyBuilder&gt;;\n\nMyClassJs::init(\"MyClass\");\n</code></pre> <p>To use the class in a given Context, the class must be initialized in the Context by calling the <code>initContext</code> method:</p> <pre><code>ContextRef ctx = ...;\n\nMyClassJs::initContext(ctx);\n</code></pre> <p>After the class and context are initialized, you can get the class constructor and prototype and instantiate the class:</p> <pre><code>Value constructor = MyClassJs::getConstructor(ctx);\nValue prototype = MyClassJs::getPrototype(ctx);\n\nValue obj = constructor.to&lt;Function&gt;().callConstructor();\n</code></pre>"},{"location":"reference/context/","title":"Context","text":"<p>According to ECMAScript specification, JavaScript code is evaluated in a Realm, which defines the execution environment (e.g., global object and set of built-in objects). QuickJS uses a different term for this concept -- Context, which I have adopted in Jaculus-machine.</p> <p>Jaculus-machine allows creating only one Context per Machine. This Context is created when the Machine is initialized and is accessible through the <code>MachineBase::context</code> method as a <code>ContextRef</code> object.</p> <p><code>ContextRef</code> can be used to access the global object of the Context through the <code>getGlobalObject</code> method. It is also an argument to many functions working with JavaScript values.</p>"},{"location":"reference/context/#usage","title":"Usage","text":"<pre><code>#include &lt;jac/machine.h&gt;\n\nusing Machine = jac::MachineBase;\n\nMachine machine;\nmachine.initialize();\n\njac::ContextRef ctx = machine.context();\njac::Object global = ctx.getGlobalObject();\n</code></pre>"},{"location":"reference/event-loop/","title":"Event loop","text":"<p>Although JavaScript programs are event-driven, the code is executed in a single thread. This is achieved by using an event loop, where asynchronous events are queued and executed in the order they are received.</p> <p>The default implementation of an event loop is provided by <code>EventLoopFeature</code>. It is an MFeature that can be added to a Machine to provide an event loop and requires an MFeature that provides an event queue. The default event queue implementation is provided by <code>EventQueueFeature</code>. To allow running code on an event loop tick, a virtual method <code>EventLoopFeature::onEventLoop</code> can be used. To define the top of the Machine stack, the <code>EventLoopTerminal</code> class must be used as the topmost MFeature.</p>"},{"location":"reference/event-loop/#usage","title":"Usage","text":"<p>To use the event loop, the MFeature must be added to the Machine. To start the event loop, use the <code>EventLoopFeature::run</code> method.</p> <pre><code>#include &lt;jac/machine.h&gt;\n#include &lt;jac/features/eventLoopFeature.h&gt;\n#include &lt;jac/features/eventQueueFeature.h&gt;\n#include &lt;jac/features/timersFeature.h&gt;\n\nusing Machine = jac::ComposeMachine&lt;\n    jac::MachineBase\n    jac::EventQueueFeature,\n    jac::EventLoopFeature,\n    jac::TimersFeature,\n    jac::EventLoopTerminal,\n&gt;;\n\nMachine machine;\nmachine.initialize();\n\nmachine.eval(\"setTimeout(() =&gt; console.log('Hello, world!'), 1000);\", \"&lt;stdin&gt;\", jac::EvalFlags::Global);\nmachine.startEventLoop();\n</code></pre> <p>The event loop will run indefinitely until the <code>EventLoopFeature::exit</code> or <code>EventLoopFeature::kill</code> method is called. The <code>exit</code> method can also be called from the JavaScript code by calling the <code>exit</code> function.</p>"},{"location":"reference/event-loop/#custom-event-queue","title":"Custom event queue","text":"<p>It is possible to implement a custom event queue MFeature with extended functionality. The MFeature must be thread-safe and must provide the following methods:</p> <pre><code>template&lt;class Next&gt;\nclass MyEventQueueFeature : public Next {\npublic:\n    /**\n     * @brief Check the event queue and return the first event\n     * @param wait Wait for event if no event is available\n     * @return Event or std::nullopt if no event is available\n     */\n    std::optional&lt;std::function&lt;void()&gt;&gt; getEvent(bool wait);\n\n    /**\n     * @brief Schedule an event to be run\n     * @param func Function to be run\n     */\n    void scheduleEvent(std::function&lt;void()&gt; func);\n\n    /**\n     * @brief Wake up event loop if it is waiting for events\n     */\n    void notifyEventLoop();\n};\n</code></pre>"},{"location":"reference/exceptions/","title":"Exceptions","text":"<p>In most cases, wrapped C++ code can throw exceptions, which will the be propagated to the JavaScript runtime.</p> <p>Similarly, if any interaction with the JavaScript runtime throws an exception, it will be propagated to the C++ side.</p>"},{"location":"reference/exceptions/#exception-propagation","title":"Exception propagation","text":"<p>When <code>jac::Exception</code> is thrown, the wrapped value is thrown or a new <code>Error</code> is constructed from given template.</p> <p>When <code>std::exception</code> is thrown, an <code>InternalError</code> is thrown with the message <code>e.what()</code>.</p> <p>When any other exception is thrown, an <code>InternalError</code> is thrown with the message <code>\"unknown error\"</code>.</p> <p>If the JavaScript runtime throws an exception, a new <code>jac::Exception</code> is constructed from the thrown value and thrown to the C++ side.</p>"},{"location":"reference/exceptions/#jacexception-class","title":"<code>jac::Exception</code> class","text":"<p>One way <code>jac::Exception</code> can be used, is to wrap any JavaScript value. It can be created by converting a <code>Value</code> to <code>Exception</code>:</p> <pre><code>Value value = ...;\nException ex = value.to&lt;Exception&gt;();\n</code></pre> <p>Second way is to define <code>Exception</code> as an <code>Error</code> template. This way, the correct <code>Error</code> type will be constructed when the exception is propagated to JavaScript:</p> <pre><code>Exception ex = Exception::create(Exception::Type::TypeError, \"Invalid argument\");\n</code></pre> <p>More information can be found in the API documentation.</p>"},{"location":"reference/functions/","title":"Functions","text":"<p>Jaculus-machine allows the wrapping of callable objects into JavaScript functions and the calling of JavaScript functions from C++.</p> <p>Exceptions thrown in the context of a wrapped function and exceptions thrown by the JavaScript functions are propagated as described in the Exceptions section.</p>"},{"location":"reference/functions/#wrapping-callable-objects","title":"Wrapping callable objects","text":"<p>Callable objects can be wrapped into JavaScript functions using the <code>jac::FunctionFactory</code> class. The call operator of the object must be unambiguous, and the arguments and return type must be convertible to and from JavaScript values.</p> <p>To wrap a function, the user can use the <code>newFunction</code> and <code>newFunctionThis</code>. All arguments that are passed to the function call will be converted to the types of the function parameters. If the number of arguments does not match or if the values cannot be converted to the required types, a <code>TypeError</code> will be thrown.</p> <p>The methods <code>newFunctionVariadic</code> and <code>newFunctionThisVariadic</code> can be used to create variadic functions --- all arguments that are passed to the function call will be contained in a single <code>std::vector&lt;ValueWeak&gt;</code>.</p> <p>The methods <code>newFunctionThis</code> and <code>newFunctionThisVariadic</code> additionally give access to the <code>this</code> value of the function (for example, when the function is called as a method of an object).</p> <p>Here are some examples:</p> <pre><code>jac::ContextRef ctx = ...;\njac::FunctionFactory ff(ctx);\n\njac::Function f1 = ff.newFunction([](int a, int b) { return a + b; });\n\njac::Function f2 = ff.newFunctionVariadic([](std::vector&lt;jac::ValueWeak&gt; args) {\n    int sum = 0;\n    for (auto&amp; arg : args) {\n        sum += arg.to&lt;int&gt;();\n    }\n    return sum;\n});\n\njac::Function f3 = ff.newFunctionThis([](jac::ValueWeak thisValue, int a, int b) {\n    auto obj = thisValue.to&lt;jac::ObjectWeak&gt;();\n\n    return obj.get(\"x\").to&lt;int&gt;() + a + b;\n});\n\njac::Function f4 = ff.newFunctionThisVariadic([](jac::ValueWeak thisValue, std::vector&lt;jac::ValueWeak&gt; args) {\n    auto obj = thisValue.to&lt;jac::ObjectWeak&gt;();\n\n    int sum = obj.get(\"x\").to&lt;int&gt;();\n    for (auto&amp; arg : args) {\n        sum += arg.to&lt;int&gt;();\n    }\n    return sum;\n});\n</code></pre>"},{"location":"reference/functions/#calling-javascript-functions","title":"Calling JavaScript functions","text":"<p>JavaScript functions can be called either as free functions or as methods of an object.</p> <p>A free function is represented by the <code>jac::Function</code> type, which has two methods for calling the function: <code>call&lt;Res, Args...&gt;(Args... args)</code> and <code>callThis&lt;Res, Args...&gt;(jac::ValueWeak thisValue, Args... args)</code>. The first method performs a standard function call, while the second method calls the function with the <code>this</code> value set to the value passed as the first argument. The template arguments <code>Res</code> and <code>Args...</code> specify the return type and the argument types of the function.</p> <p>An object is represented by the <code>jac::Object</code> type, which has a method <code>invoke&lt;Res, Args...&gt;(const std::string&amp; name, Args... args)</code> for calling a method of the object. The first argument specifies the name of the method, while the rest of the arguments are passed to the method. It has two other overloads, which allow specifying the identifier of the method as an <code>uint32_t</code> or a <code>jac::Atom</code>.</p> <p>They can be used as follows:</p> <pre><code>MachineBase machine;\nmachine.initialize();\n\njac::Function f1 = machine.eval(\"function(a, b) { return a + b; }\", \"&lt;eval&gt;\", jac::EvalFlags::Global).to&lt;jac::Function&gt;();\njac::Function f2 = machine.eval(\"function() { return this.x; }\", \"&lt;eval&gt;\", jac::EvalFlags::Global).to&lt;jac::Function&gt;();\n\nint res1 = f1.call&lt;int&gt;(1, 2);  // calls f1(1, 2) and returns the result as an int\n\njac::Value obj = machine.eval(\"({ x: 5 })\", \"&lt;eval&gt;\", jac::EvalFlags::Global);\nint res2 = f2.callThis&lt;int&gt;(obj);  // calls f2.call(obj) and returns the result as an int\n\njac::Object obj2 = jac::Object::create(machine.context());\nobj2.set(\"x\", 10);\nobj2.set(\"f\", f2);\n\nint res3 = obj2.invoke&lt;int&gt;(\"f\");  // calls obj2.f() and returns the result as an int\n</code></pre>"},{"location":"reference/functions/#calling-constructors","title":"Calling constructors","text":"<p>JavaScript distinguishes whether a function is called as a constructor or as a normal function - inside JavaScript, this is signified by the <code>new</code> keyword. To call a <code>jac::Function</code> as a constructor, use the <code>callConstructor&lt;Res, Args...&gt;(Args... args)</code> method.</p> <pre><code>MachineBase machine;\nmachine.initialize();\n\njac::Function a = machine.eval(\"class A { constructor(x) { this.x = x } }\", \"&lt;eval&gt;\", jac::EvalFlags::Global).to&lt;jac::Function&gt;();\n\njac::Value obj = a.callConstructor(5);  // calls new f(5) and returns the result as a Value\n</code></pre>"},{"location":"reference/mfeatures/","title":"Custom MFeatures","text":"<p>As shown in the Getting started section, a Machine is parametrized by MFeatures that define the core functionality of the Machine and the JavaScript runtime.</p> <p>An MFeature is a class, that follows the stack inheritance and provides functionality to the Machine either by providing a public C++ API that can be used by other MFeatures or the user, or by adding functionality directly to the JavaScript runtime.</p> <p>The MFeature must not interact with the JavaScript runtime in any way in its constructor, as it is not yet initialized at that point. Initialization of the MFeature involving the JavaScript runtime should be done in the <code>initialize</code> method.</p>"},{"location":"reference/mfeatures/#modifying-the-global-object","title":"Modifying the global object","text":"<p>Let's create an MFeature that adds a <code>print</code> function to the global object of the JavaScript runtime.</p> <pre><code>#include &lt;jac/machine.h&gt;\n#include &lt;jac/functionFactory.h&gt;\n\ntemplate&lt;class Next&gt;\nclass PrintFeature : public Next {\npublic:\n    std::ostream out;\n\n    void print(std::string str) {\n        out &lt;&lt; str;\n    }\n\n    void initialize() {\n        Next::initialize();\n\n        jac::Value global = this-&gt;context().getGlobalObject();\n        jac::FunctionFactory ff(this-&gt;context());\n\n        global.defineProperty(\"print\", ff.newFunction([this](std::string str) {\n            this-&gt;print(str);\n        }));\n    }\n};\n</code></pre> <p>The MFeature lets the user set the output stream of the <code>print</code> function by setting the <code>out</code> field. The <code>initialize</code> method then adds the <code>print</code> function to the global JavaScript object.</p> <p>The MFeature can be used like this:</p> <pre><code>using Machine = PrintFeature&lt;jac::MachineBase&gt;;\n\nMachine machine;\nmachine.print.out = std::cout;\n\nmachine.initialize();\n\nmachine.eval(\"print('Hello, world!');\", \"&lt;eval&gt;\", jac::EvalFlags::Global);\n</code></pre>"},{"location":"reference/mfeatures/#defining-a-javascript-module","title":"Defining a JavaScript module","text":"<p>Often, an MFeatures will want to define a JavaScript module. This can be done by using the <code>MachineBase::newModule</code> method.</p> <pre><code>#include &lt;jac/machine.h&gt;\n#include &lt;jac/functionFactory.h&gt;\n\ntemplate&lt;class Next&gt;\nclass PrintFeature : public Next {\npublic:\n    std::ostream out;\n\n    void print(std::string str) {\n        out &lt;&lt; str;\n    }\n\n    void initialize() {\n        Next::initialize();\n\n        jac::FunctionFactory ff(this-&gt;context());\n\n        jac::Module&amp; mdl = this-&gt;newModule(\"printer\");\n        mdl.addExport(\"print\", ff.newFunction([this](std::string str) {\n            this-&gt;print(str);\n        }));\n    }\n};\n</code></pre>"},{"location":"reference/plugins/","title":"Plugins","text":"<p>Plugins are the primary way to extend the functionality of the JavaScript runtime. They are added to the machine dynamically after the runtime initialization.</p> <p>Compared to MFeatures, Plugins are more high-level and should be used to implement functionality that is not directly related to the JavaScript runtime.</p>"},{"location":"reference/plugins/#creating-a-plugin","title":"Creating a Plugin","text":"<p>Plugins are created by subclassing the <code>Plugin</code> class. The <code>Plugin</code> initialization is done in the class constructor, with the Machine passed as an argument. The Machine should be already initialized at this point, so it is safe to interact with the JavaScript runtime.</p> <p>As an example, let's use the <code>ReportPlugin</code> used in tests:</p> <pre><code>class ReportPlugin : public jac::Plugin {\n    std::vector&lt;std::string&gt; _reports;\npublic:\n    void report(std::string report) {\n        _reports.push_back(report);\n    }\n\n    const std::vector&lt;std::string&gt;&amp; getReports() {\n        return _reports;\n    }\npublic:\n    ReportPlugin(jac::MachineBase&amp; machine) {\n        jac::FunctionFactory ff(machine.context());\n        jac::Object global = machine.context().getGlobalObject();\n\n        global.defineProperty(\"report\", ff.newFunction([this](jac::ValueWeak val) {\n            this-&gt;report(val.to&lt;std::string&gt;());\n        }));\n    }\n};\n</code></pre>"},{"location":"reference/plugins/#adding-a-plugin-to-the-machine","title":"Adding a Plugin to the Machine","text":"<p>First, we need to create a Machine, which, at the top of the stack, will have the <code>PluginHolderFeature</code>.</p> <pre><code>using Machine = jac::ComposeMachine&lt;\n    jac::MachineBase,\n    ...\n    jac::PluginHolderFeature\n&gt;;\n</code></pre> <p>The typical way of adding a Plugin to the Machine is by using the <code>jac::PluginManager</code> class, which can be used to add groups of Plugins to the Machine.</p> <pre><code>jac::PluginManager pm;\nauto offset = pm.addPlugin&lt;ReportPlugin&gt;();\n\nMachine machine;\nmachine.initialize();\n\njac::PluginHandle handle = pm.initialize(machine);\n\nmachine.eval(\"report('Hello, world!');\", \"&lt;eval&gt;\", jac::EvalFlags::Global);\n\nReportPlugin&amp; rp = machine.getPlugin&lt;ReportPlugin&gt;(handle + offset);\nassert(rp.getReports() == std::vector&lt;std::string&gt;{\"Hello, world!\"});\n</code></pre> <p>By adding the Plugin to the PluginManager, we get an offset of the Plugin in the group. Next, by using the <code>PluginManager::initialize</code> method, we get the handle of the first plugin in the group. The handle can be used to get the Plugin from the Machine by adding the offset to it.</p>"},{"location":"reference/values/","title":"Values","text":"<p>JavaScript values are represented using <code>ValueWrapper</code> class template and its subclasses. The template argument tells whether the value should be freed upon the destruction of the wrapper. Thus, for convenience, there are type aliases like the following for all value types:</p> <ul> <li><code>using Value = ValueWrapper&lt;true&gt;</code> - a wrapper for a value that should be freed (strong reference)</li> <li><code>using ValueWeak = ValueWrapper&lt;false&gt;</code> - a wrapper for a value that should not be freed (weak reference)</li> </ul> <p><code>Value</code> has ownership of the value (reference), whereas <code>ValueWeak</code> does not, meaning the garbage collector can free the value referenced by a <code>ValueWeak</code> at any time and render the wrapper invalid.</p>"},{"location":"reference/values/#value-types","title":"Value types","text":"<ul> <li><code>Value</code> - plain value, can contain any type including <code>undefined</code> and <code>null</code></li> <li><code>Object</code></li> <li><code>Function</code></li> <li><code>Array</code></li> <li><code>Promise</code></li> <li><code>ArrayBuffer</code></li> <li><code>Exception</code> - either a JavaScript value or an Error template, which can be propagated to the JavaScript</li> </ul> <p>API documentation for the value types can be found in the API documentation.</p>"},{"location":"reference/values/#creating-a-javascript-value","title":"Creating a JavaScript value","text":"<p>New values can be created using the static methods of the wrapper classes.</p> <p>For example<code>Value::from&lt;T&gt;(ContextRef, T)</code> will convert the value to a JavaScript value (if a <code>ConvTraits</code> specialization exists for the type <code>T</code>)</p> <pre><code>Value value = Value::from(machine.context(), 42);\n</code></pre> <p>A new object can be created using <code>Object::create(ContextRef)</code> method.</p> <pre><code>Object obj = Object::create(machine.context());\n</code></pre>"},{"location":"reference/values/#converting-a-javascript-value-to-a-c-type","title":"Converting a JavaScript value to a C++ type","text":"<p>Values can be converted to C++ types using <code>Value::to&lt;T&gt;()</code> method, which will convert the value to a C++ type. There must exist a <code>ConvTraits</code> specialization for the type <code>T</code>.</p> <pre><code>int i = value.to&lt;int&gt;();\n</code></pre> <p>Note that this conversion can be used to convert the value to a <code>Value</code> subclass, such as <code>Object</code>, <code>Function</code>, or <code>Exception</code>.</p> <p>A list of default conversion traits can be found in traits.h</p>"},{"location":"reference/values/#defining-a-custom-conversion-trait","title":"Defining a custom conversion trait","text":"<p>To define a conversion trait for a custom type, simply define a specialization of the <code>ConvTraits</code> template for the type.</p> <pre><code>template&lt;&gt;\nstruct ConvTraits&lt;MyType&gt; {\n    static MyType from(ContextRef ctx, ValueWeak val) {\n        // ...\n    }\n\n    static Value to(ContextRef ctx, MyType value) {\n        // ...\n    }\n};\n</code></pre>"},{"location":"doxygen/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace jac <ul> <li>class ArrayBufferWrapper A wrapper for JSValue with ArrayBuffer type with RAII. </li> <li>class ArrayWrapper A wrapper for JSValue with Array type with RAII. </li> <li>class Atom A wrapper around JSAtom with RAII. In the context of QuickJS, Atom is used to represent identifiers of properties, variables, functions, etc. </li> <li>class BasicStreamFeature </li> <li>class Class </li> <li>struct ComposeMachine </li> <li>struct ComposeMachine&lt; Base &gt; </li> <li>struct ComposeMachine&lt; Base, FirstFeature, MFeatures... &gt; </li> <li>class ContextRef A wrapper around JSContext* providing some related functionality. </li> <li>struct ConvTraits </li> <li>struct ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt; </li> <li>struct ConvTraits&lt; bool &gt; </li> <li>struct ConvTraits&lt; std::chrono::milliseconds &gt; </li> <li>class EventLoopFeature </li> <li>class EventLoopTerminal </li> <li>class EventQueueFeature </li> <li>class ExceptionWrapper An exception wrapper which can either wrap a JSValue or contain an exception description and can be thrown into JS as a specific Error type. </li> <li>class File </li> <li>struct FileProtoBuilder </li> <li>class FilesystemFeature <ul> <li>class Path </li> </ul> </li> <li>class FunctionFactory Various methods for wrapping C++ functions into javascript functions. </li> <li>class FunctionWrapper A wrapper for JSValue with Function type with RAII. </li> <li>class MachineBase </li> <li>class Module A wrapper around JSModuleDef that allows for easy exporting of values. </li> <li>class ModuleLoaderFeature </li> <li>class ObjectWrapper A wrapper for JSValue with Object type with RAII. </li> <li>class OsWritable </li> <li>class Plugin A base class for all plugins. </li> <li>class PluginHandle A handle which can be used to retrieve a plugin from a machine. </li> <li>class PluginHolderFeature An MFeature that allows for inserting plugins into the machine and retrieving them using PluginHandeles. </li> <li>class PluginManager A class for managing groups of plugins and initializing them all at once. </li> <li>class PromiseWrapper A wrapper for JSValue with Promise type with RAII. </li> <li>namespace ProtoBuilder <ul> <li>struct Callable A base class for javascript classes with callable instances. </li> <li>struct LifetimeHandles A base class used to add handles for lifetime events of an instance. </li> <li>struct Opaque A base class for javascript classes with opaque data. </li> <li>struct Properties A base class for javascript classes with added properties. </li> </ul> </li> <li>class Readable </li> <li>struct ReadableProtoBuilder </li> <li>class ReadableRef </li> <li>struct SgnUnwrap </li> <li>struct SgnUnwrap&lt; Res(Args...)&gt; </li> <li>class StdioFeature </li> <li>class StringView A wrapper around QuickJS C-string with automatic memory management. </li> <li>class TimersFeature </li> <li>class ValueWrapper A wrapper around JSValue with RAII. </li> <li>class Writable </li> <li>struct WritableProtoBuilder </li> <li>class WritableRef </li> <li>namespace detail <ul> <li>struct is_base_of_template_impl <ul> <li>struct check </li> <li>struct check&lt; A, std::void_t&lt; A&lt; Derived &gt; &gt; &gt; </li> </ul> </li> </ul> </li> <li>struct is_base_of_template Checks if a type is derived from a template class. </li> </ul> </li> <li>class Fs </li> <li>class Stdio </li> <li>class CompareTimer </li> <li>class Timer </li> <li>namespace noal <ul> <li>class callableany </li> <li>class callableany&lt; Func, Res(Args...)&gt; </li> <li>class funcptr </li> <li>class function </li> <li>class function&lt; Res(Args...), dataSize &gt; </li> <li>class memberconstfuncptr </li> <li>class memberfuncptr </li> <li>struct signatureHelper </li> <li>struct signatureHelper&lt; Res(Func::*)(Args...) &amp; &gt; </li> <li>struct signatureHelper&lt; Res(Func::*)(Args...) const &amp; &gt; </li> <li>struct signatureHelper&lt; Res(Func::*)(Args...) const &gt; </li> <li>struct signatureHelper&lt; Res(Func::*)(Args...)&gt; </li> </ul> </li> <li>namespace std </li> </ul>"},{"location":"doxygen/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src <ul> <li>file noal_func.h </li> <li>dir jac <ul> <li>dir features <ul> <li>file basicStreamFeature.h </li> <li>file eventLoopFeature.h </li> <li>file eventLoopTerminal.h </li> <li>file eventQueueFeature.h </li> <li>file filesystemFeature.h </li> <li>file moduleLoaderFeature.h </li> <li>dir types <ul> <li>file file.h </li> <li>file streams.h </li> </ul> </li> <li>dir util <ul> <li>file ostreamjs.h </li> </ul> </li> <li>file stdioFeature.h </li> <li>file timersFeature.h </li> </ul> </li> <li>dir machine <ul> <li>file atom.h </li> <li>file class.h </li> <li>file context.cpp </li> <li>file context.h </li> <li>file funcUtil.h </li> <li>file functionFactory.h </li> <li>file machine.cpp </li> <li>file machine.h </li> <li>file plugins.h </li> <li>dir internal <ul> <li>file declarations.h </li> </ul> </li> <li>file stringView.h </li> <li>file traits.h </li> <li>file values.h </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"doxygen/namespacejac/","title":"Namespace jac","text":"<p>Namespace List &gt; jac</p>"},{"location":"doxygen/namespacejac/#namespaces","title":"Namespaces","text":"Type Name namespace ProtoBuilder namespace detail"},{"location":"doxygen/namespacejac/#classes","title":"Classes","text":"Type Name class ArrayBufferWrapper &lt;managed&gt;A wrapper for JSValue with ArrayBuffer type with RAII. class ArrayWrapper &lt;managed&gt;A wrapper for JSValue with Array type with RAII. class Atom A wrapper around JSAtom with RAII. In the context of QuickJS, Atom is used to represent identifiers of properties, variables, functions, etc. class BasicStreamFeature &lt;class Next&gt; class Class &lt;class Builder&gt; struct ComposeMachine &lt;class Base, MFeatures&gt; struct ComposeMachine&lt; Base &gt; &lt;class Base&gt; struct ComposeMachine&lt; Base, FirstFeature, MFeatures... &gt; &lt;class Base, FirstFeature, MFeatures&gt; class ContextRef A wrapper around JSContext* providing some related functionality. struct ConvTraits &lt;typename T, typename En&gt; struct ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt; &lt;typename T&gt; struct ConvTraits&lt; bool &gt; &lt;&gt; struct ConvTraits&lt; std::chrono::milliseconds &gt; &lt;&gt; class EventLoopFeature &lt;class Next&gt; class EventLoopTerminal &lt;class Next&gt; class EventQueueFeature &lt;class Next&gt; class ExceptionWrapper &lt;managed&gt;An exception wrapper which can either wrap a JSValue or contain an exception description and can be thrown into JS as a specific Error type. class File struct FileProtoBuilder class FilesystemFeature &lt;class Next&gt; class FunctionFactory Various methods for wrapping C++ functions into javascript functions. class FunctionWrapper &lt;managed&gt;A wrapper for JSValue with Function type with RAII. class MachineBase class Module A wrapper around JSModuleDef that allows for easy exporting of values. class ModuleLoaderFeature &lt;class Next&gt; class ObjectWrapper &lt;managed&gt;A wrapper for JSValue with Object type with RAII. class OsWritable class Plugin A base class for all plugins. class PluginHandle A handle which can be used to retrieve a plugin from a machine. class PluginHolderFeature &lt;typename Next&gt;An MFeature that allows for inserting plugins into the machine and retrieving them using PluginHandeles. class PluginManager A class for managing groups of plugins and initializing them all at once. class PromiseWrapper &lt;managed&gt;A wrapper for JSValue with Promise type with RAII. class Readable struct ReadableProtoBuilder class ReadableRef struct SgnUnwrap &lt;typename Sgn&gt; struct SgnUnwrap&lt; Res(Args...)&gt; &lt;typename Res, Args&gt; class StdioFeature &lt;class Next&gt; class StringView A wrapper around QuickJS C-string with automatic memory management. class TimersFeature &lt;class Next&gt; class ValueWrapper &lt;managed&gt;A wrapper around JSValue with RAII. class Writable struct WritableProtoBuilder class WritableRef struct is_base_of_template &lt;Base, typename Derived&gt;Checks if a type is derived from a template class."},{"location":"doxygen/namespacejac/#public-types","title":"Public Types","text":"Type Name typedef ArrayWrapper&lt; true &gt; Array typedef ArrayBufferWrapper&lt; true &gt; ArrayBuffer typedef ArrayBufferWrapper&lt; false &gt; ArrayBufferWeak typedef ArrayWrapper&lt; false &gt; ArrayWeak enum int EvalFlags typedef ExceptionWrapper&lt; true &gt; Exception typedef ExceptionWrapper&lt; false &gt; ExceptionWeak typedef FunctionWrapper&lt; true &gt; Function typedef FunctionWrapper&lt; false &gt; FunctionWeak typedef ObjectWrapper&lt; true &gt; Object typedef ObjectWrapper&lt; false &gt; ObjectWeak typedef PromiseWrapper&lt; true &gt; Promise typedef PromiseWrapper&lt; false &gt; PromiseWeak enum int PropFlags Flags to specify property access attributes. typedef ValueWrapper&lt; true &gt; Value typedef ValueWrapper&lt; false &gt; ValueWeak typedef typename is_base_of_template&lt; Base, Derived &gt;::type is_base_of_template_t"},{"location":"doxygen/namespacejac/#public-attributes","title":"Public Attributes","text":"Type Name constexpr bool is_base_of_template_v   = <code>[**is\\_base\\_of\\_template**](structjac_1_1is__base__of__template.md)&amp;lt;Base, Derived&amp;gt;::value</code>"},{"location":"doxygen/namespacejac/#public-functions","title":"Public Functions","text":"Type Name SgnUnwrap (Res(Class::*)(Args...))  std::tuple&lt; Args... &gt; convertArgs (ContextRef ctx, std::vector&lt; ValueWeak &gt; argv, std::index_sequence&lt; Is... &gt;)  std::tuple&lt; Args... &gt; convertArgs (ContextRef ctx, JSValueConst * argv, int argc, std::index_sequence&lt; Is... &gt;)  T fromValue (ContextRef ctx, ValueWeak val)  constexpr EvalFlags operator&amp; (EvalFlags a, EvalFlags b)  constexpr PropFlags operator&amp; (PropFlags a, PropFlags b)  constexpr EvalFlags operator| (EvalFlags a, EvalFlags b)  constexpr PropFlags operator| (PropFlags a, PropFlags b)  Value processCall (ContextRef ctx, ValueWeak, std::vector&lt; ValueWeak &gt; argv, Func &amp; f)  JSValue processCallRaw (ContextRef ctx, JSValueConst, int argc, JSValueConst * argv, Func &amp; f)  Value processCallThis (ContextRef ctx, ValueWeak thisVal, std::vector&lt; ValueWeak &gt; argv, Func &amp; f)  Value processCallThisVariadic (ContextRef ctx, ValueWeak thisVal, std::vector&lt; ValueWeak &gt; argv, Func &amp; f)  Value processCallVariadic (ContextRef ctx, ValueWeak, std::vector&lt; ValueWeak &gt; argv, Func &amp; f)  JSValue processCallVariadicRaw (ContextRef ctx, JSValueConst, int argc, JSValueConst * argv, Func &amp; f)  JSValue propagateExceptions (ContextRef ctx, Func &amp; f) noexcept JSValue propagateExceptions (ContextRef ctx, Func &amp;&amp; f) noexcept constexpr bool static_false ()  Value toValue (ContextRef ctx, T val)"},{"location":"doxygen/namespacejac/#public-static-functions","title":"Public Static Functions","text":"Type Name void initializeIo (Machine &amp; machine)"},{"location":"doxygen/namespacejac/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/namespacejac/#typedef-array","title":"typedef Array","text":"<pre><code>using jac::Array = typedef ArrayWrapper&lt;true&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-arraybuffer","title":"typedef ArrayBuffer","text":"<pre><code>using jac::ArrayBuffer = typedef ArrayBufferWrapper&lt;true&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-arraybufferweak","title":"typedef ArrayBufferWeak","text":"<pre><code>using jac::ArrayBufferWeak = typedef ArrayBufferWrapper&lt;false&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-arrayweak","title":"typedef ArrayWeak","text":"<pre><code>using jac::ArrayWeak = typedef ArrayWrapper&lt;false&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#enum-evalflags","title":"enum EvalFlags","text":"<pre><code>enum jac::EvalFlags {\n    Global = JS_EVAL_TYPE_GLOBAL,\n    Module = JS_EVAL_TYPE_MODULE,\n    Strict = JS_EVAL_FLAG_STRICT,\n    CompileOnly = JS_EVAL_FLAG_COMPILE_ONLY,\n    BacktraceBarrier = JS_EVAL_FLAG_BACKTRACE_BARRIER\n};\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-exception","title":"typedef Exception","text":"<pre><code>using jac::Exception = typedef ExceptionWrapper&lt;true&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-exceptionweak","title":"typedef ExceptionWeak","text":"<pre><code>using jac::ExceptionWeak = typedef ExceptionWrapper&lt;false&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-function","title":"typedef Function","text":"<pre><code>using jac::Function = typedef FunctionWrapper&lt;true&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-functionweak","title":"typedef FunctionWeak","text":"<pre><code>using jac::FunctionWeak = typedef FunctionWrapper&lt;false&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-object","title":"typedef Object","text":"<pre><code>using jac::Object = typedef ObjectWrapper&lt;true&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-objectweak","title":"typedef ObjectWeak","text":"<pre><code>using jac::ObjectWeak = typedef ObjectWrapper&lt;false&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-promise","title":"typedef Promise","text":"<pre><code>using jac::Promise = typedef PromiseWrapper&lt;true&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-promiseweak","title":"typedef PromiseWeak","text":"<pre><code>using jac::PromiseWeak = typedef PromiseWrapper&lt;false&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#enum-propflags","title":"enum PropFlags","text":"<p>Flags to specify property access attributes. <pre><code>enum jac::PropFlags {\n    Default = 0,\n    Configurable = JS_PROP_CONFIGURABLE,\n    Writable = JS_PROP_WRITABLE,\n    Enumerable = JS_PROP_ENUMERABLE,\n    C_W_E = JS_PROP_C_W_E\n};\n</code></pre></p>"},{"location":"doxygen/namespacejac/#typedef-value","title":"typedef Value","text":"<pre><code>using jac::Value = typedef ValueWrapper&lt;true&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-valueweak","title":"typedef ValueWeak","text":"<pre><code>using jac::ValueWeak = typedef ValueWrapper&lt;false&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#typedef-is_base_of_template_t","title":"typedef is_base_of_template_t","text":"<pre><code>using jac::is_base_of_template_t = typedef typename is_base_of_template&lt;Base, Derived&gt;::type;\n</code></pre>"},{"location":"doxygen/namespacejac/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/namespacejac/#variable-is_base_of_template_v","title":"variable is_base_of_template_v","text":"<pre><code>constexpr bool jac::is_base_of_template_v;\n</code></pre>"},{"location":"doxygen/namespacejac/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/namespacejac/#function-sgnunwrap","title":"function SgnUnwrap","text":"<pre><code>template&lt;class Class, typename Res, typename... Args&gt;\njac::SgnUnwrap (\n    Res(Class::*)(Args...)\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-convertargs","title":"function convertArgs","text":"<pre><code>template&lt;typename... Args, std::size_t... Is&gt;\ninline std::tuple&lt; Args... &gt; jac::convertArgs (\n    ContextRef ctx,\n    std::vector&lt; ValueWeak &gt; argv,\n    std::index_sequence&lt; Is... &gt;\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-convertargs_1","title":"function convertArgs","text":"<pre><code>template&lt;typename... Args, std::size_t... Is&gt;\ninline std::tuple&lt; Args... &gt; jac::convertArgs (\n    ContextRef ctx,\n    JSValueConst * argv,\n    int argc,\n    std::index_sequence&lt; Is... &gt;\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-fromvalue","title":"function fromValue","text":"<pre><code>template&lt;typename T&gt;\nT jac::fromValue (\n    ContextRef ctx,\n    ValueWeak val\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-operator","title":"function operator&amp;","text":"<pre><code>inline constexpr EvalFlags jac::operator&amp; (\n    EvalFlags a,\n    EvalFlags b\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-operator_1","title":"function operator&amp;","text":"<pre><code>inline constexpr PropFlags jac::operator&amp; (\n    PropFlags a,\n    PropFlags b\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-operator_2","title":"function operator|","text":"<pre><code>inline constexpr EvalFlags jac::operator| (\n    EvalFlags a,\n    EvalFlags b\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-operator_3","title":"function operator|","text":"<pre><code>inline constexpr PropFlags jac::operator| (\n    PropFlags a,\n    PropFlags b\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-processcall","title":"function processCall","text":"<pre><code>template&lt;typename Func, typename Res, typename... Args&gt;\ninline Value jac::processCall (\n    ContextRef ctx,\n    ValueWeak,\n    std::vector&lt; ValueWeak &gt; argv,\n    Func &amp; f\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-processcallraw","title":"function processCallRaw","text":"<pre><code>template&lt;typename Func, typename Res, typename... Args&gt;\ninline JSValue jac::processCallRaw (\n    ContextRef ctx,\n    JSValueConst,\n    int argc,\n    JSValueConst * argv,\n    Func &amp; f\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-processcallthis","title":"function processCallThis","text":"<pre><code>template&lt;typename Func, typename Res, typename... Args&gt;\ninline Value jac::processCallThis (\n    ContextRef ctx,\n    ValueWeak thisVal,\n    std::vector&lt; ValueWeak &gt; argv,\n    Func &amp; f\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-processcallthisvariadic","title":"function processCallThisVariadic","text":"<pre><code>template&lt;typename Func, typename Res&gt;\ninline Value jac::processCallThisVariadic (\n    ContextRef ctx,\n    ValueWeak thisVal,\n    std::vector&lt; ValueWeak &gt; argv,\n    Func &amp; f\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-processcallvariadic","title":"function processCallVariadic","text":"<pre><code>template&lt;typename Func, typename Res&gt;\ninline Value jac::processCallVariadic (\n    ContextRef ctx,\n    ValueWeak,\n    std::vector&lt; ValueWeak &gt; argv,\n    Func &amp; f\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-processcallvariadicraw","title":"function processCallVariadicRaw","text":"<pre><code>template&lt;typename Func, typename Res&gt;\ninline JSValue jac::processCallVariadicRaw (\n    ContextRef ctx,\n    JSValueConst,\n    int argc,\n    JSValueConst * argv,\n    Func &amp; f\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-propagateexceptions","title":"function propagateExceptions","text":"<pre><code>template&lt;typename Func&gt;\ninline JSValue jac::propagateExceptions (\n    ContextRef ctx,\n    Func &amp; f\n) noexcept\n</code></pre> <p>Various functions to process function calls with unprocessed javascript arguments. Arguments and return value of the functions are automatically converted to and from javascript values. Exceptions thrown within the functions are caught and propagated to the javascript side. </p>"},{"location":"doxygen/namespacejac/#function-propagateexceptions_1","title":"function propagateExceptions","text":"<pre><code>template&lt;typename Func&gt;\ninline JSValue jac::propagateExceptions (\n    ContextRef ctx,\n    Func &amp;&amp; f\n) noexcept\n</code></pre>"},{"location":"doxygen/namespacejac/#function-static_false","title":"function static_false","text":"<pre><code>template&lt;typename T&gt;\nconstexpr bool jac::static_false () \n</code></pre>"},{"location":"doxygen/namespacejac/#function-tovalue","title":"function toValue","text":"<pre><code>template&lt;typename T&gt;\nValue jac::toValue (\n    ContextRef ctx,\n    T val\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/namespacejac/#function-initializeio","title":"function initializeIo","text":"<pre><code>template&lt;class Machine&gt;\nstatic inline void jac::initializeIo (\n    Machine &amp; machine\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/basicStreamFeature.h</code></p>"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/","title":"Class jac::ArrayBufferWrapper","text":"<p>template &lt;bool managed&gt;</p> <p>ClassList &gt; jac &gt; ArrayBufferWrapper</p> <p>A wrapper for JSValue with ArrayBuffer type with RAII. More...</p> <ul> <li><code>#include &lt;values.h&gt;</code></li> </ul> <p>Inherits the following classes: jac::ObjectWrapper</p>"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#public-functions","title":"Public Functions","text":"Type Name ArrayBufferWrapper (ObjectWrapper&lt; managed &gt; value) Wrap an existing JSValue. If managed is true, JSValue will be freed when the ArrayBuffer is destroyed. ArrayBufferWrapper (ContextRef ctx, JSValue val)  uint8_t * data () Get a pointer to the underlying buffer. size_t size () Get the size of the underlying buffer. std::span&lt; T &gt; typedView () Get a typed view of the underlying buffer."},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#public-functions-inherited-from-jacobjectwrapper","title":"Public Functions inherited from jac::ObjectWrapper","text":"<p>See jac::ObjectWrapper</p> Type Name ObjectWrapper (ValueWrapper&lt; managed &gt; value) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Object is destroyed. ObjectWrapper (ContextRef ctx, JSValue val)  void defineProperty (Id id, Value value, PropFlags flags=PropFlags::Default) Define a property of the object. void deleteProperty (Id id) Delete a property of the object. T get (Atom prop) Get a property of the object. T get (const std::string &amp; name)  T get (uint32_t idx)  Object getPrototype () Get the prototype of the object. bool hasProperty (Id id) Check if the object has a property. Res invoke (Atom key, Args... args) Invoke a method of the object. Res invoke (const std::string &amp; key, Args... args)  Res invoke (uint32_t idx, Args... args)  void set (Atom prop, T val) Set a property of the object. void set (const std::string &amp; name, T val)  void set (uint32_t idx, T val)  void setPrototype (Object proto) Set the prototype of the object."},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#public-functions-inherited-from-jacvaluewrapper","title":"Public Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ValueWrapper (ContextRef ctx, JSValue val) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Value is destroyed. ValueWrapper (const ValueWrapper &amp; other)  ValueWrapper (ValueWrapper &amp;&amp; other)  JSValue &amp; getVal () Get reference to the underlying JSValue. bool isArray () Check if the Value is an array. bool isFunction () Check if the Value is a function. bool isNull () Check if the Value is null. bool isObject () Check if the Value is an object. bool isUndefined () Check if the Value is undefined. std::pair&lt; ContextRef, JSValue &gt; loot () Release ownership of the JSValue. The JSValue will have to be freed manually. operator ValueWeak ()  ValueWrapper &amp; operator= (const ValueWrapper &amp; other)  ValueWrapper &amp; operator= (ValueWrapper &amp;&amp; other)  Value stringify (int indent=0) Convert the Value to a JSON representation. T to () Convert the Value to a specified type. StringView toString () Convert the Value to a StringView . ~ValueWrapper ()"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#public-static-functions","title":"Public Static Functions","text":"Type Name ArrayBuffer create (ContextRef ctx, size_t size) Create a new ArrayBuffer object. ArrayBuffer create (ContextRef ctx, std::span&lt; const uint8_t &gt; data) Create a new ArrayBuffer object."},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#public-static-functions-inherited-from-jacobjectwrapper","title":"Public Static Functions inherited from jac::ObjectWrapper","text":"<p>See jac::ObjectWrapper</p> Type Name Object create (ContextRef ctx) Create a new empty object."},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#public-static-functions-inherited-from-jacvaluewrapper","title":"Public Static Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name Value from (ContextRef ctx, T val) Create a new Value by converting a given value. Value fromJSON (ContextRef ctx, std::string json, std::string filename=\"&lt;json&gt;\", bool extended=false) Create a new Value from a given JSON string. Value null (ContextRef ctx) Create a new Value containing null. Value undefined (ContextRef ctx) Create a new Value containing undefined."},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#protected-attributes-inherited-from-jacvaluewrapper","title":"Protected Attributes inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ContextRef _ctx JSValue _val"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#protected-static-functions","title":"Protected Static Functions","text":"Type Name void freeArrayBuffer (JSRuntime *, void *, void * ptr)"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>managed</code> whether the JSValue should be freed when the wrapper is destroyed. </li> </ul>"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#function-arraybufferwrapper-12","title":"function ArrayBufferWrapper [1/2]","text":"<p>Wrap an existing JSValue. If managed is true, JSValue will be freed when the ArrayBuffer is destroyed. <pre><code>inline jac::ArrayBufferWrapper::ArrayBufferWrapper (\n    ObjectWrapper &lt; managed &gt; value\n) \n</code></pre></p> <p>Note:</p> <p>Used internally when directly working with QuickJS API. New ArrayBuffer should be created using ArrayBuffer::create().</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>val</code> JSValue to wrap </li> </ul>"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#function-arraybufferwrapper-22","title":"function ArrayBufferWrapper [2/2]","text":"<pre><code>inline jac::ArrayBufferWrapper::ArrayBufferWrapper (\n    ContextRef ctx,\n    JSValue val\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#function-data","title":"function data","text":"<p>Get a pointer to the underlying buffer. <pre><code>inline uint8_t * jac::ArrayBufferWrapper::data () \n</code></pre></p> <p>Returns:</p> <p>Pointer to the data </p>"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#function-size","title":"function size","text":"<p>Get the size of the underlying buffer. <pre><code>inline size_t jac::ArrayBufferWrapper::size () \n</code></pre></p> <p>Returns:</p> <p>Size of the data </p>"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#function-typedview","title":"function typedView","text":"<p>Get a typed view of the underlying buffer. <pre><code>template&lt;typename T&gt;\ninline std::span&lt; T &gt; jac::ArrayBufferWrapper::typedView () \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> Type of the view </li> </ul> <p>Returns:</p> <p>Typed view of the data </p>"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#function-create-12","title":"function create [1/2]","text":"<p>Create a new ArrayBuffer object. <pre><code>static inline ArrayBuffer jac::ArrayBufferWrapper::create (\n    ContextRef ctx,\n    size_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>size</code> size of the buffer </li> </ul> <p>Returns:</p> <p>The new ArrayBuffer object </p>"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#function-create-22","title":"function create [2/2]","text":"<p>Create a new ArrayBuffer object. <pre><code>static inline ArrayBuffer jac::ArrayBufferWrapper::create (\n    ContextRef ctx,\n    std::span&lt; const uint8_t &gt; data\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>data</code> data to copy into the buffer </li> </ul> <p>Returns:</p> <p>The new ArrayBuffer object </p>"},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#protected-static-functions-documentation","title":"Protected Static Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ArrayBufferWrapper/#function-freearraybuffer","title":"function freeArrayBuffer","text":"<pre><code>static inline void jac::ArrayBufferWrapper::freeArrayBuffer (\n    JSRuntime *,\n    void *,\n    void * ptr\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/values.h</code></p>"},{"location":"doxygen/classjac_1_1ArrayWrapper/","title":"Class jac::ArrayWrapper","text":"<p>template &lt;bool managed&gt;</p> <p>ClassList &gt; jac &gt; ArrayWrapper</p> <p>A wrapper for JSValue with Array type with RAII. More...</p> <ul> <li><code>#include &lt;values.h&gt;</code></li> </ul> <p>Inherits the following classes: jac::ObjectWrapper</p>"},{"location":"doxygen/classjac_1_1ArrayWrapper/#public-functions","title":"Public Functions","text":"Type Name ArrayWrapper (ObjectWrapper&lt; managed &gt; value) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Array is destroyed. ArrayWrapper (ContextRef ctx, JSValue val)  int length () Get the length of the array."},{"location":"doxygen/classjac_1_1ArrayWrapper/#public-functions-inherited-from-jacobjectwrapper","title":"Public Functions inherited from jac::ObjectWrapper","text":"<p>See jac::ObjectWrapper</p> Type Name ObjectWrapper (ValueWrapper&lt; managed &gt; value) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Object is destroyed. ObjectWrapper (ContextRef ctx, JSValue val)  void defineProperty (Id id, Value value, PropFlags flags=PropFlags::Default) Define a property of the object. void deleteProperty (Id id) Delete a property of the object. T get (Atom prop) Get a property of the object. T get (const std::string &amp; name)  T get (uint32_t idx)  Object getPrototype () Get the prototype of the object. bool hasProperty (Id id) Check if the object has a property. Res invoke (Atom key, Args... args) Invoke a method of the object. Res invoke (const std::string &amp; key, Args... args)  Res invoke (uint32_t idx, Args... args)  void set (Atom prop, T val) Set a property of the object. void set (const std::string &amp; name, T val)  void set (uint32_t idx, T val)  void setPrototype (Object proto) Set the prototype of the object."},{"location":"doxygen/classjac_1_1ArrayWrapper/#public-functions-inherited-from-jacvaluewrapper","title":"Public Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ValueWrapper (ContextRef ctx, JSValue val) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Value is destroyed. ValueWrapper (const ValueWrapper &amp; other)  ValueWrapper (ValueWrapper &amp;&amp; other)  JSValue &amp; getVal () Get reference to the underlying JSValue. bool isArray () Check if the Value is an array. bool isFunction () Check if the Value is a function. bool isNull () Check if the Value is null. bool isObject () Check if the Value is an object. bool isUndefined () Check if the Value is undefined. std::pair&lt; ContextRef, JSValue &gt; loot () Release ownership of the JSValue. The JSValue will have to be freed manually. operator ValueWeak ()  ValueWrapper &amp; operator= (const ValueWrapper &amp; other)  ValueWrapper &amp; operator= (ValueWrapper &amp;&amp; other)  Value stringify (int indent=0) Convert the Value to a JSON representation. T to () Convert the Value to a specified type. StringView toString () Convert the Value to a StringView . ~ValueWrapper ()"},{"location":"doxygen/classjac_1_1ArrayWrapper/#public-static-functions","title":"Public Static Functions","text":"Type Name Array create (ContextRef ctx) Create a new Array object."},{"location":"doxygen/classjac_1_1ArrayWrapper/#public-static-functions-inherited-from-jacobjectwrapper","title":"Public Static Functions inherited from jac::ObjectWrapper","text":"<p>See jac::ObjectWrapper</p> Type Name Object create (ContextRef ctx) Create a new empty object."},{"location":"doxygen/classjac_1_1ArrayWrapper/#public-static-functions-inherited-from-jacvaluewrapper","title":"Public Static Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name Value from (ContextRef ctx, T val) Create a new Value by converting a given value. Value fromJSON (ContextRef ctx, std::string json, std::string filename=\"&lt;json&gt;\", bool extended=false) Create a new Value from a given JSON string. Value null (ContextRef ctx) Create a new Value containing null. Value undefined (ContextRef ctx) Create a new Value containing undefined."},{"location":"doxygen/classjac_1_1ArrayWrapper/#protected-attributes-inherited-from-jacvaluewrapper","title":"Protected Attributes inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ContextRef _ctx JSValue _val"},{"location":"doxygen/classjac_1_1ArrayWrapper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>managed</code> whether the JSValue should be freed when the wrapper is destroyed. </li> </ul>"},{"location":"doxygen/classjac_1_1ArrayWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ArrayWrapper/#function-arraywrapper-12","title":"function ArrayWrapper [1/2]","text":"<p>Wrap an existing JSValue. If managed is true, JSValue will be freed when the Array is destroyed. <pre><code>inline jac::ArrayWrapper::ArrayWrapper (\n    ObjectWrapper &lt; managed &gt; value\n) \n</code></pre></p> <p>Note:</p> <p>Used internally when directly working with QuickJS API. New Array should be created using Array::create().</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>val</code> JSValue to wrap </li> </ul>"},{"location":"doxygen/classjac_1_1ArrayWrapper/#function-arraywrapper-22","title":"function ArrayWrapper [2/2]","text":"<pre><code>inline jac::ArrayWrapper::ArrayWrapper (\n    ContextRef ctx,\n    JSValue val\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ArrayWrapper/#function-length","title":"function length","text":"<p>Get the length of the array. <pre><code>inline int jac::ArrayWrapper::length () \n</code></pre></p> <p>Returns:</p> <p>The length </p>"},{"location":"doxygen/classjac_1_1ArrayWrapper/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ArrayWrapper/#function-create","title":"function create","text":"<p>Create a new Array object. <pre><code>static inline Array jac::ArrayWrapper::create (\n    ContextRef ctx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> </ul> <p>Returns:</p> <p>The new Array object </p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/values.h</code></p>"},{"location":"doxygen/classjac_1_1Atom/","title":"Class jac::Atom","text":"<p>ClassList &gt; jac &gt; Atom</p> <p>A wrapper around JSAtom with RAII. In the context of QuickJS, Atom is used to represent identifiers of properties, variables, functions, etc.</p> <ul> <li><code>#include &lt;atom.h&gt;</code></li> </ul>"},{"location":"doxygen/classjac_1_1Atom/#public-functions","title":"Public Functions","text":"Type Name Atom (ContextRef ctx, JSAtom atom) Wrap an existing JSAtom. The JSAtom will be freed when the Atom is destroyed. Atom (const Atom &amp; other)  Atom (Atom &amp;&amp; other)  JSAtom &amp; get () Get reference to the underlying JSAtom. std::pair&lt; ContextRef, JSAtom &gt; loot () Release ownership of the JSAtom. The JSAtom will have to be freed manually. Atom &amp; operator= (const Atom &amp; other)  Atom &amp; operator= (Atom &amp;&amp; other)  StringView toString () constGet string representation of the atom. ~Atom ()"},{"location":"doxygen/classjac_1_1Atom/#public-static-functions","title":"Public Static Functions","text":"Type Name Atom create (ContextRef ctx, uint32_t value) Create a new atom from an uint32_t value. Atom create (ContextRef ctx, const char * value) Create a new atom from a string. Atom create (ContextRef ctx, std::string value) Create a new atom from a string."},{"location":"doxygen/classjac_1_1Atom/#protected-attributes","title":"Protected Attributes","text":"Type Name JSAtom _atom ContextRef _ctx"},{"location":"doxygen/classjac_1_1Atom/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Atom/#function-atom-13","title":"function Atom [1/3]","text":"<p>Wrap an existing JSAtom. The JSAtom will be freed when the Atom is destroyed. <pre><code>inline jac::Atom::Atom (\n    ContextRef ctx,\n    JSAtom atom\n) \n</code></pre></p> <p>Note:</p> <p>Used internally when directly working with QuickJS API. New Atom should be created using Atom::create().</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>atom</code> JSAtom to wrap </li> </ul>"},{"location":"doxygen/classjac_1_1Atom/#function-atom-23","title":"function Atom [2/3]","text":"<pre><code>inline jac::Atom::Atom (\n    const Atom &amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Atom/#function-atom-33","title":"function Atom [3/3]","text":"<pre><code>inline jac::Atom::Atom (\n    Atom &amp;&amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Atom/#function-get","title":"function get","text":"<p>Get reference to the underlying JSAtom. <pre><code>inline JSAtom &amp; jac::Atom::get () \n</code></pre></p> <p>Returns:</p> <p>JSAtom reference </p>"},{"location":"doxygen/classjac_1_1Atom/#function-loot","title":"function loot","text":"<p>Release ownership of the JSAtom. The JSAtom will have to be freed manually. <pre><code>inline std::pair&lt; ContextRef , JSAtom &gt; jac::Atom::loot () \n</code></pre></p> <p>Note:</p> <p>After this call, the Atom will be in an invalid state.</p> <p>Returns:</p> <p>Pair of ContextRef and JSAtom </p>"},{"location":"doxygen/classjac_1_1Atom/#function-operator","title":"function operator=","text":"<pre><code>inline Atom &amp; jac::Atom::operator= (\n    const Atom &amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Atom/#function-operator_1","title":"function operator=","text":"<pre><code>inline Atom &amp; jac::Atom::operator= (\n    Atom &amp;&amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Atom/#function-tostring","title":"function toString","text":"<p>Get string representation of the atom. <pre><code>inline StringView jac::Atom::toString () const\n</code></pre></p> <p>Returns:</p> <p>StringView </p>"},{"location":"doxygen/classjac_1_1Atom/#function-atom","title":"function ~Atom","text":"<pre><code>inline jac::Atom::~Atom () \n</code></pre>"},{"location":"doxygen/classjac_1_1Atom/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Atom/#function-create-13","title":"function create [1/3]","text":"<p>Create a new atom from an uint32_t value. <pre><code>static inline Atom jac::Atom::create (\n    ContextRef ctx,\n    uint32_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to create the atom in </li> <li><code>value</code> the value </li> </ul> <p>Returns:</p> <p>The newly constructed atom </p>"},{"location":"doxygen/classjac_1_1Atom/#function-create-23","title":"function create [2/3]","text":"<p>Create a new atom from a string. <pre><code>static inline Atom jac::Atom::create (\n    ContextRef ctx,\n    const char * value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to create the atom in </li> <li><code>value</code> the value </li> </ul> <p>Returns:</p> <p>The newly constructed atom </p>"},{"location":"doxygen/classjac_1_1Atom/#function-create-33","title":"function create [3/3]","text":"<p>Create a new atom from a string. <pre><code>static inline Atom jac::Atom::create (\n    ContextRef ctx,\n    std::string value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to create the atom in </li> <li><code>value</code> the value </li> </ul> <p>Returns:</p> <p>The newly constructed atom </p>"},{"location":"doxygen/classjac_1_1Atom/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"doxygen/classjac_1_1Atom/#variable-_atom","title":"variable _atom","text":"<pre><code>JSAtom jac::Atom::_atom;\n</code></pre>"},{"location":"doxygen/classjac_1_1Atom/#variable-_ctx","title":"variable _ctx","text":"<pre><code>ContextRef jac::Atom::_ctx;\n</code></pre>"},{"location":"doxygen/classjac_1_1Atom/#friends-documentation","title":"Friends Documentation","text":""},{"location":"doxygen/classjac_1_1Atom/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; jac::Atom::operator&lt;&lt; (\n    std::ostream &amp; os,\n    Atom &amp; val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/atom.h</code></p>"},{"location":"doxygen/classjac_1_1BasicStreamFeature/","title":"Class jac::BasicStreamFeature","text":"<p>template &lt;class Next&gt;</p> <p>ClassList &gt; jac &gt; BasicStreamFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"doxygen/classjac_1_1BasicStreamFeature/#public-types","title":"Public Types","text":"Type Name typedef Class&lt; ReadableProtoBuilder &gt; ReadableClass typedef Class&lt; WritableProtoBuilder &gt; WritableClass"},{"location":"doxygen/classjac_1_1BasicStreamFeature/#public-functions","title":"Public Functions","text":"Type Name BasicStreamFeature ()  void initialize ()"},{"location":"doxygen/classjac_1_1BasicStreamFeature/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/classjac_1_1BasicStreamFeature/#typedef-readableclass","title":"typedef ReadableClass","text":"<pre><code>using jac::BasicStreamFeature&lt; Next &gt;::ReadableClass =  Class&lt;ReadableProtoBuilder&gt;;\n</code></pre>"},{"location":"doxygen/classjac_1_1BasicStreamFeature/#typedef-writableclass","title":"typedef WritableClass","text":"<pre><code>using jac::BasicStreamFeature&lt; Next &gt;::WritableClass =  Class&lt;WritableProtoBuilder&gt;;\n</code></pre>"},{"location":"doxygen/classjac_1_1BasicStreamFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1BasicStreamFeature/#function-basicstreamfeature","title":"function BasicStreamFeature","text":"<pre><code>inline jac::BasicStreamFeature::BasicStreamFeature () \n</code></pre>"},{"location":"doxygen/classjac_1_1BasicStreamFeature/#function-initialize","title":"function initialize","text":"<pre><code>inline void jac::BasicStreamFeature::initialize () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/basicStreamFeature.h</code></p>"},{"location":"doxygen/classjac_1_1Class/","title":"Class jac::Class","text":"<p>template &lt;class Builder&gt;</p> <p>ClassList &gt; jac &gt; Class</p>"},{"location":"doxygen/classjac_1_1Class/#public-static-functions","title":"Public Static Functions","text":"Type Name std::enable_if_t&lt; is_base_of_template_v&lt; ProtoBuilder::Opaque, Bdr &gt; &amp;&amp;std::is_base_of_v&lt; typename Bdr::OpaqueType, T &gt; &amp;&amp;std::is_same_v&lt; Bdr, Builder &gt;, Value &gt; createInstance (ContextRef ctx, T * instance) Create a new instance of this class in given context. JSClassID getClassId () Get the class id of this class. Function getConstructor (ContextRef ctx) Get the constructor object of this class in given context. Object getProto (ContextRef ctx) Get the prototype object of this class in given context. void init (std::string name, bool isCtor=false) Initialize the class. void initContext (ContextRef ctx) Initialize the class prototype."},{"location":"doxygen/classjac_1_1Class/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Class/#function-createinstance","title":"function createInstance","text":"<p>Create a new instance of this class in given context. <pre><code>template&lt;typename T, typename Bdr&gt;\nstatic inline std::enable_if_t&lt; is_base_of_template_v&lt; ProtoBuilder::Opaque , Bdr &gt; &amp;&amp;std::is_base_of_v&lt; typename Bdr::OpaqueType, T &gt; &amp;&amp;std::is_same_v&lt; Bdr, Builder &gt;, Value &gt; jac::Class::createInstance (\n    ContextRef ctx,\n    T * instance\n) \n</code></pre></p> <p>Note:</p> <p>if the class wasn't initialized in the context, it will be initialized</p> <p>Parameters:</p> <ul> <li><code>ctx</code> the context </li> <li><code>instance</code> a new-allocated instance to be saved as opaque data </li> </ul> <p>Returns:</p> <p>The new instance </p>"},{"location":"doxygen/classjac_1_1Class/#function-getclassid","title":"function getClassId","text":"<p>Get the class id of this class. <pre><code>static inline JSClassID jac::Class::getClassId () \n</code></pre></p> <p>Returns:</p> <p>JSClassID </p>"},{"location":"doxygen/classjac_1_1Class/#function-getconstructor","title":"function getConstructor","text":"<p>Get the constructor object of this class in given context. <pre><code>static inline Function jac::Class::getConstructor (\n    ContextRef ctx\n) \n</code></pre></p> <p>Note:</p> <p>if the class wasn't initialized in the context, it will be initialized</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> </ul> <p>Returns:</p> <p>The constructor object </p>"},{"location":"doxygen/classjac_1_1Class/#function-getproto","title":"function getProto","text":"<p>Get the prototype object of this class in given context. <pre><code>static inline Object jac::Class::getProto (\n    ContextRef ctx\n) \n</code></pre></p> <p>Note:</p> <p>if the class wasn't initialized in the context, it will be initialized</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> </ul> <p>Returns:</p> <p>The prototype object </p>"},{"location":"doxygen/classjac_1_1Class/#function-init","title":"function init","text":"<p>Initialize the class. <pre><code>static inline void jac::Class::init (\n    std::string name,\n    bool isCtor=false\n) \n</code></pre></p> <p>Note:</p> <p>This function should be called only once. Any subsequent calls with different parameters will throw an exception</p> <p>Parameters:</p> <ul> <li><code>name</code> name of the class </li> <li><code>isCtor</code> whether or not the class is callable a constructor (if it's callable at all) </li> </ul>"},{"location":"doxygen/classjac_1_1Class/#function-initcontext","title":"function initContext","text":"<p>Initialize the class prototype. <pre><code>static inline void jac::Class::initContext (\n    ContextRef ctx\n) \n</code></pre></p> <p>Note:</p> <p>If the class is already initialized, this function does nothing</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> </ul> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/structjac_1_1ComposeMachine/","title":"Struct jac::ComposeMachine","text":"<p>template &lt;class Base, template&lt; class &gt; class... MFeatures&gt;</p> <p>ClassList &gt; jac &gt; ComposeMachine</p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/machine.h</code></p>"},{"location":"doxygen/structjac_1_1ComposeMachine_3_01Base_01_4/","title":"Struct jac::ComposeMachine&lt; Base &gt;","text":"<p>template &lt;class Base&gt;</p> <p>ClassList &gt; jac &gt; ComposeMachine&lt; Base &gt;</p> <p>Inherits the following classes: Base</p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/machine.h</code></p>"},{"location":"doxygen/structjac_1_1ComposeMachine_3_01Base_00_01FirstFeature_00_01MFeatures_8_8_8_01_4/","title":"Struct jac::ComposeMachine&lt; Base, FirstFeature, MFeatures... &gt;","text":"<p>template &lt;class Base, template&lt; class &gt; class FirstFeature, template&lt; class &gt; class... MFeatures&gt;</p> <p>ClassList &gt; jac &gt; ComposeMachine&lt; Base, FirstFeature, MFeatures... &gt;</p> <p>Inherits the following classes: jac::ComposeMachine</p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/machine.h</code></p>"},{"location":"doxygen/classjac_1_1ContextRef/","title":"Class jac::ContextRef","text":"<p>ClassList &gt; jac &gt; ContextRef</p> <p>A wrapper around JSContext* providing some related functionality. </p> <ul> <li><code>#include &lt;context.h&gt;</code></li> </ul>"},{"location":"doxygen/classjac_1_1ContextRef/#public-functions","title":"Public Functions","text":"Type Name ContextRef (JSContext * ctx)  JSContext * get () Get the underlying JSContext*. Exception getException () Get pending exception thrown in this context. Object getGlobalObject () Get the global object of this context. operator JSContext * ()  operator JSContext * () const operator bool ()  ContextRef &amp; operator= (JSContext * ctx)"},{"location":"doxygen/classjac_1_1ContextRef/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ContextRef/#function-contextref","title":"function ContextRef","text":"<pre><code>inline jac::ContextRef::ContextRef (\n    JSContext * ctx\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ContextRef/#function-get","title":"function get","text":"<p>Get the underlying JSContext*. <pre><code>inline JSContext * jac::ContextRef::get () \n</code></pre></p> <p>Returns:</p> <p>The JSContext* </p>"},{"location":"doxygen/classjac_1_1ContextRef/#function-getexception","title":"function getException","text":"<p>Get pending exception thrown in this context. <pre><code>Exception jac::ContextRef::getException () \n</code></pre></p> <p>Note:</p> <p>If there is no pending exception, new Exception will be thrown</p> <p>Returns:</p> <p>The Exception </p>"},{"location":"doxygen/classjac_1_1ContextRef/#function-getglobalobject","title":"function getGlobalObject","text":"<p>Get the global object of this context. <pre><code>Object jac::ContextRef::getGlobalObject () \n</code></pre></p> <p>Returns:</p> <p>The global object </p>"},{"location":"doxygen/classjac_1_1ContextRef/#function-operator-jscontext-12","title":"function operator JSContext * [1/2]","text":"<pre><code>inline jac::ContextRef::operator JSContext * () \n</code></pre>"},{"location":"doxygen/classjac_1_1ContextRef/#function-operator-jscontext-22","title":"function operator JSContext * [2/2]","text":"<pre><code>inline jac::ContextRef::operator JSContext * () const\n</code></pre>"},{"location":"doxygen/classjac_1_1ContextRef/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline jac::ContextRef::operator bool () \n</code></pre>"},{"location":"doxygen/classjac_1_1ContextRef/#function-operator","title":"function operator=","text":"<pre><code>inline ContextRef &amp; jac::ContextRef::operator= (\n    JSContext * ctx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/context.h</code></p>"},{"location":"doxygen/structjac_1_1ConvTraits/","title":"Struct jac::ConvTraits","text":"<p>template &lt;typename T, typename En&gt;</p> <p>ClassList &gt; jac &gt; ConvTraits</p>"},{"location":"doxygen/structjac_1_1ConvTraits/#public-static-functions","title":"Public Static Functions","text":"Type Name void from (ContextRef, ValueWeak)  void to (ContextRef, T)"},{"location":"doxygen/structjac_1_1ConvTraits/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1ConvTraits/#function-from","title":"function from","text":"<pre><code>static inline void jac::ConvTraits::from (\n    ContextRef,\n    ValueWeak\n) \n</code></pre>"},{"location":"doxygen/structjac_1_1ConvTraits/#function-to","title":"function to","text":"<pre><code>static inline void jac::ConvTraits::to (\n    ContextRef,\n    T\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/traits.h</code></p>"},{"location":"doxygen/structjac_1_1ConvTraits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__integral__v_3_01T_01_4_013818016e757d16d29218adaa25e8f13d/","title":"Struct jac::ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; jac &gt; ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt;</p>"},{"location":"doxygen/structjac_1_1ConvTraits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__integral__v_3_01T_01_4_013818016e757d16d29218adaa25e8f13d/#public-static-functions","title":"Public Static Functions","text":"Type Name T from (ContextRef ctx, ValueWeak val)  Value to (ContextRef ctx, T val)"},{"location":"doxygen/structjac_1_1ConvTraits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__integral__v_3_01T_01_4_013818016e757d16d29218adaa25e8f13d/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1ConvTraits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__integral__v_3_01T_01_4_013818016e757d16d29218adaa25e8f13d/#function-from","title":"function from","text":"<pre><code>static inline T jac::ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt;::from (\n    ContextRef ctx,\n    ValueWeak val\n) \n</code></pre>"},{"location":"doxygen/structjac_1_1ConvTraits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__integral__v_3_01T_01_4_013818016e757d16d29218adaa25e8f13d/#function-to","title":"function to","text":"<pre><code>static inline Value jac::ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt;::to (\n    ContextRef ctx,\n    T val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/traits.h</code></p>"},{"location":"doxygen/structjac_1_1ConvTraits_3_01bool_01_4/","title":"Struct jac::ConvTraits&lt; bool &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; jac &gt; ConvTraits&lt; bool &gt;</p>"},{"location":"doxygen/structjac_1_1ConvTraits_3_01bool_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name bool from (ContextRef ctx, ValueWeak val)  Value to (ContextRef ctx, bool val)"},{"location":"doxygen/structjac_1_1ConvTraits_3_01bool_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1ConvTraits_3_01bool_01_4/#function-from","title":"function from","text":"<pre><code>static inline bool jac::ConvTraits&lt; bool &gt;::from (\n    ContextRef ctx,\n    ValueWeak val\n) \n</code></pre>"},{"location":"doxygen/structjac_1_1ConvTraits_3_01bool_01_4/#function-to","title":"function to","text":"<pre><code>static inline Value jac::ConvTraits&lt; bool &gt;::to (\n    ContextRef ctx,\n    bool val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/traits.h</code></p>"},{"location":"doxygen/structjac_1_1ConvTraits_3_01std_1_1chrono_1_1milliseconds_01_4/","title":"Struct jac::ConvTraits&lt; std::chrono::milliseconds &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; jac &gt; ConvTraits&lt; std::chrono::milliseconds &gt;</p>"},{"location":"doxygen/structjac_1_1ConvTraits_3_01std_1_1chrono_1_1milliseconds_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name std::chrono::milliseconds from (ContextRef, ValueWeak value)  Value to (ContextRef ctx, std::chrono::milliseconds value)"},{"location":"doxygen/structjac_1_1ConvTraits_3_01std_1_1chrono_1_1milliseconds_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1ConvTraits_3_01std_1_1chrono_1_1milliseconds_01_4/#function-from","title":"function from","text":"<pre><code>static inline std::chrono::milliseconds jac::ConvTraits&lt; std::chrono::milliseconds &gt;::from (\n    ContextRef,\n    ValueWeak value\n) \n</code></pre>"},{"location":"doxygen/structjac_1_1ConvTraits_3_01std_1_1chrono_1_1milliseconds_01_4/#function-to","title":"function to","text":"<pre><code>static inline Value jac::ConvTraits&lt; std::chrono::milliseconds &gt;::to (\n    ContextRef ctx,\n    std::chrono::milliseconds value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/timersFeature.h</code></p>"},{"location":"doxygen/classjac_1_1EventLoopFeature/","title":"Class jac::EventLoopFeature","text":"<p>template &lt;class Next&gt;</p> <p>ClassList &gt; jac &gt; EventLoopFeature</p> <p>More...</p> <ul> <li><code>#include &lt;eventLoopFeature.h&gt;</code></li> </ul> <p>Inherits the following classes: Next</p>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#public-functions","title":"Public Functions","text":"Type Name void evalModuleWithEventLoop (std::string code, std::string filename)  void exit (int code)  int getExitCode ()  void initialize ()  void kill ()  void onEventLoop ()  void runEventLoop ()  virtual void runOnEventLoop () = 0"},{"location":"doxygen/classjac_1_1EventLoopFeature/#protected-attributes","title":"Protected Attributes","text":"Type Name std::optional&lt; Exception &gt; _error   = <code>std::nullopt</code>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#protected-functions","title":"Protected Functions","text":"Type Name void evalWithEventLoopCommon (Value &amp; promise)"},{"location":"doxygen/classjac_1_1EventLoopFeature/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>The EventLoopFeature must be companied by EventLoopTerminal at the top of the Machine stack. </p>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1EventLoopFeature/#function-evalmodulewitheventloop","title":"function evalModuleWithEventLoop","text":"<pre><code>inline void jac::EventLoopFeature::evalModuleWithEventLoop (\n    std::string code,\n    std::string filename\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#function-exit","title":"function exit","text":"<pre><code>inline void jac::EventLoopFeature::exit (\n    int code\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#function-getexitcode","title":"function getExitCode","text":"<pre><code>inline int jac::EventLoopFeature::getExitCode () \n</code></pre>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#function-initialize","title":"function initialize","text":"<pre><code>inline void jac::EventLoopFeature::initialize () \n</code></pre>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#function-kill","title":"function kill","text":"<pre><code>inline void jac::EventLoopFeature::kill () \n</code></pre>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#function-oneventloop","title":"function onEventLoop","text":"<pre><code>inline void jac::EventLoopFeature::onEventLoop () \n</code></pre>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#function-runeventloop","title":"function runEventLoop","text":"<pre><code>inline void jac::EventLoopFeature::runEventLoop () \n</code></pre>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#function-runoneventloop","title":"function runOnEventLoop","text":"<pre><code>virtual void jac::EventLoopFeature::runOnEventLoop () = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"doxygen/classjac_1_1EventLoopFeature/#variable-_error","title":"variable _error","text":"<pre><code>std::optional&lt;Exception&gt; jac::EventLoopFeature&lt; Next &gt;::_error;\n</code></pre>"},{"location":"doxygen/classjac_1_1EventLoopFeature/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"doxygen/classjac_1_1EventLoopFeature/#function-evalwitheventloopcommon","title":"function evalWithEventLoopCommon","text":"<pre><code>inline void jac::EventLoopFeature::evalWithEventLoopCommon (\n    Value &amp; promise\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/eventLoopFeature.h</code></p>"},{"location":"doxygen/classjac_1_1EventLoopTerminal/","title":"Class jac::EventLoopTerminal","text":"<p>template &lt;class Next&gt;</p> <p>ClassList &gt; jac &gt; EventLoopTerminal</p> <p>Inherits the following classes: Next</p>"},{"location":"doxygen/classjac_1_1EventLoopTerminal/#public-functions","title":"Public Functions","text":"Type Name virtual void runOnEventLoop () override"},{"location":"doxygen/classjac_1_1EventLoopTerminal/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1EventLoopTerminal/#function-runoneventloop","title":"function runOnEventLoop","text":"<pre><code>inline virtual void jac::EventLoopTerminal::runOnEventLoop () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/eventLoopTerminal.h</code></p>"},{"location":"doxygen/classjac_1_1EventQueueFeature/","title":"Class jac::EventQueueFeature","text":"<p>template &lt;class Next&gt;</p> <p>ClassList &gt; jac &gt; EventQueueFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"doxygen/classjac_1_1EventQueueFeature/#public-functions","title":"Public Functions","text":"Type Name std::optional&lt; std::function&lt; void()&gt; &gt; getEvent (bool wait) Check the event queue and return the first event. void notifyEventLoop () Wake up event loop if it is waiting for events. void scheduleEvent (std::function&lt; void()&gt; func) Schedule an event to be run. ~EventQueueFeature ()"},{"location":"doxygen/classjac_1_1EventQueueFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1EventQueueFeature/#function-getevent","title":"function getEvent","text":"<p>Check the event queue and return the first event. <pre><code>inline std::optional&lt; std::function&lt; void()&gt; &gt; jac::EventQueueFeature::getEvent (\n    bool wait\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>wait</code> Wait for event if no event is available </li> </ul> <p>Returns:</p> <p>Event or std::nullopt if no event is available </p>"},{"location":"doxygen/classjac_1_1EventQueueFeature/#function-notifyeventloop","title":"function notifyEventLoop","text":"<p>Wake up event loop if it is waiting for events. <pre><code>inline void jac::EventQueueFeature::notifyEventLoop () \n</code></pre></p>"},{"location":"doxygen/classjac_1_1EventQueueFeature/#function-scheduleevent","title":"function scheduleEvent","text":"<p>Schedule an event to be run. <pre><code>inline void jac::EventQueueFeature::scheduleEvent (\n    std::function&lt; void()&gt; func\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>func</code> Function to be run </li> </ul>"},{"location":"doxygen/classjac_1_1EventQueueFeature/#function-eventqueuefeature","title":"function ~EventQueueFeature","text":"<pre><code>inline jac::EventQueueFeature::~EventQueueFeature () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/eventQueueFeature.h</code></p>"},{"location":"doxygen/classjac_1_1ExceptionWrapper/","title":"Class jac::ExceptionWrapper","text":"<p>template &lt;bool managed&gt;</p> <p>ClassList &gt; jac &gt; ExceptionWrapper</p> <p>An exception wrapper which can either wrap a JSValue or contain an exception description and can be thrown into JS as a specific Error type. More...</p> <ul> <li><code>#include &lt;values.h&gt;</code></li> </ul> <p>Inherits the following classes: jac::ValueWrapper,  std::exception</p>"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#public-types","title":"Public Types","text":"Type Name enum Type"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#public-functions","title":"Public Functions","text":"Type Name ExceptionWrapper (ValueWrapper&lt; managed &gt; value) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Exception is destroyed. ExceptionWrapper (ContextRef ctx, JSValue val)  std::string stackTrace () noexceptGet the exception stack trace. JSValue throwJS (ContextRef ctx) Throw the exception into JS. const char * what () noexcept override constGet the exception message."},{"location":"doxygen/classjac_1_1ExceptionWrapper/#public-functions-inherited-from-jacvaluewrapper","title":"Public Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ValueWrapper (ContextRef ctx, JSValue val) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Value is destroyed. ValueWrapper (const ValueWrapper &amp; other)  ValueWrapper (ValueWrapper &amp;&amp; other)  JSValue &amp; getVal () Get reference to the underlying JSValue. bool isArray () Check if the Value is an array. bool isFunction () Check if the Value is a function. bool isNull () Check if the Value is null. bool isObject () Check if the Value is an object. bool isUndefined () Check if the Value is undefined. std::pair&lt; ContextRef, JSValue &gt; loot () Release ownership of the JSValue. The JSValue will have to be freed manually. operator ValueWeak ()  ValueWrapper &amp; operator= (const ValueWrapper &amp; other)  ValueWrapper &amp; operator= (ValueWrapper &amp;&amp; other)  Value stringify (int indent=0) Convert the Value to a JSON representation. T to () Convert the Value to a specified type. StringView toString () Convert the Value to a StringView . ~ValueWrapper ()"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#public-static-functions","title":"Public Static Functions","text":"Type Name Exception create (Type type, std::string message) Create a new Exception."},{"location":"doxygen/classjac_1_1ExceptionWrapper/#public-static-functions-inherited-from-jacvaluewrapper","title":"Public Static Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name Value from (ContextRef ctx, T val) Create a new Value by converting a given value. Value fromJSON (ContextRef ctx, std::string json, std::string filename=\"&lt;json&gt;\", bool extended=false) Create a new Value from a given JSON string. Value null (ContextRef ctx) Create a new Value containing null. Value undefined (ContextRef ctx) Create a new Value containing undefined."},{"location":"doxygen/classjac_1_1ExceptionWrapper/#protected-attributes-inherited-from-jacvaluewrapper","title":"Protected Attributes inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ContextRef _ctx JSValue _val"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>managed</code> whether the JSValue should be freed when the wrapper is destroyed. </li> </ul>"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/classjac_1_1ExceptionWrapper/#enum-type","title":"enum Type","text":"<pre><code>enum jac::ExceptionWrapper::Type {\n    Any,\n    Error,\n    SyntaxError,\n    TypeError,\n    ReferenceError,\n    RangeError,\n    InternalError\n};\n</code></pre>"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ExceptionWrapper/#function-exceptionwrapper-23","title":"function ExceptionWrapper [2/3]","text":"<p>Wrap an existing JSValue. If managed is true, JSValue will be freed when the Exception is destroyed. <pre><code>inline jac::ExceptionWrapper::ExceptionWrapper (\n    ValueWrapper &lt; managed &gt; value\n) \n</code></pre></p> <p>Note:</p> <p>Used internally when directly working with QuickJS API. New Exception should be created using Exception::create() or by converting an existing Value to an Exception using Value::to&lt;Exception&gt;().</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>val</code> JSValue to wrap </li> </ul>"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#function-exceptionwrapper-33","title":"function ExceptionWrapper [3/3]","text":"<pre><code>inline jac::ExceptionWrapper::ExceptionWrapper (\n    ContextRef ctx,\n    JSValue val\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#function-stacktrace","title":"function stackTrace","text":"<p>Get the exception stack trace. <pre><code>std::string jac::ExceptionWrapper::stackTrace () noexcept\n</code></pre></p> <p>Returns:</p> <p>std::string containing the stack trace </p>"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#function-throwjs","title":"function throwJS","text":"<p>Throw the exception into JS. <pre><code>JSValue jac::ExceptionWrapper::throwJS (\n    ContextRef ctx\n) \n</code></pre></p> <p>Note:</p> <p>Used internally when directly working with QuickJS API. In most cases, exceptions should be thrown using a throw statement and wrapper functions will propagate the exception to JS. </p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to throw the exception in</li> </ul> <p>Returns:</p> <p>JSValue containing the exception </p>"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#function-what","title":"function what","text":"<p>Get the exception message. <pre><code>inline const char * jac::ExceptionWrapper::what () noexcept override const\n</code></pre></p> <p>Returns:</p> <p>std::string containing the exception message </p>"},{"location":"doxygen/classjac_1_1ExceptionWrapper/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ExceptionWrapper/#function-create","title":"function create","text":"<p>Create a new Exception. <pre><code>static inline Exception jac::ExceptionWrapper::create (\n    Type type,\n    std::string message\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>type</code> type of the exception </li> <li><code>message</code> exception message </li> </ul> <p>Returns:</p> <p>The resulting Exception </p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/values.h</code></p>"},{"location":"doxygen/classjac_1_1File/","title":"Class jac::File","text":"<p>ClassList &gt; jac &gt; File</p>"},{"location":"doxygen/classjac_1_1File/#public-attributes","title":"Public Attributes","text":"Type Name std::string path_"},{"location":"doxygen/classjac_1_1File/#public-functions","title":"Public Functions","text":"Type Name File (std::string path, std::string flags)  File (std::filesystem::path path, std::string flags)  void close ()  bool isOpen ()  std::string read (int length=1024)  void write (std::string data)  ~File ()"},{"location":"doxygen/classjac_1_1File/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/classjac_1_1File/#variable-path_","title":"variable path_","text":"<pre><code>std::string jac::File::path_;\n</code></pre>"},{"location":"doxygen/classjac_1_1File/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1File/#function-file-12","title":"function File [1/2]","text":"<pre><code>inline jac::File::File (\n    std::string path,\n    std::string flags\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1File/#function-file-22","title":"function File [2/2]","text":"<pre><code>inline jac::File::File (\n    std::filesystem::path path,\n    std::string flags\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1File/#function-close","title":"function close","text":"<pre><code>inline void jac::File::close () \n</code></pre>"},{"location":"doxygen/classjac_1_1File/#function-isopen","title":"function isOpen","text":"<pre><code>inline bool jac::File::isOpen () \n</code></pre>"},{"location":"doxygen/classjac_1_1File/#function-read","title":"function read","text":"<pre><code>inline std::string jac::File::read (\n    int length=1024\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1File/#function-write","title":"function write","text":"<pre><code>inline void jac::File::write (\n    std::string data\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1File/#function-file","title":"function ~File","text":"<pre><code>inline jac::File::~File () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/types/file.h</code></p>"},{"location":"doxygen/structjac_1_1FileProtoBuilder/","title":"Struct jac::FileProtoBuilder","text":"<p>ClassList &gt; jac &gt; FileProtoBuilder</p> <p>Inherits the following classes: jac::ProtoBuilder::Opaque,  jac::ProtoBuilder::Properties</p>"},{"location":"doxygen/structjac_1_1FileProtoBuilder/#public-types-inherited-from-jacprotobuilderopaque","title":"Public Types inherited from jac::ProtoBuilder::Opaque","text":"<p>See jac::ProtoBuilder::Opaque</p> Type Name typedef T OpaqueType"},{"location":"doxygen/structjac_1_1FileProtoBuilder/#public-static-attributes-inherited-from-jacprotobuilderopaque","title":"Public Static Attributes inherited from jac::ProtoBuilder::Opaque","text":"<p>See jac::ProtoBuilder::Opaque</p> Type Name JSClassID classId"},{"location":"doxygen/structjac_1_1FileProtoBuilder/#public-static-functions","title":"Public Static Functions","text":"Type Name void addProperties (ContextRef ctx, Object proto)"},{"location":"doxygen/structjac_1_1FileProtoBuilder/#public-static-functions-inherited-from-jacprotobuilderopaque","title":"Public Static Functions inherited from jac::ProtoBuilder::Opaque","text":"<p>See jac::ProtoBuilder::Opaque</p> Type Name void addMethodMember (ContextRef ctx, Object proto, std::string name, PropFlags flags=PropFlags::Default) Add a property to the object prototype from a member function of the wrapped class. void addPropMember (ContextRef ctx, Object proto, std::string name, PropFlags flags=PropFlags::Default) Add a property to the object prototype from a member variable of the wrapped class. Value callMember (ContextRef ctx, ValueWeak funcObj, ValueWeak thisVal, std::vector&lt; ValueWeak &gt; argv) Process a call to a member function of the wrapped class. T * constructOpaque (ContextRef, std::vector&lt; ValueWeak &gt;) Construct a new Opaque object from javascript arguments. void destroyOpaque (JSRuntime *, T * ptr) noexceptDestroy the Opaque object. T * getOpaque (ContextRef, ValueWeak thisVal) Get the Opaque object from an instance of the class."},{"location":"doxygen/structjac_1_1FileProtoBuilder/#public-static-functions-inherited-from-jacprotobuilderproperties","title":"Public Static Functions inherited from jac::ProtoBuilder::Properties","text":"<p>See jac::ProtoBuilder::Properties</p> Type Name void addProperties (ContextRef ctx, Object proto) Add properties to the object prototype."},{"location":"doxygen/structjac_1_1FileProtoBuilder/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1FileProtoBuilder/#function-addproperties","title":"function addProperties","text":"<pre><code>static inline void jac::FileProtoBuilder::addProperties (\n    ContextRef ctx,\n    Object proto\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/filesystemFeature.h</code></p>"},{"location":"doxygen/classjac_1_1FilesystemFeature/","title":"Class jac::FilesystemFeature","text":"<p>template &lt;class Next&gt;</p> <p>ClassList &gt; jac &gt; FilesystemFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"doxygen/classjac_1_1FilesystemFeature/#classes","title":"Classes","text":"Type Name class Path"},{"location":"doxygen/classjac_1_1FilesystemFeature/#public-types","title":"Public Types","text":"Type Name typedef Class&lt; FileProtoBuilder &gt; FileClass"},{"location":"doxygen/classjac_1_1FilesystemFeature/#public-attributes","title":"Public Attributes","text":"Type Name Fs fs Path path"},{"location":"doxygen/classjac_1_1FilesystemFeature/#public-functions","title":"Public Functions","text":"Type Name FilesystemFeature ()  void initialize ()  void setCodeDir (std::string path_)  void setWorkingDir (std::string path_)"},{"location":"doxygen/classjac_1_1FilesystemFeature/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/classjac_1_1FilesystemFeature/#typedef-fileclass","title":"typedef FileClass","text":"<pre><code>using jac::FilesystemFeature&lt; Next &gt;::FileClass =  Class&lt;FileProtoBuilder&gt;;\n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/classjac_1_1FilesystemFeature/#variable-fs","title":"variable fs","text":"<pre><code>Fs jac::FilesystemFeature&lt; Next &gt;::fs;\n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature/#variable-path","title":"variable path","text":"<pre><code>Path jac::FilesystemFeature&lt; Next &gt;::path;\n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1FilesystemFeature/#function-filesystemfeature","title":"function FilesystemFeature","text":"<pre><code>inline jac::FilesystemFeature::FilesystemFeature () \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature/#function-initialize","title":"function initialize","text":"<pre><code>inline void jac::FilesystemFeature::initialize () \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature/#function-setcodedir","title":"function setCodeDir","text":"<pre><code>inline void jac::FilesystemFeature::setCodeDir (\n    std::string path_\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature/#function-setworkingdir","title":"function setWorkingDir","text":"<pre><code>inline void jac::FilesystemFeature::setWorkingDir (\n    std::string path_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/filesystemFeature.h</code></p>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Path/","title":"Class jac::FilesystemFeature::Path","text":"<p>ClassList &gt; jac &gt; FilesystemFeature &gt; Path</p>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Path/#public-functions","title":"Public Functions","text":"Type Name Path (FilesystemFeature &amp; feature)  std::string basename (std::string path_)  std::string dirname (std::string path_)  std::string join (std::vector&lt; std::string &gt; paths)  std::string normalize (std::string path_)"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Path/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Path/#function-path","title":"function Path","text":"<pre><code>inline jac::FilesystemFeature::Path::Path (\n    FilesystemFeature &amp; feature\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Path/#function-basename","title":"function basename","text":"<pre><code>inline std::string jac::FilesystemFeature::Path::basename (\n    std::string path_\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Path/#function-dirname","title":"function dirname","text":"<pre><code>inline std::string jac::FilesystemFeature::Path::dirname (\n    std::string path_\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Path/#function-join","title":"function join","text":"<pre><code>inline std::string jac::FilesystemFeature::Path::join (\n    std::vector&lt; std::string &gt; paths\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Path/#function-normalize","title":"function normalize","text":"<pre><code>inline std::string jac::FilesystemFeature::Path::normalize (\n    std::string path_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/filesystemFeature.h</code></p>"},{"location":"doxygen/classjac_1_1FunctionFactory/","title":"Class jac::FunctionFactory","text":"<p>ClassList &gt; jac &gt; FunctionFactory</p> <p>Various methods for wrapping C++ functions into javascript functions. More...</p> <ul> <li><code>#include &lt;functionFactory.h&gt;</code></li> </ul>"},{"location":"doxygen/classjac_1_1FunctionFactory/#public-functions","title":"Public Functions","text":"Type Name FunctionFactory (ContextRef context)  Function newFunction (Func func) Wraps a C++ function into a javascript function object. Function newFunctionThis (Func func) Wraps a C++ function into a javascript function object. Function newFunctionThisVariadic (Func func) Wraps a C++ function into a javascript function object. Function newFunctionVariadic (Func func) Wraps a C++ function into a javascript function object."},{"location":"doxygen/classjac_1_1FunctionFactory/#detailed-description","title":"Detailed Description","text":"<p>About exceptions propagation:</p> <p>When jac::Exception is thrown, the wrapped value or given error type is thrown. When std::exception is thrown, an InternalError is thrown. When any other exception is thrown, an InternalError is thrown with the message \"unknown error\". </p>"},{"location":"doxygen/classjac_1_1FunctionFactory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1FunctionFactory/#function-functionfactory","title":"function FunctionFactory","text":"<pre><code>inline jac::FunctionFactory::FunctionFactory (\n    ContextRef context\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FunctionFactory/#function-newfunction","title":"function newFunction","text":"<p>Wraps a C++ function into a javascript function object. <pre><code>template&lt;class Func&gt;\ninline Function jac::FunctionFactory::newFunction (\n    Func func\n) \n</code></pre></p> <p>The expected signature of the function object is Res(Args...). Arguments and the result of the function call are automatically converted to and from javascript values. Exceptions thrown within the function are automatically propagated to the javascript side.</p> <p>Template parameters:</p> <ul> <li><code>Func</code> type of the function to be wrapped </li> </ul> <p>Parameters:</p> <ul> <li><code>func</code> the function object to be wrapped </li> </ul> <p>Returns:</p> <p>The created function object </p>"},{"location":"doxygen/classjac_1_1FunctionFactory/#function-newfunctionthis","title":"function newFunctionThis","text":"<p>Wraps a C++ function into a javascript function object. <pre><code>template&lt;class Func&gt;\ninline Function jac::FunctionFactory::newFunctionThis (\n    Func func\n) \n</code></pre></p> <p>The expected signature of the function object is Res(ContextRef, ValueWeak, Args...). Arguments and the result of the function call are automatically converted to and from javascript values. Exceptions thrown within the function are automatically propagated to the javascript side.</p> <p>Template parameters:</p> <ul> <li><code>Func</code> type of the function to be wrapped </li> </ul> <p>Parameters:</p> <ul> <li><code>func</code> the function object to be wrapped </li> </ul> <p>Returns:</p> <p>The created function object </p>"},{"location":"doxygen/classjac_1_1FunctionFactory/#function-newfunctionthisvariadic","title":"function newFunctionThisVariadic","text":"<p>Wraps a C++ function into a javascript function object. <pre><code>template&lt;class Func&gt;\ninline Function jac::FunctionFactory::newFunctionThisVariadic (\n    Func func\n) \n</code></pre></p> <p>The expected signature of the function object is Res(ContextRef, ValueWeak, std::vector&lt;ValueWeak&gt;). The vector will contain all arguments passed to the function. The the result of the function call is automatically converted from a javascript value. Exceptions thrown within the function are automatically propagated to the javascript side.</p> <p>Template parameters:</p> <ul> <li><code>Func</code> type of the function to be wrapped </li> </ul> <p>Parameters:</p> <ul> <li><code>func</code> the function object to be wrapped </li> </ul> <p>Returns:</p> <p>The created function object </p>"},{"location":"doxygen/classjac_1_1FunctionFactory/#function-newfunctionvariadic","title":"function newFunctionVariadic","text":"<p>Wraps a C++ function into a javascript function object. <pre><code>template&lt;class Func&gt;\ninline Function jac::FunctionFactory::newFunctionVariadic (\n    Func func\n) \n</code></pre></p> <p>The expected signature of the function object is Res(std::vector&lt;ValueWeak&gt;). The vector will contain all arguments passed to the function. The result of the function call is automatically converted from a javascript value. Exceptions thrown within the function are automatically propagated to the javascript side.</p> <p>Template parameters:</p> <ul> <li><code>Func</code> type of the function to be wrapped </li> </ul> <p>Parameters:</p> <ul> <li><code>func</code> the function object to be wrapped </li> </ul> <p>Returns:</p> <p>The created function object </p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/functionFactory.h</code></p>"},{"location":"doxygen/classjac_1_1FunctionWrapper/","title":"Class jac::FunctionWrapper","text":"<p>template &lt;bool managed&gt;</p> <p>ClassList &gt; jac &gt; FunctionWrapper</p> <p>A wrapper for JSValue with Function type with RAII. More...</p> <ul> <li><code>#include &lt;values.h&gt;</code></li> </ul> <p>Inherits the following classes: jac::ObjectWrapper</p>"},{"location":"doxygen/classjac_1_1FunctionWrapper/#public-functions","title":"Public Functions","text":"Type Name FunctionWrapper (ObjectWrapper&lt; managed &gt; value) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Function is destroyed. FunctionWrapper (ContextRef ctx, JSValue val)  Res call (Args... args) Call the function. Value callConstructor (Args... args) Call the function as a constructor. Res callThis (Value thisVal, Args... args) Call the function with <code>this</code> set to a given object."},{"location":"doxygen/classjac_1_1FunctionWrapper/#public-functions-inherited-from-jacobjectwrapper","title":"Public Functions inherited from jac::ObjectWrapper","text":"<p>See jac::ObjectWrapper</p> Type Name ObjectWrapper (ValueWrapper&lt; managed &gt; value) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Object is destroyed. ObjectWrapper (ContextRef ctx, JSValue val)  void defineProperty (Id id, Value value, PropFlags flags=PropFlags::Default) Define a property of the object. void deleteProperty (Id id) Delete a property of the object. T get (Atom prop) Get a property of the object. T get (const std::string &amp; name)  T get (uint32_t idx)  Object getPrototype () Get the prototype of the object. bool hasProperty (Id id) Check if the object has a property. Res invoke (Atom key, Args... args) Invoke a method of the object. Res invoke (const std::string &amp; key, Args... args)  Res invoke (uint32_t idx, Args... args)  void set (Atom prop, T val) Set a property of the object. void set (const std::string &amp; name, T val)  void set (uint32_t idx, T val)  void setPrototype (Object proto) Set the prototype of the object."},{"location":"doxygen/classjac_1_1FunctionWrapper/#public-functions-inherited-from-jacvaluewrapper","title":"Public Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ValueWrapper (ContextRef ctx, JSValue val) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Value is destroyed. ValueWrapper (const ValueWrapper &amp; other)  ValueWrapper (ValueWrapper &amp;&amp; other)  JSValue &amp; getVal () Get reference to the underlying JSValue. bool isArray () Check if the Value is an array. bool isFunction () Check if the Value is a function. bool isNull () Check if the Value is null. bool isObject () Check if the Value is an object. bool isUndefined () Check if the Value is undefined. std::pair&lt; ContextRef, JSValue &gt; loot () Release ownership of the JSValue. The JSValue will have to be freed manually. operator ValueWeak ()  ValueWrapper &amp; operator= (const ValueWrapper &amp; other)  ValueWrapper &amp; operator= (ValueWrapper &amp;&amp; other)  Value stringify (int indent=0) Convert the Value to a JSON representation. T to () Convert the Value to a specified type. StringView toString () Convert the Value to a StringView . ~ValueWrapper ()"},{"location":"doxygen/classjac_1_1FunctionWrapper/#public-static-functions-inherited-from-jacobjectwrapper","title":"Public Static Functions inherited from jac::ObjectWrapper","text":"<p>See jac::ObjectWrapper</p> Type Name Object create (ContextRef ctx) Create a new empty object."},{"location":"doxygen/classjac_1_1FunctionWrapper/#public-static-functions-inherited-from-jacvaluewrapper","title":"Public Static Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name Value from (ContextRef ctx, T val) Create a new Value by converting a given value. Value fromJSON (ContextRef ctx, std::string json, std::string filename=\"&lt;json&gt;\", bool extended=false) Create a new Value from a given JSON string. Value null (ContextRef ctx) Create a new Value containing null. Value undefined (ContextRef ctx) Create a new Value containing undefined."},{"location":"doxygen/classjac_1_1FunctionWrapper/#protected-attributes-inherited-from-jacvaluewrapper","title":"Protected Attributes inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ContextRef _ctx JSValue _val"},{"location":"doxygen/classjac_1_1FunctionWrapper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>managed</code> whether the JSValue should be freed when the wrapper is destroyed. </li> </ul>"},{"location":"doxygen/classjac_1_1FunctionWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1FunctionWrapper/#function-functionwrapper-12","title":"function FunctionWrapper [1/2]","text":"<p>Wrap an existing JSValue. If managed is true, JSValue will be freed when the Function is destroyed. <pre><code>inline jac::FunctionWrapper::FunctionWrapper (\n    ObjectWrapper &lt; managed &gt; value\n) \n</code></pre></p> <p>Note:</p> <p>Used internally when directly working with QuickJS API. New Function should be created using FunctionFactory.</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>val</code> JSValue to wrap </li> </ul>"},{"location":"doxygen/classjac_1_1FunctionWrapper/#function-functionwrapper-22","title":"function FunctionWrapper [2/2]","text":"<pre><code>inline jac::FunctionWrapper::FunctionWrapper (\n    ContextRef ctx,\n    JSValue val\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FunctionWrapper/#function-call","title":"function call","text":"<p>Call the function. <pre><code>template&lt;typename Res, typename... Args&gt;\ninline Res jac::FunctionWrapper::call (\n    Args... args\n) \n</code></pre></p> <p>Note:</p> <p>The call will automatically convert the arguments to their JavaScript counterparts, the result will be converted to the specified type and Exceptions thrown in JS will be propagated to C++ as jac::Exception.</p> <p>Template parameters:</p> <ul> <li><code>Res</code> type to convert the result to </li> <li><code>Args</code> types of the arguments </li> </ul> <p>Parameters:</p> <ul> <li><code>prop</code> the property identifier </li> <li><code>args</code> the arguments </li> </ul> <p>Returns:</p> <p>The resulting value </p>"},{"location":"doxygen/classjac_1_1FunctionWrapper/#function-callconstructor","title":"function callConstructor","text":"<p>Call the function as a constructor. <pre><code>template&lt;typename... Args&gt;\ninline Value jac::FunctionWrapper::callConstructor (\n    Args... args\n) \n</code></pre></p> <p>Note:</p> <p>The call will automatically convert the arguments to their JavaScript counterparts, the result will be converted to the specified type and Exceptions thrown in JS will be propagated to C++ as jac::Exception.</p> <p>Template parameters:</p> <ul> <li><code>Res</code> type to convert the result to </li> <li><code>Args</code> types of the arguments </li> </ul> <p>Parameters:</p> <ul> <li><code>prop</code> the property identifier </li> <li><code>args</code> the arguments </li> </ul> <p>Returns:</p> <p>The resulting value </p>"},{"location":"doxygen/classjac_1_1FunctionWrapper/#function-callthis","title":"function callThis","text":"<p>Call the function with <code>this</code> set to a given object. <pre><code>template&lt;typename Res, typename... Args&gt;\ninline Res jac::FunctionWrapper::callThis (\n    Value thisVal,\n    Args... args\n) \n</code></pre></p> <p>Note:</p> <p>The call will automatically convert the arguments to their JavaScript counterparts, the result will be converted to the specified type and Exceptions thrown in JS will be propagated to C++ as jac::Exception.</p> <p>Template parameters:</p> <ul> <li><code>Res</code> type to convert the result to </li> <li><code>Args</code> types of the arguments </li> </ul> <p>Parameters:</p> <ul> <li><code>prop</code> the property identifier </li> <li><code>args</code> the arguments </li> </ul> <p>Returns:</p> <p>The resulting value </p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/values.h</code></p>"},{"location":"doxygen/classjac_1_1MachineBase/","title":"Class jac::MachineBase","text":"<p>ClassList &gt; jac &gt; MachineBase</p>"},{"location":"doxygen/classjac_1_1MachineBase/#public-functions","title":"Public Functions","text":"Type Name MachineBase () = default MachineBase (const MachineBase &amp;) = delete MachineBase (MachineBase &amp;&amp;) = delete ContextRef context () Get the ContextRef for this machine. Value eval (std::string code, std::string filename, EvalFlags flags=EvalFlags::Global) Evaluate a string containing javascript code. void initialize () Initialize the machine. Should be called after machine configuration is done and before any interaction with the javascript engine. Other MFeatures in the Machine stack can implement this method to initialize themselves but the first call should be Next::initialize(). void interruptRuntime () Interrupt running javascript code. Execution will be thrown in the javascript as an InterruptError. Module &amp; newModule (std::string name) Create a new module in the machine. MachineBase &amp; operator= (const MachineBase &amp;) = delete MachineBase &amp; operator= (MachineBase &amp;&amp;) = delete void resetWatchdog () Reset the watchdog timer. This should be called periodically to prevent the watchdog from triggering. JSRuntime * runtime () Get the JSRuntime* for this machine. void setWatchdogHandler (std::function&lt; bool()&gt; callback) Set the watchdog callback. The callback will be called when the watchdog timeout has passed since the last reset. If the callback returns true, the runtime will be interrupted. void setWatchdogTimeout (std::chrono::milliseconds timeout) Set the watchdog timeout. If the timeout is zero, the watchdog is disabled. Otherwise, the watchdog will be called when the timeout has passed since the last reset. virtual ~MachineBase ()"},{"location":"doxygen/classjac_1_1MachineBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1MachineBase/#function-machinebase-13","title":"function MachineBase [1/3]","text":"<pre><code>jac::MachineBase::MachineBase () = default\n</code></pre>"},{"location":"doxygen/classjac_1_1MachineBase/#function-machinebase-23","title":"function MachineBase [2/3]","text":"<pre><code>jac::MachineBase::MachineBase (\n    const MachineBase &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1MachineBase/#function-machinebase-33","title":"function MachineBase [3/3]","text":"<pre><code>jac::MachineBase::MachineBase (\n    MachineBase &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1MachineBase/#function-context","title":"function context","text":"<p>Get the ContextRef for this machine. <pre><code>inline ContextRef jac::MachineBase::context () \n</code></pre></p> <p>Returns:</p> <p>The ContextRef </p>"},{"location":"doxygen/classjac_1_1MachineBase/#function-eval","title":"function eval","text":"<p>Evaluate a string containing javascript code. <pre><code>Value jac::MachineBase::eval (\n    std::string code,\n    std::string filename,\n    EvalFlags flags=EvalFlags::Global\n) \n</code></pre></p> <p>Note:</p> <p>If the evaluation mode is EvalFlags::Module, the result will be a Promise</p> <p>Parameters:</p> <ul> <li><code>code</code> the code to evaluate </li> <li><code>filename</code> filename to use for the code. Used for error reporting </li> <li><code>flags</code> flags to evaluate the code with </li> </ul> <p>Returns:</p> <p>Result of the evaluation </p>"},{"location":"doxygen/classjac_1_1MachineBase/#function-initialize","title":"function initialize","text":"<p>Initialize the machine. Should be called after machine configuration is done and before any interaction with the javascript engine. Other MFeatures in the Machine stack can implement this method to initialize themselves but the first call should be Next::initialize(). <pre><code>void jac::MachineBase::initialize () \n</code></pre></p>"},{"location":"doxygen/classjac_1_1MachineBase/#function-interruptruntime","title":"function interruptRuntime","text":"<p>Interrupt running javascript code. Execution will be thrown in the javascript as an InterruptError. <pre><code>inline void jac::MachineBase::interruptRuntime () \n</code></pre></p>"},{"location":"doxygen/classjac_1_1MachineBase/#function-newmodule","title":"function newModule","text":"<p>Create a new module in the machine. <pre><code>Module &amp; jac::MachineBase::newModule (\n    std::string name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> name of the module </li> </ul> <p>Returns:</p> <p>Reference to the new module </p>"},{"location":"doxygen/classjac_1_1MachineBase/#function-operator","title":"function operator=","text":"<pre><code>MachineBase &amp; jac::MachineBase::operator= (\n    const MachineBase &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1MachineBase/#function-operator_1","title":"function operator=","text":"<pre><code>MachineBase &amp; jac::MachineBase::operator= (\n    MachineBase &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1MachineBase/#function-resetwatchdog","title":"function resetWatchdog","text":"<p>Reset the watchdog timer. This should be called periodically to prevent the watchdog from triggering. <pre><code>inline void jac::MachineBase::resetWatchdog () \n</code></pre></p>"},{"location":"doxygen/classjac_1_1MachineBase/#function-runtime","title":"function runtime","text":"<p>Get the JSRuntime* for this machine. <pre><code>inline JSRuntime * jac::MachineBase::runtime () \n</code></pre></p> <p>Returns:</p> <p>The JSRuntime* </p>"},{"location":"doxygen/classjac_1_1MachineBase/#function-setwatchdoghandler","title":"function setWatchdogHandler","text":"<p>Set the watchdog callback. The callback will be called when the watchdog timeout has passed since the last reset. If the callback returns true, the runtime will be interrupted. <pre><code>inline void jac::MachineBase::setWatchdogHandler (\n    std::function&lt; bool()&gt; callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>callback</code> callback to call </li> </ul>"},{"location":"doxygen/classjac_1_1MachineBase/#function-setwatchdogtimeout","title":"function setWatchdogTimeout","text":"<p>Set the watchdog timeout. If the timeout is zero, the watchdog is disabled. Otherwise, the watchdog will be called when the timeout has passed since the last reset. <pre><code>inline void jac::MachineBase::setWatchdogTimeout (\n    std::chrono::milliseconds timeout\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>timeout</code> watchdog timeout </li> </ul>"},{"location":"doxygen/classjac_1_1MachineBase/#function-machinebase","title":"function ~MachineBase","text":"<pre><code>inline virtual jac::MachineBase::~MachineBase () \n</code></pre>"},{"location":"doxygen/classjac_1_1MachineBase/#friends-documentation","title":"Friends Documentation","text":""},{"location":"doxygen/classjac_1_1MachineBase/#friend-module","title":"friend Module","text":"<pre><code>class jac::MachineBase::Module (\n    Module\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/machine.h</code></p>"},{"location":"doxygen/classjac_1_1Module/","title":"Class jac::Module","text":"<p>ClassList &gt; jac &gt; Module</p> <p>A wrapper around JSModuleDef that allows for easy exporting of values. </p> <ul> <li><code>#include &lt;machine.h&gt;</code></li> </ul>"},{"location":"doxygen/classjac_1_1Module/#public-functions","title":"Public Functions","text":"Type Name Module (ContextRef ctx, std::string name) Create a new module in the given context. Should not be called directly, use MachineBase::newModule instead. Module (const Module &amp;) = delete Module (Module &amp;&amp; other)  void addExport (std::string name, Value val) Add a value to the module's exports. JSModuleDef * get () Get the underlying JSModuleDef* for this module. Module &amp; operator= (const Module &amp;) = delete Module &amp; operator= (Module &amp;&amp; other)"},{"location":"doxygen/classjac_1_1Module/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Module/#function-module-13","title":"function Module [1/3]","text":"<p>Create a new module in the given context. Should not be called directly, use MachineBase::newModule instead. <pre><code>jac::Module::Module (\n    ContextRef ctx,\n    std::string name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>name</code> name of the module </li> </ul>"},{"location":"doxygen/classjac_1_1Module/#function-module-23","title":"function Module [2/3]","text":"<pre><code>jac::Module::Module (\n    const Module &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Module/#function-module-33","title":"function Module [3/3]","text":"<pre><code>inline jac::Module::Module (\n    Module &amp;&amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Module/#function-addexport","title":"function addExport","text":"<p>Add a value to the module's exports. <pre><code>void jac::Module::addExport (\n    std::string name,\n    Value val\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> name of the export </li> <li><code>val</code> the value to export </li> </ul>"},{"location":"doxygen/classjac_1_1Module/#function-get","title":"function get","text":"<p>Get the underlying JSModuleDef* for this module. <pre><code>inline JSModuleDef * jac::Module::get () \n</code></pre></p> <p>Returns:</p> <p>JSModuleDef* </p>"},{"location":"doxygen/classjac_1_1Module/#function-operator","title":"function operator=","text":"<pre><code>Module &amp; jac::Module::operator= (\n    const Module &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Module/#function-operator_1","title":"function operator=","text":"<pre><code>inline Module &amp; jac::Module::operator= (\n    Module &amp;&amp; other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/machine.h</code></p>"},{"location":"doxygen/classjac_1_1ModuleLoaderFeature/","title":"Class jac::ModuleLoaderFeature","text":"<p>template &lt;class Next&gt;</p> <p>ClassList &gt; jac &gt; ModuleLoaderFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"doxygen/classjac_1_1ModuleLoaderFeature/#public-functions","title":"Public Functions","text":"Type Name Value evalFile (std::string path_) Evaluate a file. void evalFileWithEventLoop (std::string path_) Evaluate a file and run the event loop until the program exits or throws an exception. void initialize ()"},{"location":"doxygen/classjac_1_1ModuleLoaderFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ModuleLoaderFeature/#function-evalfile","title":"function evalFile","text":"<p>Evaluate a file. <pre><code>inline Value jac::ModuleLoaderFeature::evalFile (\n    std::string path_\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>path_</code> Path to the file </li> </ul> <p>Returns:</p> <p>A promise that will be resolved when the module ends, and rejected if the module throws an exception. </p>"},{"location":"doxygen/classjac_1_1ModuleLoaderFeature/#function-evalfilewitheventloop","title":"function evalFileWithEventLoop","text":"<p>Evaluate a file and run the event loop until the program exits or throws an exception. <pre><code>inline void jac::ModuleLoaderFeature::evalFileWithEventLoop (\n    std::string path_\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>path_</code> Path to the file </li> </ul>"},{"location":"doxygen/classjac_1_1ModuleLoaderFeature/#function-initialize","title":"function initialize","text":"<pre><code>inline void jac::ModuleLoaderFeature::initialize () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/moduleLoaderFeature.h</code></p>"},{"location":"doxygen/classjac_1_1ObjectWrapper/","title":"Class jac::ObjectWrapper","text":"<p>template &lt;bool managed&gt;</p> <p>ClassList &gt; jac &gt; ObjectWrapper</p> <p>A wrapper for JSValue with Object type with RAII. More...</p> <ul> <li><code>#include &lt;values.h&gt;</code></li> </ul> <p>Inherits the following classes: jac::ValueWrapper</p> <p>Inherited by the following classes: jac::ArrayBufferWrapper,  jac::ArrayWrapper,  jac::FunctionWrapper,  jac::PromiseWrapper</p>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#public-functions","title":"Public Functions","text":"Type Name ObjectWrapper (ValueWrapper&lt; managed &gt; value) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Object is destroyed. ObjectWrapper (ContextRef ctx, JSValue val)  void defineProperty (Id id, Value value, PropFlags flags=PropFlags::Default) Define a property of the object. void deleteProperty (Id id) Delete a property of the object. T get (Atom prop) Get a property of the object. T get (const std::string &amp; name)  T get (uint32_t idx)  Object getPrototype () Get the prototype of the object. bool hasProperty (Id id) Check if the object has a property. Res invoke (Atom key, Args... args) Invoke a method of the object. Res invoke (const std::string &amp; key, Args... args)  Res invoke (uint32_t idx, Args... args)  void set (Atom prop, T val) Set a property of the object. void set (const std::string &amp; name, T val)  void set (uint32_t idx, T val)  void setPrototype (Object proto) Set the prototype of the object."},{"location":"doxygen/classjac_1_1ObjectWrapper/#public-functions-inherited-from-jacvaluewrapper","title":"Public Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ValueWrapper (ContextRef ctx, JSValue val) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Value is destroyed. ValueWrapper (const ValueWrapper &amp; other)  ValueWrapper (ValueWrapper &amp;&amp; other)  JSValue &amp; getVal () Get reference to the underlying JSValue. bool isArray () Check if the Value is an array. bool isFunction () Check if the Value is a function. bool isNull () Check if the Value is null. bool isObject () Check if the Value is an object. bool isUndefined () Check if the Value is undefined. std::pair&lt; ContextRef, JSValue &gt; loot () Release ownership of the JSValue. The JSValue will have to be freed manually. operator ValueWeak ()  ValueWrapper &amp; operator= (const ValueWrapper &amp; other)  ValueWrapper &amp; operator= (ValueWrapper &amp;&amp; other)  Value stringify (int indent=0) Convert the Value to a JSON representation. T to () Convert the Value to a specified type. StringView toString () Convert the Value to a StringView . ~ValueWrapper ()"},{"location":"doxygen/classjac_1_1ObjectWrapper/#public-static-functions","title":"Public Static Functions","text":"Type Name Object create (ContextRef ctx) Create a new empty object."},{"location":"doxygen/classjac_1_1ObjectWrapper/#public-static-functions-inherited-from-jacvaluewrapper","title":"Public Static Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name Value from (ContextRef ctx, T val) Create a new Value by converting a given value. Value fromJSON (ContextRef ctx, std::string json, std::string filename=\"&lt;json&gt;\", bool extended=false) Create a new Value from a given JSON string. Value null (ContextRef ctx) Create a new Value containing null. Value undefined (ContextRef ctx) Create a new Value containing undefined."},{"location":"doxygen/classjac_1_1ObjectWrapper/#protected-attributes-inherited-from-jacvaluewrapper","title":"Protected Attributes inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ContextRef _ctx JSValue _val"},{"location":"doxygen/classjac_1_1ObjectWrapper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>managed</code> whether the JSValue should be freed when the wrapper is destroyed. </li> </ul>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-objectwrapper-12","title":"function ObjectWrapper [1/2]","text":"<p>Wrap an existing JSValue. If managed is true, JSValue will be freed when the Object is destroyed. <pre><code>inline jac::ObjectWrapper::ObjectWrapper (\n    ValueWrapper &lt; managed &gt; value\n) \n</code></pre></p> <p>Note:</p> <p>Used internally when directly working with QuickJS API. New Object should be created using Object::create() or by converting an existing Value to an Object using Value::to&lt;Object&gt;().</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>val</code> JSValue to wrap </li> </ul>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-objectwrapper-22","title":"function ObjectWrapper [2/2]","text":"<pre><code>inline jac::ObjectWrapper::ObjectWrapper (\n    ContextRef ctx,\n    JSValue val\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-defineproperty","title":"function defineProperty","text":"<p>Define a property of the object. <pre><code>template&lt;typename Id&gt;\ninline void jac::ObjectWrapper::defineProperty (\n    Id id,\n    Value value,\n    PropFlags flags=PropFlags::Default\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Id</code> the type of the property identifier (Atom, std::string, uint32_t) </li> </ul> <p>Parameters:</p> <ul> <li><code>id</code> the property identifier </li> <li><code>value</code> the value to set </li> <li><code>flags</code> the property flags </li> </ul>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-deleteproperty","title":"function deleteProperty","text":"<p>Delete a property of the object. <pre><code>template&lt;typename Id&gt;\ninline void jac::ObjectWrapper::deleteProperty (\n    Id id\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Id</code> the type of the property identifier (Atom, std::string, uint32_t) </li> </ul> <p>Parameters:</p> <ul> <li><code>id</code> the property identifier </li> </ul>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-get-13","title":"function get [1/3]","text":"<p>Get a property of the object. <pre><code>template&lt;typename T&gt;\ninline T jac::ObjectWrapper::get (\n    Atom prop\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> type to convert the property to </li> </ul> <p>Parameters:</p> <ul> <li><code>prop</code> the property identifier </li> </ul> <p>Returns:</p> <p>The resulting value </p>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-get-23","title":"function get [2/3]","text":"<pre><code>template&lt;typename T&gt;\ninline T jac::ObjectWrapper::get (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-get-33","title":"function get [3/3]","text":"<pre><code>template&lt;typename T&gt;\ninline T jac::ObjectWrapper::get (\n    uint32_t idx\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-getprototype","title":"function getPrototype","text":"<p>Get the prototype of the object. <pre><code>inline Object jac::ObjectWrapper::getPrototype () \n</code></pre></p> <p>Returns:</p> <p>The prototype </p>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-hasproperty","title":"function hasProperty","text":"<p>Check if the object has a property. <pre><code>template&lt;typename Id&gt;\ninline bool jac::ObjectWrapper::hasProperty (\n    Id id\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Id</code> the type of the property identifier (Atom, std::string, uint32_t) </li> </ul> <p>Parameters:</p> <ul> <li><code>id</code> the property identifier </li> </ul> <p>Returns:</p> <p>true if the object has the property, false otherwise </p>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-invoke-13","title":"function invoke [1/3]","text":"<p>Invoke a method of the object. <pre><code>template&lt;typename Res, typename... Args&gt;\nRes jac::ObjectWrapper::invoke (\n    Atom key,\n    Args... args\n) \n</code></pre></p> <p>Note:</p> <p>The call will automatically convert the arguments to their JavaScript counterparts, the result will be converted to the specified type and Exceptions thrown in JS will be propagated to C++ as jac::Exception.</p> <p>Template parameters:</p> <ul> <li><code>Res</code> type to convert the result to </li> <li><code>Args</code> types of the arguments </li> </ul> <p>Parameters:</p> <ul> <li><code>prop</code> the property identifier </li> <li><code>args</code> the arguments </li> </ul> <p>Returns:</p> <p>The resulting value </p>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-invoke-23","title":"function invoke [2/3]","text":"<pre><code>template&lt;typename Res, typename... Args&gt;\ninline Res jac::ObjectWrapper::invoke (\n    const std::string &amp; key,\n    Args... args\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-invoke-33","title":"function invoke [3/3]","text":"<pre><code>template&lt;typename Res, typename... Args&gt;\ninline Res jac::ObjectWrapper::invoke (\n    uint32_t idx,\n    Args... args\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-set-13","title":"function set [1/3]","text":"<p>Set a property of the object. <pre><code>template&lt;typename T&gt;\ninline void jac::ObjectWrapper::set (\n    Atom prop,\n    T val\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> type of the value to set </li> </ul> <p>Parameters:</p> <ul> <li><code>prop</code> the property identifier </li> <li><code>val</code> the value to set </li> </ul>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-set-23","title":"function set [2/3]","text":"<pre><code>template&lt;typename T&gt;\ninline void jac::ObjectWrapper::set (\n    const std::string &amp; name,\n    T val\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-set-33","title":"function set [3/3]","text":"<pre><code>template&lt;typename T&gt;\ninline void jac::ObjectWrapper::set (\n    uint32_t idx,\n    T val\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-setprototype","title":"function setPrototype","text":"<p>Set the prototype of the object. <pre><code>inline void jac::ObjectWrapper::setPrototype (\n    Object proto\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>proto</code> the prototype </li> </ul>"},{"location":"doxygen/classjac_1_1ObjectWrapper/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ObjectWrapper/#function-create","title":"function create","text":"<p>Create a new empty object. <pre><code>static inline Object jac::ObjectWrapper::create (\n    ContextRef ctx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> the context to create the object in </li> </ul> <p>Returns:</p> <p>The new object </p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/values.h</code></p>"},{"location":"doxygen/classjac_1_1OsWritable/","title":"Class jac::OsWritable","text":"<p>ClassList &gt; jac &gt; OsWritable</p> <p>Inherits the following classes: jac::Writable</p>"},{"location":"doxygen/classjac_1_1OsWritable/#public-functions","title":"Public Functions","text":"Type Name OsWritable (std::ostream &amp; stream)  virtual void write (std::string data) override"},{"location":"doxygen/classjac_1_1OsWritable/#public-functions-inherited-from-jacwritable","title":"Public Functions inherited from jac::Writable","text":"<p>See jac::Writable</p> Type Name virtual void write (std::string data) = 0 virtual ~Writable () = default"},{"location":"doxygen/classjac_1_1OsWritable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1OsWritable/#function-oswritable","title":"function OsWritable","text":"<pre><code>inline jac::OsWritable::OsWritable (\n    std::ostream &amp; stream\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1OsWritable/#function-write","title":"function write","text":"<pre><code>inline virtual void jac::OsWritable::write (\n    std::string data\n) override\n</code></pre> <p>Implements jac::Writable::write</p> <p>The documentation for this class was generated from the following file <code>src/jac/features/util/ostreamjs.h</code></p>"},{"location":"doxygen/classjac_1_1Plugin/","title":"Class jac::Plugin","text":"<p>ClassList &gt; jac &gt; Plugin</p> <p>A base class for all plugins. </p> <ul> <li><code>#include &lt;plugins.h&gt;</code></li> </ul>"},{"location":"doxygen/classjac_1_1Plugin/#public-functions","title":"Public Functions","text":"Type Name virtual ~Plugin () = default"},{"location":"doxygen/classjac_1_1Plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Plugin/#function-plugin","title":"function ~Plugin","text":"<pre><code>virtual jac::Plugin::~Plugin () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/plugins.h</code></p>"},{"location":"doxygen/classjac_1_1PluginHandle/","title":"Class jac::PluginHandle","text":"<p>ClassList &gt; jac &gt; PluginHandle</p> <p>A handle which can be used to retrieve a plugin from a machine. </p> <ul> <li><code>#include &lt;plugins.h&gt;</code></li> </ul>"},{"location":"doxygen/classjac_1_1PluginHandle/#public-functions","title":"Public Functions","text":"Type Name PluginHandle (size_t index)  size_t index () const PluginHandle operator+ (size_t offset)  PluginHandle &amp; operator++ ()  PluginHandle operator++ (int)  bool operator== (const PluginHandle &amp; other) const"},{"location":"doxygen/classjac_1_1PluginHandle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1PluginHandle/#function-pluginhandle","title":"function PluginHandle","text":"<pre><code>inline jac::PluginHandle::PluginHandle (\n    size_t index\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1PluginHandle/#function-index","title":"function index","text":"<pre><code>inline size_t jac::PluginHandle::index () const\n</code></pre>"},{"location":"doxygen/classjac_1_1PluginHandle/#function-operator","title":"function operator+","text":"<pre><code>inline PluginHandle jac::PluginHandle::operator+ (\n    size_t offset\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1PluginHandle/#function-operator_1","title":"function operator++","text":"<pre><code>inline PluginHandle &amp; jac::PluginHandle::operator++ () \n</code></pre>"},{"location":"doxygen/classjac_1_1PluginHandle/#function-operator_2","title":"function operator++","text":"<pre><code>inline PluginHandle jac::PluginHandle::operator++ (\n    int\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1PluginHandle/#function-operator_3","title":"function operator==","text":"<pre><code>bool jac::PluginHandle::operator== (\n    const PluginHandle &amp; other\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/plugins.h</code></p>"},{"location":"doxygen/classjac_1_1PluginHolderFeature/","title":"Class jac::PluginHolderFeature","text":"<p>template &lt;typename Next&gt;</p> <p>ClassList &gt; jac &gt; PluginHolderFeature</p> <p>An MFeature that allows for inserting plugins into the machine and retrieving them using PluginHandeles. </p> <ul> <li><code>#include &lt;plugins.h&gt;</code></li> </ul> <p>Inherits the following classes: Next</p>"},{"location":"doxygen/classjac_1_1PluginHolderFeature/#public-functions","title":"Public Functions","text":"Type Name PluginHolderFeature () = default Plugin_t &amp; getPlugin (PluginHandle handle)  PluginHandle holdPlugin (std::unique_ptr&lt; Plugin &gt; plugin)  PluginHandle pluginBegin ()  PluginHandle pluginEnd ()"},{"location":"doxygen/classjac_1_1PluginHolderFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1PluginHolderFeature/#function-pluginholderfeature","title":"function PluginHolderFeature","text":"<pre><code>jac::PluginHolderFeature::PluginHolderFeature () = default\n</code></pre>"},{"location":"doxygen/classjac_1_1PluginHolderFeature/#function-getplugin","title":"function getPlugin","text":"<pre><code>template&lt;typename Plugin_t&gt;\ninline Plugin_t &amp; jac::PluginHolderFeature::getPlugin (\n    PluginHandle handle\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1PluginHolderFeature/#function-holdplugin","title":"function holdPlugin","text":"<pre><code>inline PluginHandle jac::PluginHolderFeature::holdPlugin (\n    std::unique_ptr&lt; Plugin &gt; plugin\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1PluginHolderFeature/#function-pluginbegin","title":"function pluginBegin","text":"<pre><code>inline PluginHandle jac::PluginHolderFeature::pluginBegin () \n</code></pre>"},{"location":"doxygen/classjac_1_1PluginHolderFeature/#function-pluginend","title":"function pluginEnd","text":"<pre><code>inline PluginHandle jac::PluginHolderFeature::pluginEnd () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/plugins.h</code></p>"},{"location":"doxygen/classjac_1_1PluginManager/","title":"Class jac::PluginManager","text":"<p>ClassList &gt; jac &gt; PluginManager</p> <p>A class for managing groups of plugins and initializing them all at once. </p> <ul> <li><code>#include &lt;plugins.h&gt;</code></li> </ul>"},{"location":"doxygen/classjac_1_1PluginManager/#public-functions","title":"Public Functions","text":"Type Name PluginManager () = default size_t addPlugin () Adds a plugin to the manager. PluginHandle initialize (Machine &amp; machine) Initializes all plugins in the manager."},{"location":"doxygen/classjac_1_1PluginManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1PluginManager/#function-pluginmanager","title":"function PluginManager","text":"<pre><code>jac::PluginManager::PluginManager () = default\n</code></pre>"},{"location":"doxygen/classjac_1_1PluginManager/#function-addplugin","title":"function addPlugin","text":"<p>Adds a plugin to the manager. <pre><code>template&lt;typename Plugin_t&gt;\ninline size_t jac::PluginManager::addPlugin () \n</code></pre></p> <p>Note:</p> <p>The initialization of the plugin is to be performed by the constructor. </p> <p>Template parameters:</p> <ul> <li><code>Plugin_t</code> The type of the plugin to add </li> </ul> <p>Returns:</p> <p>The offset of the plugin in the group. Can be added to the PluginHandle returned by initialize() to get a handle to the plugin instance inside the Machine. </p>"},{"location":"doxygen/classjac_1_1PluginManager/#function-initialize","title":"function initialize","text":"<p>Initializes all plugins in the manager. <pre><code>template&lt;typename Machine&gt;\ninline PluginHandle jac::PluginManager::initialize (\n    Machine &amp; machine\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Machine</code> The type of the machine to initialize the plugins for </li> </ul> <p>Parameters:</p> <ul> <li><code>machine</code> The machine to initialize the plugins for </li> </ul> <p>Returns:</p> <p>A Handle to the first plugin initialized. </p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/plugins.h</code></p>"},{"location":"doxygen/classjac_1_1PromiseWrapper/","title":"Class jac::PromiseWrapper","text":"<p>template &lt;bool managed&gt;</p> <p>ClassList &gt; jac &gt; PromiseWrapper</p> <p>A wrapper for JSValue with Promise type with RAII. More...</p> <ul> <li><code>#include &lt;values.h&gt;</code></li> </ul> <p>Inherits the following classes: jac::ObjectWrapper</p>"},{"location":"doxygen/classjac_1_1PromiseWrapper/#public-functions","title":"Public Functions","text":"Type Name PromiseWrapper (ObjectWrapper&lt; managed &gt; value) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Promise is destroyed. PromiseWrapper (ContextRef ctx, JSValue val)"},{"location":"doxygen/classjac_1_1PromiseWrapper/#public-functions-inherited-from-jacobjectwrapper","title":"Public Functions inherited from jac::ObjectWrapper","text":"<p>See jac::ObjectWrapper</p> Type Name ObjectWrapper (ValueWrapper&lt; managed &gt; value) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Object is destroyed. ObjectWrapper (ContextRef ctx, JSValue val)  void defineProperty (Id id, Value value, PropFlags flags=PropFlags::Default) Define a property of the object. void deleteProperty (Id id) Delete a property of the object. T get (Atom prop) Get a property of the object. T get (const std::string &amp; name)  T get (uint32_t idx)  Object getPrototype () Get the prototype of the object. bool hasProperty (Id id) Check if the object has a property. Res invoke (Atom key, Args... args) Invoke a method of the object. Res invoke (const std::string &amp; key, Args... args)  Res invoke (uint32_t idx, Args... args)  void set (Atom prop, T val) Set a property of the object. void set (const std::string &amp; name, T val)  void set (uint32_t idx, T val)  void setPrototype (Object proto) Set the prototype of the object."},{"location":"doxygen/classjac_1_1PromiseWrapper/#public-functions-inherited-from-jacvaluewrapper","title":"Public Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ValueWrapper (ContextRef ctx, JSValue val) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Value is destroyed. ValueWrapper (const ValueWrapper &amp; other)  ValueWrapper (ValueWrapper &amp;&amp; other)  JSValue &amp; getVal () Get reference to the underlying JSValue. bool isArray () Check if the Value is an array. bool isFunction () Check if the Value is a function. bool isNull () Check if the Value is null. bool isObject () Check if the Value is an object. bool isUndefined () Check if the Value is undefined. std::pair&lt; ContextRef, JSValue &gt; loot () Release ownership of the JSValue. The JSValue will have to be freed manually. operator ValueWeak ()  ValueWrapper &amp; operator= (const ValueWrapper &amp; other)  ValueWrapper &amp; operator= (ValueWrapper &amp;&amp; other)  Value stringify (int indent=0) Convert the Value to a JSON representation. T to () Convert the Value to a specified type. StringView toString () Convert the Value to a StringView . ~ValueWrapper ()"},{"location":"doxygen/classjac_1_1PromiseWrapper/#public-static-functions","title":"Public Static Functions","text":"Type Name std::tuple&lt; Promise, Function, Function &gt; create (ContextRef ctx) Create a new Promise object."},{"location":"doxygen/classjac_1_1PromiseWrapper/#public-static-functions-inherited-from-jacobjectwrapper","title":"Public Static Functions inherited from jac::ObjectWrapper","text":"<p>See jac::ObjectWrapper</p> Type Name Object create (ContextRef ctx) Create a new empty object."},{"location":"doxygen/classjac_1_1PromiseWrapper/#public-static-functions-inherited-from-jacvaluewrapper","title":"Public Static Functions inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name Value from (ContextRef ctx, T val) Create a new Value by converting a given value. Value fromJSON (ContextRef ctx, std::string json, std::string filename=\"&lt;json&gt;\", bool extended=false) Create a new Value from a given JSON string. Value null (ContextRef ctx) Create a new Value containing null. Value undefined (ContextRef ctx) Create a new Value containing undefined."},{"location":"doxygen/classjac_1_1PromiseWrapper/#protected-attributes-inherited-from-jacvaluewrapper","title":"Protected Attributes inherited from jac::ValueWrapper","text":"<p>See jac::ValueWrapper</p> Type Name ContextRef _ctx JSValue _val"},{"location":"doxygen/classjac_1_1PromiseWrapper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>managed</code> whether the JSValue should be freed when the wrapper is destroyed. </li> </ul>"},{"location":"doxygen/classjac_1_1PromiseWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1PromiseWrapper/#function-promisewrapper-12","title":"function PromiseWrapper [1/2]","text":"<p>Wrap an existing JSValue. If managed is true, JSValue will be freed when the Promise is destroyed. <pre><code>inline jac::PromiseWrapper::PromiseWrapper (\n    ObjectWrapper &lt; managed &gt; value\n) \n</code></pre></p> <p>Note:</p> <p>Used internally when directly working with QuickJS API. New Promise should be created using Promise::create().</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>val</code> JSValue to wrap </li> </ul>"},{"location":"doxygen/classjac_1_1PromiseWrapper/#function-promisewrapper-22","title":"function PromiseWrapper [2/2]","text":"<pre><code>inline jac::PromiseWrapper::PromiseWrapper (\n    ContextRef ctx,\n    JSValue val\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1PromiseWrapper/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classjac_1_1PromiseWrapper/#function-create","title":"function create","text":"<p>Create a new Promise object. <pre><code>static inline std::tuple&lt; Promise , Function , Function &gt; jac::PromiseWrapper::create (\n    ContextRef ctx\n) \n</code></pre></p> <p>Returns:</p> <p>Tuple of the Promise object, resolve function, reject function </p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/values.h</code></p>"},{"location":"doxygen/namespacejac_1_1ProtoBuilder/","title":"Namespace jac::ProtoBuilder","text":"<p>Namespace List &gt; jac &gt; ProtoBuilder</p>"},{"location":"doxygen/namespacejac_1_1ProtoBuilder/#classes","title":"Classes","text":"Type Name struct Callable A base class for javascript classes with callable instances. struct LifetimeHandles A base class used to add handles for lifetime events of an instance. struct Opaque &lt;typename T&gt;A base class for javascript classes with opaque data. struct Properties A base class for javascript classes with added properties. <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Callable/","title":"Struct jac::ProtoBuilder::Callable","text":"<p>ClassList &gt; jac &gt; ProtoBuilder &gt; Callable</p> <p>A base class for javascript classes with callable instances. More...</p> <ul> <li><code>#include &lt;class.h&gt;</code></li> </ul>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Callable/#public-static-functions","title":"Public Static Functions","text":"Type Name Value callConstructor (ContextRef, ValueWeak, ValueWeak, std::vector&lt; ValueWeak &gt;) Process a call to the wrapped class as a constructor. Value callFunction (ContextRef, ValueWeak, ValueWeak, std::vector&lt; ValueWeak &gt;) Process a call to the wrapped class."},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Callable/#detailed-description","title":"Detailed Description","text":"<p>The functions <code>callFunction</code> and <code>callConstructor</code> can be overriden to provide custom handling of the class instance when it's called as a function or as a constructor (with <code>new</code>). </p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Callable/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Callable/#function-callconstructor","title":"function callConstructor","text":"<p>Process a call to the wrapped class as a constructor. <pre><code>static inline Value jac::ProtoBuilder::Callable::callConstructor (\n    ContextRef,\n    ValueWeak,\n    ValueWeak,\n    std::vector&lt; ValueWeak &gt;\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>funcObj</code> instance of the class </li> <li><code>target</code> value of <code>new.target</code> in the function </li> <li><code>args</code> arguments passed to the function </li> </ul> <p>Returns:</p> <p>Result of the call </p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Callable/#function-callfunction","title":"function callFunction","text":"<p>Process a call to the wrapped class. <pre><code>static inline Value jac::ProtoBuilder::Callable::callFunction (\n    ContextRef,\n    ValueWeak,\n    ValueWeak,\n    std::vector&lt; ValueWeak &gt;\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>funcObj</code> instance of the class </li> <li><code>thisVal</code> value of <code>this</code> in the function </li> <li><code>args</code> arguments passed to the function </li> </ul> <p>Returns:</p> <p>result of the call </p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1LifetimeHandles/","title":"Struct jac::ProtoBuilder::LifetimeHandles","text":"<p>ClassList &gt; jac &gt; ProtoBuilder &gt; LifetimeHandles</p> <p>A base class used to add handles for lifetime events of an instance. More...</p> <ul> <li><code>#include &lt;class.h&gt;</code></li> </ul>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1LifetimeHandles/#public-static-functions","title":"Public Static Functions","text":"Type Name void postConstruction (ContextRef ctx, Object thisVal, std::vector&lt; ValueWeak &gt; args)"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1LifetimeHandles/#detailed-description","title":"Detailed Description","text":"<p>The functions <code>postConstruction</code> can be overriden to provide custom handling of the class instance after it's constructed. </p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1LifetimeHandles/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1LifetimeHandles/#function-postconstruction","title":"function postConstruction","text":"<pre><code>static inline void jac::ProtoBuilder::LifetimeHandles::postConstruction (\n    ContextRef ctx,\n    Object thisVal,\n    std::vector&lt; ValueWeak &gt; args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/","title":"Struct jac::ProtoBuilder::Opaque","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; jac &gt; ProtoBuilder &gt; Opaque</p> <p>A base class for javascript classes with opaque data. More...</p> <ul> <li><code>#include &lt;class.h&gt;</code></li> </ul>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#public-types","title":"Public Types","text":"Type Name typedef T OpaqueType"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#public-static-attributes","title":"Public Static Attributes","text":"Type Name JSClassID classId"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#public-static-functions","title":"Public Static Functions","text":"Type Name void addMethodMember (ContextRef ctx, Object proto, std::string name, PropFlags flags=PropFlags::Default) Add a property to the object prototype from a member function of the wrapped class. void addPropMember (ContextRef ctx, Object proto, std::string name, PropFlags flags=PropFlags::Default) Add a property to the object prototype from a member variable of the wrapped class. Value callMember (ContextRef ctx, ValueWeak funcObj, ValueWeak thisVal, std::vector&lt; ValueWeak &gt; argv) Process a call to a member function of the wrapped class. T * constructOpaque (ContextRef, std::vector&lt; ValueWeak &gt;) Construct a new Opaque object from javascript arguments. void destroyOpaque (JSRuntime *, T * ptr) noexceptDestroy the Opaque object. T * getOpaque (ContextRef, ValueWeak thisVal) Get the Opaque object from an instance of the class."},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#detailed-description","title":"Detailed Description","text":"<p>The functions <code>constructOpaque</code> and <code>destroyOpaque</code> can be overriden to provide custom construction and destruction of the opaque data.</p> <p>Template parameters:</p> <ul> <li><code>T</code> The type of the opaque data </li> </ul>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#typedef-opaquetype","title":"typedef OpaqueType","text":"<pre><code>using jac::ProtoBuilder::Opaque&lt; T &gt;::OpaqueType =  T;\n</code></pre>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#variable-classid","title":"variable classId","text":"<pre><code>JSClassID jac::ProtoBuilder::Opaque&lt; T &gt;::classId;\n</code></pre>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#function-addmethodmember","title":"function addMethodMember","text":"<p>Add a property to the object prototype from a member function of the wrapped class. <pre><code>template&lt;typename  Sgn, Sgn member&gt;\nstatic inline void jac::ProtoBuilder::Opaque::addMethodMember (\n    ContextRef ctx,\n    Object proto,\n    std::string name,\n    PropFlags flags=PropFlags::Default\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Sgn</code> signature of the member function </li> <li><code>member</code> pointer to the member function </li> </ul> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>proto</code> the prototype of the class </li> <li><code>name</code> name of the property </li> <li><code>flags</code> flags of the property </li> </ul>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#function-addpropmember","title":"function addPropMember","text":"<p>Add a property to the object prototype from a member variable of the wrapped class. <pre><code>template&lt;typename  U, UT::* member&gt;\nstatic inline void jac::ProtoBuilder::Opaque::addPropMember (\n    ContextRef ctx,\n    Object proto,\n    std::string name,\n    PropFlags flags=PropFlags::Default\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>U</code> the type of the member variable </li> <li><code>U(T::*member)</code> pointer to the member variable </li> </ul> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>proto</code> the prototype of the class </li> <li><code>name</code> name of the property </li> <li><code>flags</code> flags of the property </li> </ul>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#function-callmember","title":"function callMember","text":"<p>Process a call to a member function of the wrapped class. <pre><code>template&lt;typename  Sgn, Sgn member&gt;\nstatic inline Value jac::ProtoBuilder::Opaque::callMember (\n    ContextRef ctx,\n    ValueWeak funcObj,\n    ValueWeak thisVal,\n    std::vector&lt; ValueWeak &gt; argv\n) \n</code></pre></p> <p>Note:</p> <p>The arguments and return value are automatically converted to and from javascript values</p> <p>Template parameters:</p> <ul> <li><code>Sgn</code> the signature of the member function </li> <li><code>member</code> pointer to the member function </li> </ul> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>funcObj</code> instance of the class </li> <li><code>thisVal</code> value of <code>this</code> in the function </li> <li><code>argv</code> arguments passed to the function </li> </ul> <p>Returns:</p> <p>Result of the call </p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#function-constructopaque","title":"function constructOpaque","text":"<p>Construct a new Opaque object from javascript arguments. <pre><code>static inline T * jac::ProtoBuilder::Opaque::constructOpaque (\n    ContextRef,\n    std::vector&lt; ValueWeak &gt;\n) \n</code></pre></p> <p>Note:</p> <p>This function is only called upon javascript class instantiation</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>args</code> arguments passed to the constructor </li> </ul> <p>Returns:</p> <p>A pointer to the opaque data </p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#function-destroyopaque","title":"function destroyOpaque","text":"<p>Destroy the Opaque object. <pre><code>static inline void jac::ProtoBuilder::Opaque::destroyOpaque (\n    JSRuntime *,\n    T * ptr\n) noexcept\n</code></pre></p> <p>Note:</p> <p>This function is only called when the javascript object is garbage collected</p> <p>Parameters:</p> <ul> <li><code>rt</code> runtime to work in </li> <li><code>ptr</code> pointer to the opaque data </li> </ul>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Opaque/#function-getopaque","title":"function getOpaque","text":"<p>Get the Opaque object from an instance of the class. <pre><code>static inline T * jac::ProtoBuilder::Opaque::getOpaque (\n    ContextRef,\n    ValueWeak thisVal\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>thisVal</code> the instance of the class </li> </ul> <p>Returns:</p> <p>A pointer to the opaque data </p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Properties/","title":"Struct jac::ProtoBuilder::Properties","text":"<p>ClassList &gt; jac &gt; ProtoBuilder &gt; Properties</p> <p>A base class for javascript classes with added properties. More...</p> <ul> <li><code>#include &lt;class.h&gt;</code></li> </ul> <p>Inherited by the following classes: jac::FileProtoBuilder,  jac::ReadableProtoBuilder,  jac::WritableProtoBuilder</p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Properties/#public-static-functions","title":"Public Static Functions","text":"Type Name void addProperties (ContextRef ctx, Object proto) Add properties to the object prototype."},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Properties/#detailed-description","title":"Detailed Description","text":"<p>The function <code>addProperties</code> can be overriden to specify custom properties for the class prototype. </p>"},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Properties/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1ProtoBuilder_1_1Properties/#function-addproperties","title":"function addProperties","text":"<p>Add properties to the object prototype. <pre><code>static inline void jac::ProtoBuilder::Properties::addProperties (\n    ContextRef ctx,\n    Object proto\n) \n</code></pre></p> <p>Note:</p> <p>This function is only called when the class prototype is created</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>proto</code> the prototype of the class </li> </ul> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/classjac_1_1Readable/","title":"Class jac::Readable","text":"<p>ClassList &gt; jac &gt; Readable</p> <p>Inherited by the following classes: jac::ReadableRef</p>"},{"location":"doxygen/classjac_1_1Readable/#public-functions","title":"Public Functions","text":"Type Name virtual bool get (std::function&lt; void(char)&gt; callback) = 0 virtual bool read (std::function&lt; void(std::string)&gt; callback) = 0 virtual ~Readable () = default"},{"location":"doxygen/classjac_1_1Readable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Readable/#function-get","title":"function get","text":"<pre><code>virtual bool jac::Readable::get (\n    std::function&lt; void(char)&gt; callback\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1Readable/#function-read","title":"function read","text":"<pre><code>virtual bool jac::Readable::read (\n    std::function&lt; void(std::string)&gt; callback\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1Readable/#function-readable","title":"function ~Readable","text":"<pre><code>virtual jac::Readable::~Readable () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/types/streams.h</code></p>"},{"location":"doxygen/structjac_1_1ReadableProtoBuilder/","title":"Struct jac::ReadableProtoBuilder","text":"<p>ClassList &gt; jac &gt; ReadableProtoBuilder</p> <p>Inherits the following classes: jac::ProtoBuilder::Opaque,  jac::ProtoBuilder::Properties</p>"},{"location":"doxygen/structjac_1_1ReadableProtoBuilder/#public-types-inherited-from-jacprotobuilderopaque","title":"Public Types inherited from jac::ProtoBuilder::Opaque","text":"<p>See jac::ProtoBuilder::Opaque</p> Type Name typedef T OpaqueType"},{"location":"doxygen/structjac_1_1ReadableProtoBuilder/#public-static-attributes-inherited-from-jacprotobuilderopaque","title":"Public Static Attributes inherited from jac::ProtoBuilder::Opaque","text":"<p>See jac::ProtoBuilder::Opaque</p> Type Name JSClassID classId"},{"location":"doxygen/structjac_1_1ReadableProtoBuilder/#public-static-functions","title":"Public Static Functions","text":"Type Name void addProperties (ContextRef ctx, Object proto)"},{"location":"doxygen/structjac_1_1ReadableProtoBuilder/#public-static-functions-inherited-from-jacprotobuilderopaque","title":"Public Static Functions inherited from jac::ProtoBuilder::Opaque","text":"<p>See jac::ProtoBuilder::Opaque</p> Type Name void addMethodMember (ContextRef ctx, Object proto, std::string name, PropFlags flags=PropFlags::Default) Add a property to the object prototype from a member function of the wrapped class. void addPropMember (ContextRef ctx, Object proto, std::string name, PropFlags flags=PropFlags::Default) Add a property to the object prototype from a member variable of the wrapped class. Value callMember (ContextRef ctx, ValueWeak funcObj, ValueWeak thisVal, std::vector&lt; ValueWeak &gt; argv) Process a call to a member function of the wrapped class. T * constructOpaque (ContextRef, std::vector&lt; ValueWeak &gt;) Construct a new Opaque object from javascript arguments. void destroyOpaque (JSRuntime *, T * ptr) noexceptDestroy the Opaque object. T * getOpaque (ContextRef, ValueWeak thisVal) Get the Opaque object from an instance of the class."},{"location":"doxygen/structjac_1_1ReadableProtoBuilder/#public-static-functions-inherited-from-jacprotobuilderproperties","title":"Public Static Functions inherited from jac::ProtoBuilder::Properties","text":"<p>See jac::ProtoBuilder::Properties</p> Type Name void addProperties (ContextRef ctx, Object proto) Add properties to the object prototype."},{"location":"doxygen/structjac_1_1ReadableProtoBuilder/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1ReadableProtoBuilder/#function-addproperties","title":"function addProperties","text":"<pre><code>static inline void jac::ReadableProtoBuilder::addProperties (\n    ContextRef ctx,\n    Object proto\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/basicStreamFeature.h</code></p>"},{"location":"doxygen/classjac_1_1ReadableRef/","title":"Class jac::ReadableRef","text":"<p>ClassList &gt; jac &gt; ReadableRef</p> <p>Inherits the following classes: jac::Readable</p>"},{"location":"doxygen/classjac_1_1ReadableRef/#public-functions","title":"Public Functions","text":"Type Name ReadableRef (Readable * ptr)  virtual bool get (std::function&lt; void(char)&gt; callback) override virtual bool read (std::function&lt; void(std::string)&gt; callback) override"},{"location":"doxygen/classjac_1_1ReadableRef/#public-functions-inherited-from-jacreadable","title":"Public Functions inherited from jac::Readable","text":"<p>See jac::Readable</p> Type Name virtual bool get (std::function&lt; void(char)&gt; callback) = 0 virtual bool read (std::function&lt; void(std::string)&gt; callback) = 0 virtual ~Readable () = default"},{"location":"doxygen/classjac_1_1ReadableRef/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ReadableRef/#function-readableref","title":"function ReadableRef","text":"<pre><code>inline jac::ReadableRef::ReadableRef (\n    Readable * ptr\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ReadableRef/#function-get","title":"function get","text":"<pre><code>inline virtual bool jac::ReadableRef::get (\n    std::function&lt; void(char)&gt; callback\n) override\n</code></pre> <p>Implements jac::Readable::get</p>"},{"location":"doxygen/classjac_1_1ReadableRef/#function-read","title":"function read","text":"<pre><code>inline virtual bool jac::ReadableRef::read (\n    std::function&lt; void(std::string)&gt; callback\n) override\n</code></pre> <p>Implements jac::Readable::read</p> <p>The documentation for this class was generated from the following file <code>src/jac/features/types/streams.h</code></p>"},{"location":"doxygen/structjac_1_1SgnUnwrap/","title":"Struct jac::SgnUnwrap","text":"<p>template &lt;typename Sgn&gt;</p> <p>ClassList &gt; jac &gt; SgnUnwrap</p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/structjac_1_1SgnUnwrap_3_01Res_07Args_8_8_8_08_4/","title":"Struct jac::SgnUnwrap&lt; Res(Args...)&gt;","text":"<p>template &lt;typename Res, typename... Args&gt;</p> <p>ClassList &gt; jac &gt; SgnUnwrap&lt; Res(Args...)&gt;</p>"},{"location":"doxygen/structjac_1_1SgnUnwrap_3_01Res_07Args_8_8_8_08_4/#public-types","title":"Public Types","text":"Type Name typedef std::tuple&lt; Args... &gt; ArgTypes typedef Res ResType"},{"location":"doxygen/structjac_1_1SgnUnwrap_3_01Res_07Args_8_8_8_08_4/#public-functions","title":"Public Functions","text":"Type Name SgnUnwrap (Res(Class::*)(Args...))  SgnUnwrap (Res(Class::*)(Args...) const)"},{"location":"doxygen/structjac_1_1SgnUnwrap_3_01Res_07Args_8_8_8_08_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/structjac_1_1SgnUnwrap_3_01Res_07Args_8_8_8_08_4/#typedef-argtypes","title":"typedef ArgTypes","text":"<pre><code>using jac::SgnUnwrap&lt; Res(Args...)&gt;::ArgTypes =  std::tuple&lt;Args...&gt;;\n</code></pre>"},{"location":"doxygen/structjac_1_1SgnUnwrap_3_01Res_07Args_8_8_8_08_4/#typedef-restype","title":"typedef ResType","text":"<pre><code>using jac::SgnUnwrap&lt; Res(Args...)&gt;::ResType =  Res;\n</code></pre>"},{"location":"doxygen/structjac_1_1SgnUnwrap_3_01Res_07Args_8_8_8_08_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/structjac_1_1SgnUnwrap_3_01Res_07Args_8_8_8_08_4/#function-sgnunwrap-12","title":"function SgnUnwrap [1/2]","text":"<pre><code>template&lt;class Class&gt;\ninline jac::SgnUnwrap&lt; Res(Args...)&gt;::SgnUnwrap (\n    Res(Class::*)(Args...)\n) \n</code></pre>"},{"location":"doxygen/structjac_1_1SgnUnwrap_3_01Res_07Args_8_8_8_08_4/#function-sgnunwrap-22","title":"function SgnUnwrap [2/2]","text":"<pre><code>template&lt;class Class&gt;\ninline jac::SgnUnwrap&lt; Res(Args...)&gt;::SgnUnwrap (\n    Res(Class::*)(Args...) const\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/classjac_1_1StdioFeature/","title":"Class jac::StdioFeature","text":"<p>template &lt;class Next&gt;</p> <p>ClassList &gt; jac &gt; StdioFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"doxygen/classjac_1_1StdioFeature/#public-attributes","title":"Public Attributes","text":"Type Name Stdio stdio"},{"location":"doxygen/classjac_1_1StdioFeature/#public-functions","title":"Public Functions","text":"Type Name void initialize ()"},{"location":"doxygen/classjac_1_1StdioFeature/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/classjac_1_1StdioFeature/#variable-stdio","title":"variable stdio","text":"<pre><code>Stdio jac::StdioFeature&lt; Next &gt;::stdio;\n</code></pre>"},{"location":"doxygen/classjac_1_1StdioFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1StdioFeature/#function-initialize","title":"function initialize","text":"<pre><code>inline void jac::StdioFeature::initialize () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/stdioFeature.h</code></p>"},{"location":"doxygen/classjac_1_1StringView/","title":"Class jac::StringView","text":"<p>ClassList &gt; jac &gt; StringView</p> <p>A wrapper around QuickJS C-string with automatic memory management. </p> <ul> <li><code>#include &lt;stringView.h&gt;</code></li> </ul> <p>Inherits the following classes: std::basic_string_view&lt; char &gt;</p>"},{"location":"doxygen/classjac_1_1StringView/#public-functions","title":"Public Functions","text":"Type Name StringView (StringView &amp;&amp; other)  StringView (const basic_string_view &amp; other) = delete StringView (const StringView &amp; other) = delete StringView () = default StringView (ContextRef ctx, const char * str) Wrap a QuickJS allocated string. The string will be freed when the StringView is freed. const char * c_str () constGet the C string. string () const StringView &amp; operator= (StringView &amp;&amp; other)  StringView &amp; operator= (const StringView &amp; other) = delete ~StringView ()"},{"location":"doxygen/classjac_1_1StringView/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1StringView/#function-stringview-15","title":"function StringView [1/5]","text":"<pre><code>inline jac::StringView::StringView (\n    StringView &amp;&amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1StringView/#function-stringview-25","title":"function StringView [2/5]","text":"<pre><code>jac::StringView::StringView (\n    const basic_string_view &amp; other\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1StringView/#function-stringview-35","title":"function StringView [3/5]","text":"<pre><code>jac::StringView::StringView (\n    const StringView &amp; other\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1StringView/#function-stringview-45","title":"function StringView [4/5]","text":"<pre><code>jac::StringView::StringView () = default\n</code></pre>"},{"location":"doxygen/classjac_1_1StringView/#function-stringview-55","title":"function StringView [5/5]","text":"<p>Wrap a QuickJS allocated string. The string will be freed when the StringView is freed. <pre><code>inline jac::StringView::StringView (\n    ContextRef ctx,\n    const char * str\n) \n</code></pre></p> <p>Note:</p> <p>The string must be allocated using QuickJS functions - JS_NewString, JS_ToCString, etc.</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>str</code> string to wrap </li> </ul>"},{"location":"doxygen/classjac_1_1StringView/#function-c_str","title":"function c_str","text":"<p>Get the C string. <pre><code>inline const char * jac::StringView::c_str () const\n</code></pre></p> <p>Returns:</p> <p>const char* </p>"},{"location":"doxygen/classjac_1_1StringView/#function-string","title":"function string","text":"<pre><code>inline jac::StringView::string () const\n</code></pre>"},{"location":"doxygen/classjac_1_1StringView/#function-operator","title":"function operator=","text":"<pre><code>inline StringView &amp; jac::StringView::operator= (\n    StringView &amp;&amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1StringView/#function-operator_1","title":"function operator=","text":"<pre><code>StringView &amp; jac::StringView::operator= (\n    const StringView &amp; other\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1StringView/#function-stringview","title":"function ~StringView","text":"<pre><code>inline jac::StringView::~StringView () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/stringView.h</code></p>"},{"location":"doxygen/classjac_1_1TimersFeature/","title":"Class jac::TimersFeature","text":"<p>template &lt;class Next&gt;</p> <p>ClassList &gt; jac &gt; TimersFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"doxygen/classjac_1_1TimersFeature/#public-functions","title":"Public Functions","text":"Type Name void clearInterval (int id)  void clearTimeout (int id)  void initialize ()  int setInterval (std::function&lt; void()&gt; func, std::chrono::milliseconds millis)  int setTimeout (std::function&lt; void()&gt; func, std::chrono::milliseconds millis)  ~TimersFeature ()"},{"location":"doxygen/classjac_1_1TimersFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1TimersFeature/#function-clearinterval","title":"function clearInterval","text":"<pre><code>inline void jac::TimersFeature::clearInterval (\n    int id\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature/#function-cleartimeout","title":"function clearTimeout","text":"<pre><code>inline void jac::TimersFeature::clearTimeout (\n    int id\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature/#function-initialize","title":"function initialize","text":"<pre><code>inline void jac::TimersFeature::initialize () \n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature/#function-setinterval","title":"function setInterval","text":"<pre><code>inline int jac::TimersFeature::setInterval (\n    std::function&lt; void()&gt; func,\n    std::chrono::milliseconds millis\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature/#function-settimeout","title":"function setTimeout","text":"<pre><code>inline int jac::TimersFeature::setTimeout (\n    std::function&lt; void()&gt; func,\n    std::chrono::milliseconds millis\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature/#function-timersfeature","title":"function ~TimersFeature","text":"<pre><code>inline jac::TimersFeature::~TimersFeature () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/timersFeature.h</code></p>"},{"location":"doxygen/classjac_1_1ValueWrapper/","title":"Class jac::ValueWrapper","text":"<p>template &lt;bool managed&gt;</p> <p>ClassList &gt; jac &gt; ValueWrapper</p> <p>A wrapper around JSValue with RAII. More...</p> <ul> <li><code>#include &lt;values.h&gt;</code></li> </ul> <p>Inherited by the following classes: jac::ExceptionWrapper,  jac::ObjectWrapper</p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#public-functions","title":"Public Functions","text":"Type Name ValueWrapper (ContextRef ctx, JSValue val) Wrap an existing JSValue. If managed is true, JSValue will be freed when the Value is destroyed. ValueWrapper (const ValueWrapper &amp; other)  ValueWrapper (ValueWrapper &amp;&amp; other)  JSValue &amp; getVal () Get reference to the underlying JSValue. bool isArray () Check if the Value is an array. bool isFunction () Check if the Value is a function. bool isNull () Check if the Value is null. bool isObject () Check if the Value is an object. bool isUndefined () Check if the Value is undefined. std::pair&lt; ContextRef, JSValue &gt; loot () Release ownership of the JSValue. The JSValue will have to be freed manually. operator ValueWeak ()  ValueWrapper &amp; operator= (const ValueWrapper &amp; other)  ValueWrapper &amp; operator= (ValueWrapper &amp;&amp; other)  Value stringify (int indent=0) Convert the Value to a JSON representation. T to () Convert the Value to a specified type. StringView toString () Convert the Value to a StringView . ~ValueWrapper ()"},{"location":"doxygen/classjac_1_1ValueWrapper/#public-static-functions","title":"Public Static Functions","text":"Type Name Value from (ContextRef ctx, T val) Create a new Value by converting a given value. Value fromJSON (ContextRef ctx, std::string json, std::string filename=\"&lt;json&gt;\", bool extended=false) Create a new Value from a given JSON string. Value null (ContextRef ctx) Create a new Value containing null. Value undefined (ContextRef ctx) Create a new Value containing undefined."},{"location":"doxygen/classjac_1_1ValueWrapper/#protected-attributes","title":"Protected Attributes","text":"Type Name ContextRef _ctx JSValue _val"},{"location":"doxygen/classjac_1_1ValueWrapper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>managed</code> whether the JSValue should be freed when the wrapper is destroyed. </li> </ul>"},{"location":"doxygen/classjac_1_1ValueWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ValueWrapper/#function-valuewrapper-13","title":"function ValueWrapper [1/3]","text":"<p>Wrap an existing JSValue. If managed is true, JSValue will be freed when the Value is destroyed. <pre><code>jac::ValueWrapper::ValueWrapper (\n    ContextRef ctx,\n    JSValue val\n) \n</code></pre></p> <p>Note:</p> <p>Used internally when directly working with QuickJS API. New Value should be created using Value::from&lt;T&gt;(), Value::undefined(), etc.</p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>val</code> JSValue to wrap </li> </ul>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-valuewrapper-23","title":"function ValueWrapper [2/3]","text":"<pre><code>inline jac::ValueWrapper::ValueWrapper (\n    const ValueWrapper &amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-valuewrapper-33","title":"function ValueWrapper [3/3]","text":"<pre><code>inline jac::ValueWrapper::ValueWrapper (\n    ValueWrapper &amp;&amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-getval","title":"function getVal","text":"<p>Get reference to the underlying JSValue. <pre><code>inline JSValue &amp; jac::ValueWrapper::getVal () \n</code></pre></p> <p>Returns:</p> <p>JSValue reference </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-isarray","title":"function isArray","text":"<p>Check if the Value is an array. <pre><code>inline bool jac::ValueWrapper::isArray () \n</code></pre></p> <p>Returns:</p> <p>true if the Value is an array, false otherwise </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-isfunction","title":"function isFunction","text":"<p>Check if the Value is a function. <pre><code>inline bool jac::ValueWrapper::isFunction () \n</code></pre></p> <p>Returns:</p> <p>true if the Value is a function, false otherwise </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-isnull","title":"function isNull","text":"<p>Check if the Value is null. <pre><code>inline bool jac::ValueWrapper::isNull () \n</code></pre></p> <p>Returns:</p> <p>true if the Value is null, false otherwise </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-isobject","title":"function isObject","text":"<p>Check if the Value is an object. <pre><code>inline bool jac::ValueWrapper::isObject () \n</code></pre></p> <p>Returns:</p> <p>true if the Value is an object, false otherwise </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-isundefined","title":"function isUndefined","text":"<p>Check if the Value is undefined. <pre><code>inline bool jac::ValueWrapper::isUndefined () \n</code></pre></p> <p>Returns:</p> <p>true if the Value is undefined, false otherwise </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-loot","title":"function loot","text":"<p>Release ownership of the JSValue. The JSValue will have to be freed manually. <pre><code>inline std::pair&lt; ContextRef , JSValue &gt; jac::ValueWrapper::loot () \n</code></pre></p> <p>Note:</p> <p>After this call, the Value is in an undefined state.</p> <p>Returns:</p> <p>Pair of ContextRef and JSValue </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-operator-valueweak","title":"function operator ValueWeak","text":"<pre><code>inline jac::ValueWrapper::operator ValueWeak () \n</code></pre>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-operator","title":"function operator=","text":"<pre><code>inline ValueWrapper &amp; jac::ValueWrapper::operator= (\n    const ValueWrapper &amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-operator_1","title":"function operator=","text":"<pre><code>inline ValueWrapper &amp; jac::ValueWrapper::operator= (\n    ValueWrapper &amp;&amp; other\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-stringify","title":"function stringify","text":"<p>Convert the Value to a JSON representation. <pre><code>inline Value jac::ValueWrapper::stringify (\n    int indent=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>indent</code> indentation level </li> </ul> <p>Returns:</p> <p>Value containing the JSON representation </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-to","title":"function to","text":"<p>Convert the Value to a specified type. <pre><code>template&lt;typename T&gt;\ninline T jac::ValueWrapper::to () \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> Type to convert to </li> </ul> <p>Returns:</p> <p>The converted value </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-tostring","title":"function toString","text":"<p>Convert the Value to a StringView . <pre><code>inline StringView jac::ValueWrapper::toString () \n</code></pre></p> <p>Returns:</p> <p>The StringView </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-valuewrapper","title":"function ~ValueWrapper","text":"<pre><code>inline jac::ValueWrapper::~ValueWrapper () \n</code></pre>"},{"location":"doxygen/classjac_1_1ValueWrapper/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classjac_1_1ValueWrapper/#function-from","title":"function from","text":"<p>Create a new Value by converting a given value. <pre><code>template&lt;typename T&gt;\nstatic inline Value jac::ValueWrapper::from (\n    ContextRef ctx,\n    T val\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> Type of the value </li> </ul> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>val</code> value to convert </li> </ul> <p>Returns:</p> <p>The resulting Value </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-fromjson","title":"function fromJSON","text":"<p>Create a new Value from a given JSON string. <pre><code>static inline Value jac::ValueWrapper::fromJSON (\n    ContextRef ctx,\n    std::string json,\n    std::string filename=\"&lt;json&gt;\",\n    bool extended=false\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> <li><code>json</code> JSON string </li> <li><code>filename</code> filename to use as the source of the JSON </li> <li><code>extended</code> whether to use extended JSON </li> </ul> <p>Returns:</p> <p>The resulting Value </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-null","title":"function null","text":"<p>Create a new Value containing null. <pre><code>static inline Value jac::ValueWrapper::null (\n    ContextRef ctx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> </ul> <p>Returns:</p> <p>The resulting Value </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#function-undefined","title":"function undefined","text":"<p>Create a new Value containing undefined. <pre><code>static inline Value jac::ValueWrapper::undefined (\n    ContextRef ctx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> context to work in </li> </ul> <p>Returns:</p> <p>The resulting Value </p>"},{"location":"doxygen/classjac_1_1ValueWrapper/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"doxygen/classjac_1_1ValueWrapper/#variable-_ctx","title":"variable _ctx","text":"<pre><code>ContextRef jac::ValueWrapper&lt; managed &gt;::_ctx;\n</code></pre>"},{"location":"doxygen/classjac_1_1ValueWrapper/#variable-_val","title":"variable _val","text":"<pre><code>JSValue jac::ValueWrapper&lt; managed &gt;::_val;\n</code></pre>"},{"location":"doxygen/classjac_1_1ValueWrapper/#friends-documentation","title":"Friends Documentation","text":""},{"location":"doxygen/classjac_1_1ValueWrapper/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; jac::ValueWrapper::operator&lt;&lt; (\n    std::ostream &amp; os,\n    ValueWrapper &amp; val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/values.h</code></p>"},{"location":"doxygen/classjac_1_1Writable/","title":"Class jac::Writable","text":"<p>ClassList &gt; jac &gt; Writable</p> <p>Inherited by the following classes: jac::OsWritable,  jac::WritableRef</p>"},{"location":"doxygen/classjac_1_1Writable/#public-functions","title":"Public Functions","text":"Type Name virtual void write (std::string data) = 0 virtual ~Writable () = default"},{"location":"doxygen/classjac_1_1Writable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Writable/#function-write","title":"function write","text":"<pre><code>virtual void jac::Writable::write (\n    std::string data\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1Writable/#function-writable","title":"function ~Writable","text":"<pre><code>virtual jac::Writable::~Writable () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/types/streams.h</code></p>"},{"location":"doxygen/structjac_1_1WritableProtoBuilder/","title":"Struct jac::WritableProtoBuilder","text":"<p>ClassList &gt; jac &gt; WritableProtoBuilder</p> <p>Inherits the following classes: jac::ProtoBuilder::Opaque,  jac::ProtoBuilder::Properties</p>"},{"location":"doxygen/structjac_1_1WritableProtoBuilder/#public-types-inherited-from-jacprotobuilderopaque","title":"Public Types inherited from jac::ProtoBuilder::Opaque","text":"<p>See jac::ProtoBuilder::Opaque</p> Type Name typedef T OpaqueType"},{"location":"doxygen/structjac_1_1WritableProtoBuilder/#public-static-attributes-inherited-from-jacprotobuilderopaque","title":"Public Static Attributes inherited from jac::ProtoBuilder::Opaque","text":"<p>See jac::ProtoBuilder::Opaque</p> Type Name JSClassID classId"},{"location":"doxygen/structjac_1_1WritableProtoBuilder/#public-static-functions","title":"Public Static Functions","text":"Type Name void addProperties (ContextRef ctx, Object proto)"},{"location":"doxygen/structjac_1_1WritableProtoBuilder/#public-static-functions-inherited-from-jacprotobuilderopaque","title":"Public Static Functions inherited from jac::ProtoBuilder::Opaque","text":"<p>See jac::ProtoBuilder::Opaque</p> Type Name void addMethodMember (ContextRef ctx, Object proto, std::string name, PropFlags flags=PropFlags::Default) Add a property to the object prototype from a member function of the wrapped class. void addPropMember (ContextRef ctx, Object proto, std::string name, PropFlags flags=PropFlags::Default) Add a property to the object prototype from a member variable of the wrapped class. Value callMember (ContextRef ctx, ValueWeak funcObj, ValueWeak thisVal, std::vector&lt; ValueWeak &gt; argv) Process a call to a member function of the wrapped class. T * constructOpaque (ContextRef, std::vector&lt; ValueWeak &gt;) Construct a new Opaque object from javascript arguments. void destroyOpaque (JSRuntime *, T * ptr) noexceptDestroy the Opaque object. T * getOpaque (ContextRef, ValueWeak thisVal) Get the Opaque object from an instance of the class."},{"location":"doxygen/structjac_1_1WritableProtoBuilder/#public-static-functions-inherited-from-jacprotobuilderproperties","title":"Public Static Functions inherited from jac::ProtoBuilder::Properties","text":"<p>See jac::ProtoBuilder::Properties</p> Type Name void addProperties (ContextRef ctx, Object proto) Add properties to the object prototype."},{"location":"doxygen/structjac_1_1WritableProtoBuilder/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1WritableProtoBuilder/#function-addproperties","title":"function addProperties","text":"<pre><code>static inline void jac::WritableProtoBuilder::addProperties (\n    ContextRef ctx,\n    Object proto\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/basicStreamFeature.h</code></p>"},{"location":"doxygen/classjac_1_1WritableRef/","title":"Class jac::WritableRef","text":"<p>ClassList &gt; jac &gt; WritableRef</p> <p>Inherits the following classes: jac::Writable</p>"},{"location":"doxygen/classjac_1_1WritableRef/#public-functions","title":"Public Functions","text":"Type Name WritableRef (Writable * ptr)  virtual void write (std::string data) override"},{"location":"doxygen/classjac_1_1WritableRef/#public-functions-inherited-from-jacwritable","title":"Public Functions inherited from jac::Writable","text":"<p>See jac::Writable</p> Type Name virtual void write (std::string data) = 0 virtual ~Writable () = default"},{"location":"doxygen/classjac_1_1WritableRef/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1WritableRef/#function-writableref","title":"function WritableRef","text":"<pre><code>inline jac::WritableRef::WritableRef (\n    Writable * ptr\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1WritableRef/#function-write","title":"function write","text":"<pre><code>inline virtual void jac::WritableRef::write (\n    std::string data\n) override\n</code></pre> <p>Implements jac::Writable::write</p> <p>The documentation for this class was generated from the following file <code>src/jac/features/types/streams.h</code></p>"},{"location":"doxygen/namespacejac_1_1detail/","title":"Namespace jac::detail","text":"<p>Namespace List &gt; jac &gt; detail</p>"},{"location":"doxygen/namespacejac_1_1detail/#classes","title":"Classes","text":"Type Name struct is_base_of_template_impl &lt;Base, typename Derived&gt;"},{"location":"doxygen/namespacejac_1_1detail/#public-attributes","title":"Public Attributes","text":"Type Name constexpr bool is_leq_i32   = <code>/* multi line expression */</code>"},{"location":"doxygen/namespacejac_1_1detail/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/namespacejac_1_1detail/#variable-is_leq_i32","title":"variable is_leq_i32","text":"<pre><code>constexpr bool jac::detail::is_leq_i32;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl/","title":"Struct jac::detail::is_base_of_template_impl","text":"<p>template &lt;template&lt; typename... &gt; class Base, typename Derived&gt;</p> <p>ClassList &gt; jac &gt; detail &gt; is_base_of_template_impl</p>"},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl/#classes","title":"Classes","text":"Type Name struct check &lt;A, class Void&gt; struct check&lt; A, std::void_t&lt; A&lt; Derived &gt; &gt; &gt; &lt;A&gt;"},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl/#public-types","title":"Public Types","text":"Type Name typedef decltype(is_callable(std::declval&lt; T * &gt;())) is_callable_t typedef check&lt; is_callable_t &gt; value_t"},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr void is_callable (Base&lt; Ts... &gt; *)"},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl/#typedef-is_callable_t","title":"typedef is_callable_t","text":"<pre><code>using jac::detail::is_base_of_template_impl&lt; Base, Derived &gt;::is_callable_t =  decltype(is_callable(std::declval&lt;T*&gt;()));\n</code></pre>"},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl/#typedef-value_t","title":"typedef value_t","text":"<pre><code>using jac::detail::is_base_of_template_impl&lt; Base, Derived &gt;::value_t =  check&lt;is_callable_t&gt;;\n</code></pre>"},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl/#function-is_callable","title":"function is_callable","text":"<pre><code>template&lt;typename... Ts&gt;\nstatic constexpr void jac::detail::is_base_of_template_impl::is_callable (\n    Base&lt; Ts... &gt; *\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl_1_1check/","title":"Struct jac::detail::is_base_of_template_impl::check","text":"<p>template &lt;template&lt; class... &gt; class A, class Void&gt;</p> <p>ClassList &gt; jac &gt; detail &gt; is_base_of_template_impl &gt; check</p> <p>Inherits the following classes: std::false_type</p> <p>Inherited by the following classes: jac::is_base_of_template</p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/structjac_1_1detail_1_1is__base__of__template__impl_1_1check_3_01A_00_01std_1_1void__t_3_01A_3_01Derived_01_4_01_4_01_4/","title":"Struct jac::detail::is_base_of_template_impl::check&lt; A, std::void_t&lt; A&lt; Derived &gt; &gt; &gt;","text":"<p>template &lt;template&lt; class... &gt; class A&gt;</p> <p>ClassList &gt; jac &gt; detail &gt; is_base_of_template_impl &gt; check&lt; A, std::void_t&lt; A&lt; Derived &gt; &gt; &gt;</p> <p>Inherits the following classes: std::true_type</p> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/structjac_1_1is__base__of__template/","title":"Struct jac::is_base_of_template","text":"<p>template &lt;template&lt; typename... &gt; class Base, typename Derived&gt;</p> <p>ClassList &gt; jac &gt; is_base_of_template</p> <p>Checks if a type is derived from a template class. More...</p> <ul> <li><code>#include &lt;class.h&gt;</code></li> </ul> <p>Inherits the following classes: jac::detail::is_base_of_template_impl::check</p>"},{"location":"doxygen/structjac_1_1is__base__of__template/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Base</code> The base template class </li> <li><code>Derived</code> The tested type </li> </ul> <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/","title":"Class jac::FilesystemFeature::Fs","text":"<p>ClassList &gt; Fs</p>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#public-functions","title":"Public Functions","text":"Type Name Fs (FilesystemFeature &amp; feature)  bool exists (std::string path_)  bool isDirectory (std::string path_)  bool isFile (std::string path_)  std::string loadCode (std::string filename)  void mkdir (std::string path_)  File open (std::string path_, std::string flags)  std::vector&lt; std::string &gt; readdir (std::string path_)  void rm (std::string path_)  void rmdir (std::string path_)"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#function-fs","title":"function Fs","text":"<pre><code>inline Fs::Fs (\n    FilesystemFeature &amp; feature\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#function-exists","title":"function exists","text":"<pre><code>inline bool Fs::exists (\n    std::string path_\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#function-isdirectory","title":"function isDirectory","text":"<pre><code>inline bool Fs::isDirectory (\n    std::string path_\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#function-isfile","title":"function isFile","text":"<pre><code>inline bool Fs::isFile (\n    std::string path_\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#function-loadcode","title":"function loadCode","text":"<pre><code>inline std::string Fs::loadCode (\n    std::string filename\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#function-mkdir","title":"function mkdir","text":"<pre><code>inline void Fs::mkdir (\n    std::string path_\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#function-open","title":"function open","text":"<pre><code>inline File Fs::open (\n    std::string path_,\n    std::string flags\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#function-readdir","title":"function readdir","text":"<pre><code>inline std::vector&lt; std::string &gt; Fs::readdir (\n    std::string path_\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#function-rm","title":"function rm","text":"<pre><code>inline void Fs::rm (\n    std::string path_\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1FilesystemFeature_1_1Fs/#function-rmdir","title":"function rmdir","text":"<pre><code>inline void Fs::rmdir (\n    std::string path_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/filesystemFeature.h</code></p>"},{"location":"doxygen/classjac_1_1StdioFeature_1_1Stdio/","title":"Class jac::StdioFeature::Stdio","text":"<p>ClassList &gt; Stdio</p>"},{"location":"doxygen/classjac_1_1StdioFeature_1_1Stdio/#public-attributes","title":"Public Attributes","text":"Type Name std::unique_ptr&lt; Writable &gt; err std::unique_ptr&lt; Readable &gt; in std::unique_ptr&lt; Writable &gt; out"},{"location":"doxygen/classjac_1_1StdioFeature_1_1Stdio/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/classjac_1_1StdioFeature_1_1Stdio/#variable-err","title":"variable err","text":"<pre><code>std::unique_ptr&lt;Writable&gt; jac::StdioFeature&lt; Next &gt;::Stdio::err;\n</code></pre>"},{"location":"doxygen/classjac_1_1StdioFeature_1_1Stdio/#variable-in","title":"variable in","text":"<pre><code>std::unique_ptr&lt;Readable&gt; jac::StdioFeature&lt; Next &gt;::Stdio::in;\n</code></pre>"},{"location":"doxygen/classjac_1_1StdioFeature_1_1Stdio/#variable-out","title":"variable out","text":"<pre><code>std::unique_ptr&lt;Writable&gt; jac::StdioFeature&lt; Next &gt;::Stdio::out;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/stdioFeature.h</code></p>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1CompareTimer/","title":"Class jac::TimersFeature::CompareTimer","text":"<p>ClassList &gt; CompareTimer</p>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1CompareTimer/#public-functions","title":"Public Functions","text":"Type Name bool operator() (const std::shared_ptr&lt; Timer &gt; &amp; a, const std::shared_ptr&lt; Timer &gt; &amp; b) const"},{"location":"doxygen/classjac_1_1TimersFeature_1_1CompareTimer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1TimersFeature_1_1CompareTimer/#function-operator","title":"function operator()","text":"<pre><code>inline bool CompareTimer::operator() (\n    const std::shared_ptr&lt; Timer &gt; &amp; a,\n    const std::shared_ptr&lt; Timer &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/timersFeature.h</code></p>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/","title":"Class jac::TimersFeature::Timer","text":"<p>ClassList &gt; Timer</p>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#public-functions","title":"Public Functions","text":"Type Name Timer (std::function&lt; void()&gt; callback, std::chrono::milliseconds duration, int id, bool isRepeating=false)  void cancel ()  std::function&lt; void()&gt; getCallback ()  std::chrono::time_point&lt; std::chrono::steady_clock &gt; getEndTime () const int getId () const bool isCancelled () const bool isRepeating () const bool operator&lt; (const Timer &amp; other) const void update ()"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#function-timer","title":"function Timer","text":"<pre><code>inline Timer::Timer (\n    std::function&lt; void()&gt; callback,\n    std::chrono::milliseconds duration,\n    int id,\n    bool isRepeating=false\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#function-cancel","title":"function cancel","text":"<pre><code>inline void Timer::cancel () \n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#function-getcallback","title":"function getCallback","text":"<pre><code>inline std::function&lt; void()&gt; Timer::getCallback () \n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#function-getendtime","title":"function getEndTime","text":"<pre><code>inline std::chrono::time_point&lt; std::chrono::steady_clock &gt; Timer::getEndTime () const\n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#function-getid","title":"function getId","text":"<pre><code>inline int Timer::getId () const\n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#function-iscancelled","title":"function isCancelled","text":"<pre><code>inline bool Timer::isCancelled () const\n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#function-isrepeating","title":"function isRepeating","text":"<pre><code>inline bool Timer::isRepeating () const\n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#function-operator","title":"function operator&lt;","text":"<pre><code>inline bool Timer::operator&lt; (\n    const Timer &amp; other\n) const\n</code></pre>"},{"location":"doxygen/classjac_1_1TimersFeature_1_1Timer/#function-update","title":"function update","text":"<pre><code>inline void Timer::update () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/timersFeature.h</code></p>"},{"location":"doxygen/namespacenoal/","title":"Namespace noal","text":"<p>Namespace List &gt; noal</p>"},{"location":"doxygen/namespacenoal/#classes","title":"Classes","text":"Type Name class callableany &lt;typename Func, typename Sign&gt; class callableany&lt; Func, Res(Args...)&gt; &lt;typename Func, typename Res, Args&gt; class funcptr &lt;typename Res, Args&gt; class function &lt;typename Sign, dataSize&gt; class function&lt; Res(Args...), dataSize &gt; &lt;typename Res, Args, dataSize&gt; class memberconstfuncptr &lt;class Class, typename Res, Args&gt; class memberfuncptr &lt;class Class, typename Res, Args&gt; struct signatureHelper &lt;typename Func&gt; struct signatureHelper&lt; Res(Func::*)(Args...) &amp; &gt; &lt;typename Func, typename Res, Args&gt; struct signatureHelper&lt; Res(Func::*)(Args...) const &amp; &gt; &lt;typename Func, typename Res, Args&gt; struct signatureHelper&lt; Res(Func::*)(Args...) const &gt; &lt;typename Func, typename Res, Args&gt; struct signatureHelper&lt; Res(Func::*)(Args...)&gt; &lt;typename Func, typename Res, Args&gt;"},{"location":"doxygen/namespacenoal/#public-functions","title":"Public Functions","text":"Type Name callableany (Func)  function (Res(*)(Args...))  function (Res(Class::*)(Args...), Class *)  function (Func)  Res invoker (void * func, Args... args)"},{"location":"doxygen/namespacenoal/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/namespacenoal/#function-callableany","title":"function callableany","text":"<pre><code>template&lt;typename Func, typename Sign&gt;\nnoal::callableany (\n    Func\n) \n</code></pre>"},{"location":"doxygen/namespacenoal/#function-function","title":"function function","text":"<pre><code>template&lt;typename Res, typename... Args&gt;\nnoal::function (\n    Res(*)(Args...)\n) \n</code></pre>"},{"location":"doxygen/namespacenoal/#function-function_1","title":"function function","text":"<pre><code>template&lt;class Class, typename Res, typename... Args&gt;\nnoal::function (\n    Res(Class::*)(Args...),\n    Class *\n) \n</code></pre>"},{"location":"doxygen/namespacenoal/#function-function_2","title":"function function","text":"<pre><code>template&lt;typename Func, typename Sign&gt;\nnoal::function (\n    Func\n) \n</code></pre>"},{"location":"doxygen/namespacenoal/#function-invoker","title":"function invoker","text":"<pre><code>template&lt;typename Res, typename... Args&gt;\nRes noal::invoker (\n    void * func,\n    Args... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/classnoal_1_1callableany/","title":"Class noal::callableany","text":"<p>template &lt;typename Func, typename Sign&gt;</p> <p>ClassList &gt; noal &gt; callableany</p> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/classnoal_1_1callableany_3_01Func_00_01Res_07Args_8_8_8_08_4/","title":"Class noal::callableany&lt; Func, Res(Args...)&gt;","text":"<p>template &lt;typename Func, typename Res, typename... Args&gt;</p> <p>ClassList &gt; noal &gt; callableany&lt; Func, Res(Args...)&gt;</p>"},{"location":"doxygen/classnoal_1_1callableany_3_01Func_00_01Res_07Args_8_8_8_08_4/#public-functions","title":"Public Functions","text":"Type Name callableany (Func _func)  Res operator() (Args... args)"},{"location":"doxygen/classnoal_1_1callableany_3_01Func_00_01Res_07Args_8_8_8_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Res call (void * self, Args... args)"},{"location":"doxygen/classnoal_1_1callableany_3_01Func_00_01Res_07Args_8_8_8_08_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classnoal_1_1callableany_3_01Func_00_01Res_07Args_8_8_8_08_4/#function-callableany","title":"function callableany","text":"<pre><code>inline noal::callableany&lt; Func, Res(Args...)&gt;::callableany (\n    Func _func\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1callableany_3_01Func_00_01Res_07Args_8_8_8_08_4/#function-operator","title":"function operator()","text":"<pre><code>inline Res noal::callableany&lt; Func, Res(Args...)&gt;::operator() (\n    Args... args\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1callableany_3_01Func_00_01Res_07Args_8_8_8_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classnoal_1_1callableany_3_01Func_00_01Res_07Args_8_8_8_08_4/#function-call","title":"function call","text":"<pre><code>static inline Res noal::callableany&lt; Func, Res(Args...)&gt;::call (\n    void * self,\n    Args... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/classnoal_1_1funcptr/","title":"Class noal::funcptr","text":"<p>template &lt;typename Res, typename... Args&gt;</p> <p>ClassList &gt; noal &gt; funcptr</p>"},{"location":"doxygen/classnoal_1_1funcptr/#public-functions","title":"Public Functions","text":"Type Name funcptr (Res(*)(Args...) func)  Res operator() (Args... args)"},{"location":"doxygen/classnoal_1_1funcptr/#public-static-functions","title":"Public Static Functions","text":"Type Name Res call (void * self, Args... args)"},{"location":"doxygen/classnoal_1_1funcptr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classnoal_1_1funcptr/#function-funcptr","title":"function funcptr","text":"<pre><code>inline noal::funcptr::funcptr (\n    Res(*)(Args...) func\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1funcptr/#function-operator","title":"function operator()","text":"<pre><code>inline Res noal::funcptr::operator() (\n    Args... args\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1funcptr/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classnoal_1_1funcptr/#function-call","title":"function call","text":"<pre><code>static inline Res noal::funcptr::call (\n    void * self,\n    Args... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/classnoal_1_1function/","title":"Class noal::function","text":"<p>template &lt;typename Sign, size_t dataSize&gt;</p> <p>ClassList &gt; noal &gt; function</p> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/","title":"Class noal::function&lt; Res(Args...), dataSize &gt;","text":"<p>template &lt;typename Res, typename... Args, size_t dataSize&gt;</p> <p>ClassList &gt; noal &gt; function&lt; Res(Args...), dataSize &gt;</p>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#public-functions","title":"Public Functions","text":"Type Name function () = default function (const function&lt; Sign, otherSize &gt; &amp; other)  function (function&lt; Sign, otherSize &gt; &amp;&amp; other)  function (Res(*)(Args...) func)  function (Res(Class::*)(Args...) func, Class * self)  function (Res(Class::*)(Args...) const func, Class * self)  function (Func func)  operator bool () const Res operator() (Args... args)  function &amp; operator= (const function&lt; Sign, otherSize &gt; &amp; other)  function &amp; operator= (function&lt; Sign, otherSize &gt; &amp;&amp; other)  function &amp; operator= (Res(*)(Args...) func)  function &amp; operator= (Func func)"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-function-17","title":"function function [1/7]","text":"<pre><code>noal::function&lt; Res(Args...), dataSize &gt;::function () = default\n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-function-27","title":"function function [2/7]","text":"<pre><code>template&lt;size_t otherSize&gt;\ninline noal::function&lt; Res(Args...), dataSize &gt;::function (\n    const function &lt; Sign, otherSize &gt; &amp; other\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-function-37","title":"function function [3/7]","text":"<pre><code>template&lt;size_t otherSize&gt;\ninline noal::function&lt; Res(Args...), dataSize &gt;::function (\n    function &lt; Sign, otherSize &gt; &amp;&amp; other\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-function-47","title":"function function [4/7]","text":"<pre><code>inline explicit noal::function&lt; Res(Args...), dataSize &gt;::function (\n    Res(*)(Args...) func\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-function-57","title":"function function [5/7]","text":"<pre><code>template&lt;class Class&gt;\ninline noal::function&lt; Res(Args...), dataSize &gt;::function (\n    Res(Class::*)(Args...) func,\n    Class * self\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-function-67","title":"function function [6/7]","text":"<pre><code>template&lt;class Class&gt;\ninline noal::function&lt; Res(Args...), dataSize &gt;::function (\n    Res(Class::*)(Args...) const func,\n    Class * self\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-function-77","title":"function function [7/7]","text":"<pre><code>template&lt;typename Func, typename Sign&gt;\ninline explicit noal::function&lt; Res(Args...), dataSize &gt;::function (\n    Func func\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit noal::function&lt; Res(Args...), dataSize &gt;::operator bool () const\n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline Res noal::function&lt; Res(Args...), dataSize &gt;::operator() (\n    Args... args\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-operator_1","title":"function operator=","text":"<pre><code>template&lt;size_t otherSize&gt;\ninline function &amp; noal::function&lt; Res(Args...), dataSize &gt;::operator= (\n    const function &lt; Sign, otherSize &gt; &amp; other\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-operator_2","title":"function operator=","text":"<pre><code>template&lt;size_t otherSize&gt;\ninline function &amp; noal::function&lt; Res(Args...), dataSize &gt;::operator= (\n    function &lt; Sign, otherSize &gt; &amp;&amp; other\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-operator_3","title":"function operator=","text":"<pre><code>inline function &amp; noal::function&lt; Res(Args...), dataSize &gt;::operator= (\n    Res(*)(Args...) func\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1function_3_01Res_07Args_8_8_8_08_00_01dataSize_01_4/#function-operator_4","title":"function operator=","text":"<pre><code>template&lt;typename Func, typename Sign&gt;\ninline function &amp; noal::function&lt; Res(Args...), dataSize &gt;::operator= (\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/classnoal_1_1memberconstfuncptr/","title":"Class noal::memberconstfuncptr","text":"<p>template &lt;class Class, typename Res, typename... Args&gt;</p> <p>ClassList &gt; noal &gt; memberconstfuncptr</p>"},{"location":"doxygen/classnoal_1_1memberconstfuncptr/#public-functions","title":"Public Functions","text":"Type Name memberconstfuncptr (Res(Class::*)(Args...) const func, Class * self)  Res operator() (Args... args)"},{"location":"doxygen/classnoal_1_1memberconstfuncptr/#public-static-functions","title":"Public Static Functions","text":"Type Name Res call (void * self, Args... args)"},{"location":"doxygen/classnoal_1_1memberconstfuncptr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classnoal_1_1memberconstfuncptr/#function-memberconstfuncptr","title":"function memberconstfuncptr","text":"<pre><code>inline noal::memberconstfuncptr::memberconstfuncptr (\n    Res(Class::*)(Args...) const func,\n    Class * self\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1memberconstfuncptr/#function-operator","title":"function operator()","text":"<pre><code>inline Res noal::memberconstfuncptr::operator() (\n    Args... args\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1memberconstfuncptr/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classnoal_1_1memberconstfuncptr/#function-call","title":"function call","text":"<pre><code>static inline Res noal::memberconstfuncptr::call (\n    void * self,\n    Args... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/classnoal_1_1memberfuncptr/","title":"Class noal::memberfuncptr","text":"<p>template &lt;class Class, typename Res, typename... Args&gt;</p> <p>ClassList &gt; noal &gt; memberfuncptr</p>"},{"location":"doxygen/classnoal_1_1memberfuncptr/#public-functions","title":"Public Functions","text":"Type Name memberfuncptr (Res(Class::*)(Args...) func, Class * self)  Res operator() (Args... args)"},{"location":"doxygen/classnoal_1_1memberfuncptr/#public-static-functions","title":"Public Static Functions","text":"Type Name Res call (void * self, Args... args)"},{"location":"doxygen/classnoal_1_1memberfuncptr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classnoal_1_1memberfuncptr/#function-memberfuncptr","title":"function memberfuncptr","text":"<pre><code>inline noal::memberfuncptr::memberfuncptr (\n    Res(Class::*)(Args...) func,\n    Class * self\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1memberfuncptr/#function-operator","title":"function operator()","text":"<pre><code>inline Res noal::memberfuncptr::operator() (\n    Args... args\n) \n</code></pre>"},{"location":"doxygen/classnoal_1_1memberfuncptr/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/classnoal_1_1memberfuncptr/#function-call","title":"function call","text":"<pre><code>static inline Res noal::memberfuncptr::call (\n    void * self,\n    Args... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/structnoal_1_1signatureHelper/","title":"Struct noal::signatureHelper","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; noal &gt; signatureHelper</p> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01_6_01_4/","title":"Struct noal::signatureHelper&lt; Res(Func::*)(Args...) &amp; &gt;","text":"<p>template &lt;typename Func, typename Res, typename... Args&gt;</p> <p>ClassList &gt; noal &gt; signatureHelper&lt; Res(Func::*)(Args...) &amp; &gt;</p>"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01_6_01_4/#public-types","title":"Public Types","text":"Type Name typedef Res(Args...) type"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01_6_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01_6_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using noal::signatureHelper&lt; Res(Func::*)(Args...) &amp; &gt;::type =  Res(Args...);\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01const_01_6_01_4/","title":"Struct noal::signatureHelper&lt; Res(Func::*)(Args...) const &amp; &gt;","text":"<p>template &lt;typename Func, typename Res, typename... Args&gt;</p> <p>ClassList &gt; noal &gt; signatureHelper&lt; Res(Func::*)(Args...) const &amp; &gt;</p>"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01const_01_6_01_4/#public-types","title":"Public Types","text":"Type Name typedef Res(Args...) type"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01const_01_6_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01const_01_6_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using noal::signatureHelper&lt; Res(Func::*)(Args...) const &amp; &gt;::type =  Res(Args...);\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01const_01_4/","title":"Struct noal::signatureHelper&lt; Res(Func::*)(Args...) const &gt;","text":"<p>template &lt;typename Func, typename Res, typename... Args&gt;</p> <p>ClassList &gt; noal &gt; signatureHelper&lt; Res(Func::*)(Args...) const &gt;</p>"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01const_01_4/#public-types","title":"Public Types","text":"Type Name typedef Res(Args...) type"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01const_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_01const_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using noal::signatureHelper&lt; Res(Func::*)(Args...) const &gt;::type =  Res(Args...);\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_4/","title":"Struct noal::signatureHelper&lt; Res(Func::*)(Args...)&gt;","text":"<p>template &lt;typename Func, typename Res, typename... Args&gt;</p> <p>ClassList &gt; noal &gt; signatureHelper&lt; Res(Func::*)(Args...)&gt;</p>"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_4/#public-types","title":"Public Types","text":"Type Name typedef Res(Args...) type"},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/structnoal_1_1signatureHelper_3_01Res_07Func_1_1_5_08_07Args_8_8_8_08_4/#typedef-type","title":"typedef type","text":"<pre><code>using noal::signatureHelper&lt; Res(Func::*)(Args...)&gt;::type =  Res(Args...);\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"doxygen/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"doxygen/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file noal_func.h"},{"location":"doxygen/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","title":"Directories","text":"Type Name dir jac <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"doxygen/noal__func_8h/","title":"File noal_func.h","text":"<p>FileList &gt; src &gt; noal_func.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"doxygen/noal__func_8h/#namespaces","title":"Namespaces","text":"Type Name namespace noal"},{"location":"doxygen/noal__func_8h/#classes","title":"Classes","text":"Type Name class callableany&lt; Func, Res(Args...)&gt; &lt;typename Func, typename Res, Args&gt; class funcptr &lt;typename Res, Args&gt; class function&lt; Res(Args...), dataSize &gt; &lt;typename Res, Args, dataSize&gt; class memberconstfuncptr &lt;class Class, typename Res, Args&gt; class memberfuncptr &lt;class Class, typename Res, Args&gt; struct signatureHelper&lt; Res(Func::*)(Args...) &amp; &gt; &lt;typename Func, typename Res, Args&gt; struct signatureHelper&lt; Res(Func::*)(Args...) const &amp; &gt; &lt;typename Func, typename Res, Args&gt; struct signatureHelper&lt; Res(Func::*)(Args...) const &gt; &lt;typename Func, typename Res, Args&gt; struct signatureHelper&lt; Res(Func::*)(Args...)&gt; &lt;typename Func, typename Res, Args&gt; <p>The documentation for this class was generated from the following file <code>src/noal_func.h</code></p>"},{"location":"doxygen/noal__func_8h_source/","title":"File noal_func.h","text":"<p>File List &gt; src &gt; noal_func.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;utility&gt;\n\n\nnamespace noal {\n\ntemplate&lt;typename Res, typename... Args&gt;\nclass funcptr {\n    Res (*_func)(Args...);\npublic:\n    funcptr(Res (*func)(Args...)) : _func(func) {}\n    inline Res operator()(Args... args) {\n        return _func(std::forward&lt;Args&gt;(args)...);\n    }\n    static Res call(void* self, Args... args) {\n        return (static_cast&lt;funcptr*&gt;(self))-&gt;operator()(std::forward&lt;Args&gt;(args)...);\n    }\n};\n\ntemplate&lt;typename Res, typename... Args&gt;\nRes invoker(void* func, Args... args) {\n    return (*static_cast&lt;Res(**)(Args...)&gt;(func))(std::forward&lt;Args&gt;(args)...);\n}\n\ntemplate&lt;class Class, typename Res, typename... Args&gt;\nclass memberfuncptr {\n    Res (Class::*_func)(Args...);\n    Class* _self;\npublic:\n    memberfuncptr(Res (Class::*func)(Args...), Class* self) : _func(func), _self(self) {}\n    inline Res operator()(Args... args) {\n        return (_self-&gt;*_func)(std::forward&lt;Args&gt;(args)...);\n    }\n    static Res call(void* self, Args... args) {\n        return static_cast&lt;memberfuncptr*&gt;(self)-&gt;operator()(std::forward&lt;Args&gt;(args)...);\n    }\n};\n\ntemplate&lt;class Class, typename Res, typename... Args&gt;\nclass memberconstfuncptr {\n    Res (Class::*_func)(Args...) const;\n    Class* _self;\npublic:\n    memberconstfuncptr(Res (Class::*func)(Args...) const, Class* self) : _func(func), _self(self) {}\n    inline Res operator()(Args... args) {\n        return _func(std::forward&lt;Args&gt;(args)...);\n    }\n    static Res call(void* self, Args... args) {\n        return static_cast&lt;memberconstfuncptr*&gt;(self)-&gt;operator()(std::forward&lt;Args&gt;(args)...);\n    }\n};\n\ntemplate&lt;typename Func&gt;\nstruct signatureHelper;\n\ntemplate&lt;typename Func, typename Res, typename... Args&gt;\nstruct signatureHelper&lt;Res (Func::*)(Args...)&gt; {\n    using type = Res(Args...);\n};\n\ntemplate&lt;typename Func, typename Res, typename... Args&gt;\nstruct signatureHelper&lt;Res (Func::*)(Args...) &amp;&gt; {\n    using type = Res(Args...);\n};\n\ntemplate&lt;typename Func, typename Res, typename... Args&gt;\nstruct signatureHelper&lt;Res (Func::*)(Args...) const&gt; {\n    using type = Res(Args...);\n};\n\ntemplate&lt;typename Func, typename Res, typename... Args&gt;\nstruct signatureHelper&lt;Res (Func::*)(Args...) const &amp;&gt; {\n    using type = Res(Args...);\n};\n\ntemplate&lt;typename Func, typename Sign&gt;\nclass callableany;\n\ntemplate&lt;typename Func, typename Res, typename... Args&gt;\nclass callableany&lt;Func, Res(Args...)&gt; {\n    Func func;\npublic:\n    callableany(Func _func) : func(_func) {\n        static_assert(std::is_trivially_copyable_v&lt;Func&gt;);\n        static_assert(std::is_trivially_destructible_v&lt;Func&gt;);\n    }\n    inline Res operator()(Args... args) {\n        return func(std::forward&lt;Args&gt;(args)...);\n    }\n    static Res call(void* self, Args... args) {\n        return static_cast&lt;callableany&lt;Func, Res(Args...)&gt;*&gt;(self)-&gt;operator()(std::forward&lt;Args&gt;(args)...);\n    }\n};\ntemplate&lt;typename Func, typename Sign = typename signatureHelper&lt;decltype(&amp;Func::operator())&gt;::type&gt;\ncallableany(Func) -&gt; callableany&lt;Func, Sign&gt;;\n\n\ntemplate&lt;typename Sign, size_t dataSize&gt;\nclass function;\n\ntemplate&lt;typename Res, typename... Args, size_t dataSize&gt;\nclass function&lt;Res(Args...), dataSize&gt; {\n    using Sign = Res(Args...);\n\n    Res (*call)(void*, Args...);\n    uint8_t data[dataSize];\npublic:\n// default/copy/move constructors, copy/move assignment operators\n    function() = default;\n    template&lt;size_t otherSize&gt;\n    function&amp; operator=(const function&lt;Sign, otherSize&gt;&amp; other) {\n        static_assert(otherSize &lt;= dataSize, \"Other function object is too large\");\n        // static_assert(sizeof(other) &lt;= sizeof(*this), \"Other function object is too large\");\n\n        std::copy(static_cast&lt;uint8_t*&gt;(&amp;other), static_cast&lt;uint8_t*&gt;(&amp;other) + sizeof(other), static_cast&lt;uint8_t*&gt;(this));\n        std::fill(static_cast&lt;uint8_t*&gt;(this) + sizeof(other), static_cast&lt;uint8_t*&gt;(this) + sizeof(*this), 0);  // possibly unnecessary - prevent data leaks?\n        return *this;\n    }\n    template&lt;size_t otherSize&gt;\n    function&amp; operator=(function&lt;Sign, otherSize&gt;&amp;&amp; other) { *this = other; }\n    template&lt;size_t otherSize&gt;\n    function(const function&lt;Sign, otherSize&gt;&amp; other) { *this = other; }\n    template&lt;size_t otherSize&gt;\n    function(function&lt;Sign, otherSize&gt;&amp;&amp; other) { *this = other; }\n\n// member functions\n    Res operator()(Args... args) {\n        return call(data, std::forward&lt;Args&gt;(args)...);\n    }\n\n    explicit operator bool() const {\n        return call != nullptr;\n    }\n\n// type erasure constructors, assignment operators\n    explicit function(Res (*func)(Args...)) {\n        // new (data) funcptr&lt;Res, Args...&gt;(func);\n        // call = funcptr&lt;Res, Args...&gt;::call;\n        std::copy(static_cast&lt;uint8_t*&gt;(&amp;func), static_cast&lt;uint8_t*&gt;(&amp;func) + sizeof(func), data);\n        call = invoker&lt;Res, Args...&gt;;\n    }\n    function&amp; operator=(Res (*func)(Args...)) { new (this) function(func); return *this; }\n\n    template&lt;class Class&gt;\n    function(Res (Class::*func)(Args...), Class* self) {\n        new (data) memberfuncptr&lt;Class, Res, Args...&gt;(func, self);\n        call = memberfuncptr&lt;Class, Res, Args...&gt;::call;\n    }\n\n    template&lt;class Class&gt;\n    function(Res (Class::*func)(Args...) const, Class* self) {\n        new (data) memberconstfuncptr&lt;Class, Res, Args...&gt;(func, self);\n        call = memberconstfuncptr&lt;Class, Res, Args...&gt;::call;\n    }\n    template&lt;typename Func, typename Sign = typename signatureHelper&lt;decltype(&amp;Func::operator())&gt;::type&gt;\n    explicit function(Func func) {\n        new (data) callableany&lt;Func, Sign&gt;(func);\n        call = callableany&lt;Func, Sign&gt;::call;\n    }\n    template&lt;typename Func, typename Sign = typename signatureHelper&lt;decltype(&amp;Func::operator())&gt;::type&gt;\n    function&amp; operator=(Func func) { new (this) function(func); return *this; }\n};\n\n// template&lt;typename Res, typename... Args&gt;\n// function(Res (*)(Args...)) -&gt; function&lt;Res(Args...), sizeof(funcptr&lt;Res, Args...&gt;)&gt;;\ntemplate&lt;typename Res, typename... Args&gt;\nfunction(Res (*)(Args...)) -&gt; function&lt;Res(Args...), sizeof(Res (*)(Args...))&gt;;\n\ntemplate&lt;class Class, typename Res, typename... Args&gt;\nfunction(Res (Class::*)(Args...), Class*) -&gt; function&lt;Res(Args...), sizeof(memberfuncptr&lt;Class, Res, Args...&gt;)&gt;;\n\ntemplate&lt;class Class, typename Res, typename... Args&gt;\nfunction(Res (Class::*)(Args...) const, Class*) -&gt; function&lt;Res(Args...), sizeof(memberconstfuncptr&lt;Class, Res, Args...&gt;)&gt;;\n\ntemplate&lt;typename Func, typename Sign = typename signatureHelper&lt;decltype(&amp;Func::operator())&gt;::type&gt;\nfunction(Func) -&gt; function&lt;Sign, sizeof(callableany&lt;Func, Sign&gt;)&gt;;\n\n} // namespace noal\n</code></pre>"},{"location":"doxygen/dir_256037ad7d0c306238e2bc4f945d341d/","title":"Dir src/jac","text":"<p>FileList &gt; jac</p>"},{"location":"doxygen/dir_256037ad7d0c306238e2bc4f945d341d/#directories","title":"Directories","text":"Type Name dir features dir machine <p>The documentation for this class was generated from the following file <code>src/jac/</code></p>"},{"location":"doxygen/dir_6f95e06b732314161804ab1ef73c9681/","title":"Dir src/jac/features","text":"<p>FileList &gt; features</p>"},{"location":"doxygen/dir_6f95e06b732314161804ab1ef73c9681/#files","title":"Files","text":"Type Name file basicStreamFeature.h file eventLoopFeature.h file eventLoopTerminal.h file eventQueueFeature.h file filesystemFeature.h file moduleLoaderFeature.h file stdioFeature.h file timersFeature.h"},{"location":"doxygen/dir_6f95e06b732314161804ab1ef73c9681/#directories","title":"Directories","text":"Type Name dir types dir util <p>The documentation for this class was generated from the following file <code>src/jac/features/</code></p>"},{"location":"doxygen/basicStreamFeature_8h/","title":"File basicStreamFeature.h","text":"<p>FileList &gt; features &gt; basicStreamFeature.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/machine/class.h&gt;</code></li> <li><code>#include &lt;jac/machine/functionFactory.h&gt;</code></li> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;jac/machine/values.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"types/streams.h\"</code></li> </ul>"},{"location":"doxygen/basicStreamFeature_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/basicStreamFeature_8h/#classes","title":"Classes","text":"Type Name class BasicStreamFeature &lt;class Next&gt; struct ReadableProtoBuilder struct WritableProtoBuilder <p>The documentation for this class was generated from the following file <code>src/jac/features/basicStreamFeature.h</code></p>"},{"location":"doxygen/basicStreamFeature_8h_source/","title":"File basicStreamFeature.h","text":"<p>File List &gt; features &gt; basicStreamFeature.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/machine/class.h&gt;\n#include &lt;jac/machine/functionFactory.h&gt;\n#include &lt;jac/machine/machine.h&gt;\n#include &lt;jac/machine/values.h&gt;\n\n#include &lt;string&gt;\n\n#include \"types/streams.h\"\n\nnamespace jac {\n\n\nstruct WritableProtoBuilder : public ProtoBuilder::Opaque&lt;Writable&gt;, public ProtoBuilder::Properties {\n    static void addProperties(ContextRef ctx, Object proto) {\n        addMethodMember&lt;void(Writable::*)(std::string), &amp;Writable::write&gt;(ctx, proto, \"write\");\n    }\n};\n\n\nstruct ReadableProtoBuilder : public ProtoBuilder::Opaque&lt;Readable&gt;, public ProtoBuilder::Properties {\n    static void addProperties(ContextRef ctx, Object proto) {\n        FunctionFactory ff(ctx);\n\n        proto.defineProperty(\"get\", ff.newFunctionThis([](ContextRef ctx_, ValueWeak self) {\n            Readable&amp; self_ = *ReadableProtoBuilder::getOpaque(ctx_, self);\n            auto [promise, resolve, reject] = Promise::create(ctx_);\n\n            bool res = self_.get([resolve_ = resolve](char data) mutable {\n                resolve_.call&lt;void&gt;(std::string{static_cast&lt;char&gt;(data)});\n            });\n\n            if (!res) {\n                reject.call&lt;void&gt;(Exception::create(Exception::Type::Error, \"Stream is not readable\"));\n            }\n\n            return promise;\n        }));\n\n        proto.defineProperty(\"read\", ff.newFunctionThis([](ContextRef ctx_, ValueWeak self) {\n            Readable&amp; self_ = *ReadableProtoBuilder::getOpaque(ctx_, self);\n            auto [promise, resolve, reject] = Promise::create(ctx_);\n\n            bool res = self_.read([resolve_ = resolve](std::string data) mutable {\n                resolve_.call&lt;void&gt;(data);\n            });\n\n            if (!res) {\n                reject.call&lt;void&gt;(Exception::create(Exception::Type::Error, \"Stream is not readable\"));\n            }\n\n            return promise;\n        }));\n    }\n};\n\n\ntemplate&lt;class Next&gt;\nclass BasicStreamFeature : public Next {\npublic:\n\n    using WritableClass = Class&lt;WritableProtoBuilder&gt;;\n    using ReadableClass = Class&lt;ReadableProtoBuilder&gt;;\n\n    BasicStreamFeature() {\n        WritableClass::init(\"Writable\");\n        ReadableClass::init(\"Readable\");\n    }\n\n    void initialize() {\n        Next::initialize();\n\n        WritableClass::initContext(this-&gt;context());\n        ReadableClass::initContext(this-&gt;context());\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/eventLoopFeature_8h/","title":"File eventLoopFeature.h","text":"<p>FileList &gt; features &gt; eventLoopFeature.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/machine/functionFactory.h&gt;</code></li> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;noal_func.h&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include \"eventLoopTerminal.h\"</code></li> </ul>"},{"location":"doxygen/eventLoopFeature_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/eventLoopFeature_8h/#classes","title":"Classes","text":"Type Name class EventLoopFeature &lt;class Next&gt; <p>The documentation for this class was generated from the following file <code>src/jac/features/eventLoopFeature.h</code></p>"},{"location":"doxygen/eventLoopFeature_8h_source/","title":"File eventLoopFeature.h","text":"<p>File List &gt; features &gt; eventLoopFeature.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/machine/functionFactory.h&gt;\n#include &lt;jac/machine/machine.h&gt;\n\n#include &lt;atomic&gt;\n#include &lt;noal_func.h&gt;\n#include &lt;optional&gt;\n\n#include \"eventLoopTerminal.h\"\n\n\nnamespace jac {\n\n\ntemplate&lt;class Next&gt;\nclass EventLoopFeature : public Next {\nprivate:\n    std::atomic&lt;bool&gt; _shouldExit = false;\n    int _exitCode = 1;\n\nprotected:\n    std::optional&lt;Exception&gt; _error = std::nullopt;\n\n    void evalWithEventLoopCommon(Value&amp; promise) {\n        auto promiseObj = promise.to&lt;ObjectWeak&gt;();\n\n        FunctionFactory ff(this-&gt;context());\n        auto fail = ff.newFunction(noal::function([this](Value err) {\n            this-&gt;_error = err.to&lt;Exception&gt;();\n            this-&gt;kill();\n        }));\n\n        auto catch_ = promiseObj.get&lt;Function&gt;(\"catch\");\n        catch_.callThis&lt;void&gt;(promise, fail);\n\n        this-&gt;runEventLoop();\n    }\npublic:\n\n    void runEventLoop() {\n        try {\n            JSRuntime* rt = JS_GetRuntime(this-&gt;context());\n            JSContext* ctx1;\n\n            bool didJob = true;\n            while (!_shouldExit) {\n                runOnEventLoop();\n\n                auto event = this-&gt;getEvent(!didJob);\n                this-&gt;resetWatchdog();\n                if (event) {\n                    (*event)();\n                }\n                else if (!didJob) {\n                    continue;\n                }\n\n                didJob = false;\n                while (!_shouldExit) {\n                    this-&gt;resetWatchdog();\n                    int err = JS_ExecutePendingJob(rt, &amp;ctx1);\n                    if (err &lt;= 0) {\n                        if (err &lt; 0) {\n                            throw ContextRef(ctx1).getException();\n                        }\n                        break;\n                    }\n                    didJob = true;\n                }\n            }\n        }\n        catch (...) {\n            if (_shouldExit) {\n                // ignore\n            }\n            else {\n                throw;\n            }\n        }\n\n        if (_error) {\n            throw (*_error);\n        }\n    }\n\n    void kill() {\n        _shouldExit = true;\n        this-&gt;interruptRuntime();\n        this-&gt;notifyEventLoop();\n        _exitCode = 1;\n    }\n\n    void exit(int code) {\n        kill();\n        _exitCode = code;\n    }\n\n    int getExitCode() {\n        return _exitCode;\n    }\n\n    void evalModuleWithEventLoop(std::string code, std::string filename) {\n        Value promise = this-&gt;eval(std::move(code), filename, EvalFlags::Module);\n        this-&gt;evalWithEventLoopCommon(promise);\n    }\n\n    virtual void runOnEventLoop() = 0;\n\n    void initialize() {\n        Next::initialize();\n        FunctionFactory ff(this-&gt;context());\n        Object global = this-&gt;context().getGlobalObject();\n\n        global.defineProperty(\"exit\", ff.newFunction(noal::function(&amp;EventLoopFeature::exit, this)), PropFlags::Enumerable);\n    }\n\n    void onEventLoop() {\n        // last in stack\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/eventLoopTerminal_8h/","title":"File eventLoopTerminal.h","text":"<p>FileList &gt; features &gt; eventLoopTerminal.h</p> <p>Go to the source code of this file</p>"},{"location":"doxygen/eventLoopTerminal_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/eventLoopTerminal_8h/#classes","title":"Classes","text":"Type Name class EventLoopTerminal &lt;class Next&gt; <p>The documentation for this class was generated from the following file <code>src/jac/features/eventLoopTerminal.h</code></p>"},{"location":"doxygen/eventLoopTerminal_8h_source/","title":"File eventLoopTerminal.h","text":"<p>File List &gt; features &gt; eventLoopTerminal.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n\nnamespace jac {\n\n\ntemplate&lt;class Next&gt;\nclass EventLoopTerminal : public Next {\npublic:\n    virtual void runOnEventLoop() override {  // NOLINT\n        Next::onEventLoop();\n    };\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/eventQueueFeature_8h/","title":"File eventQueueFeature.h","text":"<p>FileList &gt; features &gt; eventQueueFeature.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;condition_variable&gt;</code></li> <li><code>#include &lt;deque&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> </ul>"},{"location":"doxygen/eventQueueFeature_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/eventQueueFeature_8h/#classes","title":"Classes","text":"Type Name class EventQueueFeature &lt;class Next&gt; <p>The documentation for this class was generated from the following file <code>src/jac/features/eventQueueFeature.h</code></p>"},{"location":"doxygen/eventQueueFeature_8h_source/","title":"File eventQueueFeature.h","text":"<p>File List &gt; features &gt; eventQueueFeature.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;condition_variable&gt;\n#include &lt;deque&gt;\n#include &lt;functional&gt;\n#include &lt;mutex&gt;\n#include &lt;optional&gt;\n\n\nnamespace jac {\n\n\ntemplate&lt;class Next&gt;\nclass EventQueueFeature : public Next {\nprivate:\n    std::deque&lt;std::function&lt;void()&gt;&gt; _scheduledFunctions;\n    std::mutex _scheduledFunctionsMutex;\n    std::condition_variable _scheduledFunctionsCondition;\npublic:\n    std::optional&lt;std::function&lt;void()&gt;&gt; getEvent(bool wait) {\n        std::unique_lock lock(_scheduledFunctionsMutex);\n        if (wait &amp;&amp; _scheduledFunctions.empty()) {\n            _scheduledFunctionsCondition.wait(lock);\n        }\n        if (_scheduledFunctions.empty()) {\n            return std::nullopt;\n        }\n        auto func = std::move(_scheduledFunctions.front());\n        _scheduledFunctions.pop_front();\n        lock.unlock();\n\n        return func;\n    }\n\n    void scheduleEvent(std::function&lt;void()&gt; func) {\n        {\n            std::scoped_lock lock(_scheduledFunctionsMutex);\n            _scheduledFunctions.push_back(std::move(func));\n        }\n        _scheduledFunctionsCondition.notify_one();\n    }\n\n    void notifyEventLoop() {\n        _scheduledFunctionsCondition.notify_one();\n    }\n\n    ~EventQueueFeature() {\n        notifyEventLoop();\n        std::scoped_lock lock(_scheduledFunctionsMutex);\n        _scheduledFunctions.clear();\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/filesystemFeature_8h/","title":"File filesystemFeature.h","text":"<p>FileList &gt; features &gt; filesystemFeature.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/machine/class.h&gt;</code></li> <li><code>#include &lt;jac/machine/functionFactory.h&gt;</code></li> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;noal_func.h&gt;</code></li> <li><code>#include \"types/file.h\"</code></li> </ul>"},{"location":"doxygen/filesystemFeature_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/filesystemFeature_8h/#classes","title":"Classes","text":"Type Name struct FileProtoBuilder class FilesystemFeature &lt;class Next&gt; class Path <p>The documentation for this class was generated from the following file <code>src/jac/features/filesystemFeature.h</code></p>"},{"location":"doxygen/filesystemFeature_8h_source/","title":"File filesystemFeature.h","text":"<p>File List &gt; features &gt; filesystemFeature.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/machine/class.h&gt;\n#include &lt;jac/machine/functionFactory.h&gt;\n#include &lt;jac/machine/machine.h&gt;\n\n#include &lt;filesystem&gt;\n#include &lt;noal_func.h&gt;\n\n#include \"types/file.h\"\n\n\nnamespace jac {\n\n\nstruct FileProtoBuilder : public ProtoBuilder::Opaque&lt;File&gt;, public ProtoBuilder::Properties {\n    static void addProperties(ContextRef ctx, Object proto) {\n        addPropMember&lt;std::string, &amp;File::path_&gt;(ctx, proto, \"path\", PropFlags::Enumerable);\n        addMethodMember&lt;bool(File::*)(), &amp;File::isOpen&gt;(ctx, proto, \"isOpen\", PropFlags::Enumerable);\n        addMethodMember&lt;void(File::*)(), &amp;File::close&gt;(ctx, proto, \"close\", PropFlags::Enumerable);\n        addMethodMember&lt;std::string(File::*)(int), &amp;File::read&gt;(ctx, proto, \"read\", PropFlags::Enumerable);\n        addMethodMember&lt;void(File::*)(std::string), &amp;File::write&gt;(ctx, proto, \"write\", PropFlags::Enumerable);\n    }\n};\n\n\ntemplate&lt;class Next&gt;\nclass FilesystemFeature : public Next {\nprivate:\n\n    std::filesystem::path _codeDir = \".\";\n    std::filesystem::path _workingDir = \".\";\n\npublic:\n    using FileClass = Class&lt;FileProtoBuilder&gt;;\n\n    void setCodeDir(std::string path_) {\n        this-&gt;_codeDir = std::filesystem::path(path_).lexically_normal();\n    }\n\n    void setWorkingDir(std::string path_) {\n        this-&gt;_workingDir = std::filesystem::path(path_).lexically_normal();\n    }\n\n    class Path {\n        FilesystemFeature&amp; _feature;\n    public:\n        Path(FilesystemFeature&amp; feature): _feature(feature) {}\n\n        std::string normalize(std::string path_) {\n            return std::filesystem::path(path_).lexically_normal().string();\n        }\n\n        std::string dirname(std::string path_) {\n            auto res = std::filesystem::path(path_).parent_path().string();\n            return res.empty() ? \".\" : res;\n        }\n\n        std::string basename(std::string path_) {\n            return std::filesystem::path(path_).filename().string();\n        }\n\n        std::string join(std::vector&lt;std::string&gt; paths) {\n            std::filesystem::path path_;\n            for (auto&amp; p : paths) {\n                path_ /= p;\n            }\n            return path_.string();\n        }\n    };\n\nprivate:\n    class Fs {\n        FilesystemFeature&amp; _feature;\n    public:\n        Fs(FilesystemFeature&amp; feature) : _feature(feature) {}\n\n        std::string loadCode(std::string filename) {\n            std::string buffer;\n            File file(_feature._codeDir / filename, \"r\");\n            std::string read = file.read();\n            while (!read.empty()) {\n                buffer += read;\n                read = file.read();\n            }\n            return buffer;\n        }\n\n\n        File open(std::string path_, std::string flags) {\n            return File(_feature._workingDir / path_, flags);\n        }\n\n        bool exists(std::string path_) {\n            return std::filesystem::exists(_feature._workingDir / path_);\n        }\n\n        bool isFile(std::string path_) {\n            return std::filesystem::is_regular_file(_feature._workingDir / path_);\n        }\n\n        bool isDirectory(std::string path_) {\n            return std::filesystem::is_directory(_feature._workingDir / path_);\n        }\n\n        void mkdir(std::string path_) {\n            std::filesystem::create_directories(_feature._workingDir / path_);\n        }\n\n        std::vector&lt;std::string&gt; readdir(std::string path_) {\n            std::vector&lt;std::string&gt; res;\n            for (auto&amp; p : std::filesystem::directory_iterator(_feature._workingDir / path_)) {\n                res.push_back(p.path().filename().string());\n            }\n            return res;\n        }\n\n        void rm(std::string path_) {\n            std::filesystem::remove(_feature._workingDir / path_);\n        }\n\n        void rmdir(std::string path_) {\n            std::filesystem::remove_all(_feature._workingDir / path_);\n        }\n    };\n\npublic:\n    Path path;\n    Fs fs;\n\n    FilesystemFeature() : path(*this), fs(*this) {\n        FileClass::init(\"File\");\n    }\n\n    void initialize() {\n        Next::initialize();\n\n        FileClass::initContext(this-&gt;context());\n\n        FunctionFactory ff(this-&gt;context());\n\n        Module&amp; pathMod = this-&gt;newModule(\"path\");\n        pathMod.addExport(\"normalize\", ff.newFunction(noal::function(&amp;Path::normalize, &amp;(this-&gt;path))));\n        pathMod.addExport(\"dirname\", ff.newFunction(noal::function(&amp;Path::dirname, &amp;(this-&gt;path))));\n        pathMod.addExport(\"basename\", ff.newFunction(noal::function(&amp;Path::basename, &amp;(this-&gt;path))));\n        pathMod.addExport(\"join\", ff.newFunctionVariadic([this](std::vector&lt;ValueWeak&gt; paths) {\n            std::vector&lt;std::string&gt; paths_;\n            for (auto&amp; p : paths) {\n                paths_.push_back(p.to&lt;std::string&gt;());\n            }\n            return this-&gt;path.join(paths_);\n        }));\n\n        Module&amp; fsMod = this-&gt;newModule(\"fs\");\n        fsMod.addExport(\"open\", ff.newFunction([this](std::string path_, std::string flags) {\n            return FileClass::createInstance(this-&gt;context(), new File(this-&gt;fs.open(path_, flags)));\n        }));\n        fsMod.addExport(\"exists\", ff.newFunction(noal::function(&amp;Fs::exists, &amp;(this-&gt;fs))));\n        fsMod.addExport(\"isFile\", ff.newFunction(noal::function(&amp;Fs::isFile, &amp;(this-&gt;fs))));\n        fsMod.addExport(\"isDirectory\", ff.newFunction(noal::function(&amp;Fs::isDirectory, &amp;(this-&gt;fs))));\n        fsMod.addExport(\"mkdir\", ff.newFunction(noal::function(&amp;Fs::mkdir, &amp;(this-&gt;fs))));\n        fsMod.addExport(\"rm\", ff.newFunction(noal::function(&amp;Fs::rm, &amp;(this-&gt;fs))));\n        fsMod.addExport(\"rmdir\", ff.newFunction(noal::function(&amp;Fs::rmdir, &amp;(this-&gt;fs))));\n        fsMod.addExport(\"readdir\", ff.newFunction(noal::function(&amp;Fs::readdir, &amp;(this-&gt;fs))));\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/moduleLoaderFeature_8h/","title":"File moduleLoaderFeature.h","text":"<p>FileList &gt; features &gt; moduleLoaderFeature.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> </ul>"},{"location":"doxygen/moduleLoaderFeature_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/moduleLoaderFeature_8h/#classes","title":"Classes","text":"Type Name class ModuleLoaderFeature &lt;class Next&gt; <p>The documentation for this class was generated from the following file <code>src/jac/features/moduleLoaderFeature.h</code></p>"},{"location":"doxygen/moduleLoaderFeature_8h_source/","title":"File moduleLoaderFeature.h","text":"<p>File List &gt; features &gt; moduleLoaderFeature.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/machine/machine.h&gt;\n\n\nnamespace jac {\n\n\ntemplate&lt;class Next&gt;\nclass ModuleLoaderFeature : public Next {\nprivate:\n    static JSModuleDef *moduleLoaderCbk(JSContext* ctx, const char *module_name, void *_self) {\n        auto &amp;self = *static_cast&lt;ModuleLoaderFeature&lt;Next&gt;*&gt;(_self);\n\n        std::string filename = module_name;\n\n        std::string buffer;\n        try {\n            buffer = self.fs.loadCode(filename);\n        } catch (jac::Exception &amp;e) {\n            e.throwJS(ctx);\n            return nullptr;\n        }\n\n        // compile and return module\n        self.resetWatchdog();\n        JSValue val = JS_Eval(ctx, buffer.c_str(), buffer.size(), module_name,\n                              JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);\n        if (JS_IsException(val)) {\n            return nullptr;\n        }\n\n        auto mdl = static_cast&lt;JSModuleDef*&gt;(JS_VALUE_GET_PTR(val));\n\n        Object meta(ctx, JS_GetImportMeta(ctx, mdl));\n        meta.set(\"url\", filename);\n        meta.set(\"main\", false);\n\n        return mdl;\n    }\n\npublic:\n    Value evalFile(std::string path_) {\n        auto buffer = this-&gt;fs.loadCode(path_);\n\n        Value val = this-&gt;eval(std::move(buffer), path_, EvalFlags::Module);\n        return val;\n    }\n\n    void evalFileWithEventLoop(std::string path_) {\n        Value promise = this-&gt;evalFile(path_);\n        this-&gt;evalWithEventLoopCommon(promise);\n    }\n\n    void initialize() {\n        Next::initialize();\n\n        JS_SetModuleLoaderFunc(this-&gt;runtime(), nullptr, moduleLoaderCbk, this);\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/dir_7e10f281dae724a55a0e1ba0acd02229/","title":"Dir src/jac/features/types","text":"<p>FileList &gt; features &gt; types</p>"},{"location":"doxygen/dir_7e10f281dae724a55a0e1ba0acd02229/#files","title":"Files","text":"Type Name file file.h file streams.h <p>The documentation for this class was generated from the following file <code>src/jac/features/types/</code></p>"},{"location":"doxygen/file_8h/","title":"File file.h","text":"<p>FileList &gt; features &gt; types &gt; file.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;jac/machine/values.h&gt;</code></li> </ul>"},{"location":"doxygen/file_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/file_8h/#classes","title":"Classes","text":"Type Name class File <p>The documentation for this class was generated from the following file <code>src/jac/features/types/file.h</code></p>"},{"location":"doxygen/file_8h_source/","title":"File file.h","text":"<p>File List &gt; features &gt; types &gt; file.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;filesystem&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n\n#include &lt;jac/machine/values.h&gt;\n\nnamespace jac {\n\n\nclass File {\n    std::fstream _file;\npublic:\n    std::string path_;\n\n    File(std::string path, std::string flags): path_(path) {\n        auto openMode = static_cast&lt;std::ios::openmode&gt;(0);\n        if (flags.find('r') != std::string::npos) {\n            openMode |= std::ios::in;\n        }\n        if (flags.find('w') != std::string::npos) {\n            openMode |= std::ios::out;\n        }\n        if (flags.find('a') != std::string::npos) {\n            openMode |= std::ios::app;\n        }\n        if (flags.find('b') != std::string::npos) {\n            openMode |= std::ios::binary;\n        }\n        if (flags.find('t') != std::string::npos) {\n            openMode |= std::ios::trunc;\n        }\n\n        if (openMode == static_cast&lt;std::ios::openmode&gt;(0)) {\n            throw jac::Exception::create(jac::Exception::Type::Error, \"Invalid file flags\");\n        }\n\n        this-&gt;_file = std::fstream(path, openMode);\n        if (!_file.is_open()) {\n            throw jac::Exception::create(jac::Exception::Type::Error, \"Could not open file: \" + path);\n        }\n    }\n    File(std::filesystem::path path, std::string flags): File(path.string(), flags) {}\n\n    std::string read(int length = 1024) {\n        std::string buffer;\n        buffer.resize(length);\n        this-&gt;_file.readsome(buffer.data(), length);\n        buffer.resize(this-&gt;_file.gcount());\n        return buffer;\n    }\n\n    void write(std::string data) {\n        this-&gt;_file.write(data.data(), data.size());\n    }\n\n    bool isOpen() {\n        return this-&gt;_file.is_open();\n    }\n\n    void close() {\n        this-&gt;_file.close();\n    }\n\n    ~File() {\n        this-&gt;close();\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/streams_8h/","title":"File streams.h","text":"<p>FileList &gt; features &gt; types &gt; streams.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"doxygen/streams_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/streams_8h/#classes","title":"Classes","text":"Type Name class Readable class ReadableRef class Writable class WritableRef <p>The documentation for this class was generated from the following file <code>src/jac/features/types/streams.h</code></p>"},{"location":"doxygen/streams_8h_source/","title":"File streams.h","text":"<p>File List &gt; features &gt; types &gt; streams.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;string&gt;\n\n\nnamespace jac {\n\n\nclass Writable {\npublic:\n    virtual void write(std::string data) = 0;\n\n    virtual ~Writable() = default;\n};\n\n\nclass Readable {\npublic:\n    virtual bool get(std::function&lt;void(char)&gt; callback) = 0;\n    virtual bool read(std::function&lt;void(std::string)&gt; callback) = 0;\n\n    virtual ~Readable() = default;\n};\n\nclass WritableRef : public Writable {\nprivate:\n    Writable* _ptr;\npublic:\n    WritableRef(Writable* ptr): _ptr(ptr) {}\n\n    void write(std::string data) override {\n        _ptr-&gt;write(std::move(data));\n    }\n};\n\nclass ReadableRef : public Readable {\nprivate:\n    Readable* _ptr;\npublic:\n    ReadableRef(Readable* ptr): _ptr(ptr) {}\n\n    bool read(std::function&lt;void(std::string)&gt; callback) override {\n        return _ptr-&gt;read(std::move(callback));\n    }\n\n    bool get(std::function&lt;void(char)&gt; callback) override {\n        return _ptr-&gt;get(std::move(callback));\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/dir_8745a1fa89e3088deda48338e7669502/","title":"Dir src/jac/features/util","text":"<p>FileList &gt; features &gt; util</p>"},{"location":"doxygen/dir_8745a1fa89e3088deda48338e7669502/#files","title":"Files","text":"Type Name file ostreamjs.h <p>The documentation for this class was generated from the following file <code>src/jac/features/util/</code></p>"},{"location":"doxygen/ostreamjs_8h/","title":"File ostreamjs.h","text":"<p>FileList &gt; features &gt; util &gt; ostreamjs.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"../types/streams.h\"</code></li> </ul>"},{"location":"doxygen/ostreamjs_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/ostreamjs_8h/#classes","title":"Classes","text":"Type Name class OsWritable <p>The documentation for this class was generated from the following file <code>src/jac/features/util/ostreamjs.h</code></p>"},{"location":"doxygen/ostreamjs_8h_source/","title":"File ostreamjs.h","text":"<p>File List &gt; features &gt; util &gt; ostreamjs.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\n#include \"../types/streams.h\"\n\nnamespace jac {\n\n\nclass OsWritable : public Writable {\n    std::ostream&amp; _stream;\npublic:\n    OsWritable(std::ostream&amp; stream): _stream(stream) {}\n\n    void write(std::string data) override {\n        _stream.write(data.data(), data.size());\n    }\n};\n\n\ntemplate&lt;class Machine&gt;\nstatic inline void initializeIo(Machine&amp; machine) {\n    if (!machine.stdio.out) {\n        machine.stdio.out = std::make_unique&lt;OsWritable&gt;(std::cout);\n    }\n    if (!machine.stdio.err) {\n        machine.stdio.err = std::make_unique&lt;OsWritable&gt;(std::cerr);\n    }\n}\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/stdioFeature_8h/","title":"File stdioFeature.h","text":"<p>FileList &gt; features &gt; stdioFeature.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/machine/functionFactory.h&gt;</code></li> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;jac/machine/values.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"types/streams.h\"</code></li> </ul>"},{"location":"doxygen/stdioFeature_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/stdioFeature_8h/#classes","title":"Classes","text":"Type Name class StdioFeature &lt;class Next&gt; <p>The documentation for this class was generated from the following file <code>src/jac/features/stdioFeature.h</code></p>"},{"location":"doxygen/stdioFeature_8h_source/","title":"File stdioFeature.h","text":"<p>File List &gt; features &gt; stdioFeature.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/machine/functionFactory.h&gt;\n#include &lt;jac/machine/machine.h&gt;\n#include &lt;jac/machine/values.h&gt;\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include \"types/streams.h\"\n\nnamespace jac {\n\n\ntemplate&lt;class Next&gt;\nclass StdioFeature : public Next {\nprivate:\n    class Stdio {\n    public:\n        std::unique_ptr&lt;Writable&gt; out;\n        std::unique_ptr&lt;Writable&gt; err;\n        std::unique_ptr&lt;Readable&gt; in;\n    };\npublic:\n    Stdio stdio;\n\n    void initialize() {\n        Next::initialize();\n\n        FunctionFactory ff(this-&gt;context());\n\n        if (!this-&gt;stdio.out) {\n            throw std::runtime_error(\"StdioFeature: stdio.out is not set\");\n        }\n        if (!this-&gt;stdio.err) {\n            throw std::runtime_error(\"StdioFeature: stdio.err is not set\");\n        }\n\n        Object console = Object::create(this-&gt;context());\n        console.set(\"debug\", ff.newFunction([this](std::string str) {\n            this-&gt;stdio.out-&gt;write(str + \"\\n\");\n        }));\n        console.set(\"log\", ff.newFunction([this](std::string str) {\n            this-&gt;stdio.out-&gt;write(str + \"\\n\");\n        }));\n        console.set(\"info\", ff.newFunction([this](std::string str) {\n            this-&gt;stdio.out-&gt;write(str + \"\\n\");\n        }));\n        console.set(\"warn\", ff.newFunction([this](std::string str) {\n            this-&gt;stdio.err-&gt;write(str + \"\\n\");\n        }));\n        console.set(\"error\", ff.newFunction([this](std::string str) {\n            this-&gt;stdio.err-&gt;write(str + \"\\n\");\n        }));\n        Object global = this-&gt;context().getGlobalObject();\n        global.defineProperty(\"console\", console);\n\n        auto&amp; mdl = this-&gt;newModule(\"stdio\");\n        mdl.addExport(\"stdout\", Next::WritableClass::createInstance(this-&gt;context(), new WritableRef(stdio.out.get())));\n        mdl.addExport(\"stderr\", Next::WritableClass::createInstance(this-&gt;context(), new WritableRef(stdio.err.get())));\n        if (stdio.in) {\n            mdl.addExport(\"stdin\", Next::ReadableClass::createInstance(this-&gt;context(), new ReadableRef(stdio.in.get())));\n        }\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/timersFeature_8h/","title":"File timersFeature.h","text":"<p>FileList &gt; features &gt; timersFeature.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/machine/functionFactory.h&gt;</code></li> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;condition_variable&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> </ul>"},{"location":"doxygen/timersFeature_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/timersFeature_8h/#classes","title":"Classes","text":"Type Name struct ConvTraits&lt; std::chrono::milliseconds &gt; &lt;&gt; class TimersFeature &lt;class Next&gt; <p>The documentation for this class was generated from the following file <code>src/jac/features/timersFeature.h</code></p>"},{"location":"doxygen/timersFeature_8h_source/","title":"File timersFeature.h","text":"<p>File List &gt; features &gt; timersFeature.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/machine/functionFactory.h&gt;\n#include &lt;jac/machine/machine.h&gt;\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;condition_variable&gt;\n#include &lt;mutex&gt;\n#include &lt;queue&gt;\n#include &lt;thread&gt;\n#include &lt;unordered_map&gt;\n\n\nnamespace jac {\n\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;std::chrono::milliseconds&gt; {\n    static std::chrono::milliseconds from(ContextRef, ValueWeak value) {\n        return std::chrono::milliseconds(value.to&lt;int&gt;());\n    }\n\n    static Value to(ContextRef ctx, std::chrono::milliseconds value) {\n        return Value::from(ctx, static_cast&lt;int&gt;(value.count()));\n    }\n};\n\ntemplate&lt;class Next&gt;\nclass TimersFeature : public Next {\nprivate:\n    class Timer {\n    private:\n        std::chrono::time_point&lt;std::chrono::steady_clock&gt; _startTime;\n        std::chrono::milliseconds _duration;\n        std::function&lt;void()&gt; _callback;\n        int _id;\n        bool _isRepeating = false;\n        bool cancelled = false;\n\n    public:\n        Timer(std::function&lt;void()&gt; callback, std::chrono::milliseconds duration, int id, bool isRepeating = false):\n            _duration(duration),\n            _callback(callback),\n            _id(id),\n            _isRepeating(isRepeating)\n        {\n            _startTime = std::chrono::steady_clock::now();\n        }\n\n        bool operator&lt;(const Timer&amp; other) const {\n            return getEndTime() &gt; other.getEndTime();\n        }\n\n        void update() {\n            if (_isRepeating) {\n                _startTime = std::chrono::steady_clock::now();\n            }\n        }\n\n        std::function&lt;void()&gt; getCallback() {\n            return _callback;\n        }\n\n        std::chrono::time_point&lt;std::chrono::steady_clock&gt; getEndTime() const {\n            return _startTime + _duration;\n        }\n\n        bool isRepeating() const {\n            return _isRepeating;\n        }\n\n        bool isCancelled() const {\n            return cancelled;\n        }\n\n        int getId() const {\n            return _id;\n        }\n\n        void cancel() {\n            cancelled = true;\n        }\n    };\n\n    class CompareTimer {\n    public:\n        bool operator()(const std::shared_ptr&lt;Timer&gt;&amp; a, const std::shared_ptr&lt;Timer&gt;&amp; b) const {\n            return *a &lt; *b;\n        }\n    };\n\n    std::priority_queue&lt;std::shared_ptr&lt;Timer&gt;, std::vector&lt;std::shared_ptr&lt;Timer&gt;&gt;, CompareTimer&gt; _timers;\n    std::unordered_map&lt;int, std::shared_ptr&lt;Timer&gt;&gt; _timersById;\n    std::mutex _timersMutex;\n    std::condition_variable _timersCondition;\n    std::thread _timerThread;\n    std::atomic&lt;bool&gt; _stop = false;\n\n    int nextId = 1;\n\n    int createTimer(std::function&lt;void()&gt; func, std::chrono::milliseconds millis, bool isRepeating) {\n        std::lock_guard&lt;std::mutex&gt; lock(_timersMutex);\n        auto timer = std::make_shared&lt;Timer&gt;(func, millis, nextId++, isRepeating);\n        _timers.emplace(timer);\n        _timersById[nextId - 1] = std::move(timer);\n\n        _timersCondition.notify_one();\n        return nextId - 1;\n    }\n\n    void clearTimer(int id) {\n        std::lock_guard&lt;std::mutex&gt; lock(_timersMutex);\n        auto it = _timersById.find(id);\n        if (it != _timersById.end()) {\n            it-&gt;second-&gt;cancel();\n        }\n    }\npublic:\n    int setInterval(std::function&lt;void()&gt; func, std::chrono::milliseconds millis) {\n        return createTimer(func, millis, true);\n    }\n\n    int setTimeout(std::function&lt;void()&gt; func, std::chrono::milliseconds millis) {\n        return createTimer(func, millis, false);\n    }\n\n    void clearInterval(int id) {\n        clearTimer(id);\n    }\n\n    void clearTimeout(int id) {\n        clearTimer(id);\n    }\n\n    void initialize() {\n        Next::initialize();\n\n        _stop = false;\n        _timerThread = std::thread([this]() {\n            while (!_stop) {\n                std::unique_lock&lt;std::mutex&gt; lock(_timersMutex);\n                if (_timers.empty()) {\n                    _timersCondition.wait(lock);\n                    if (_timers.empty()) {\n                        continue;\n                    }\n                }\n\n                auto timer = _timers.top();\n\n                if (timer-&gt;getEndTime() &gt; std::chrono::steady_clock::now()) {\n                    _timersCondition.wait_until(lock, timer-&gt;getEndTime());\n                    continue;\n                }\n\n                _timers.pop();\n\n                if (timer-&gt;isCancelled()) {\n                    int id = timer-&gt;getId();\n                    _timersById.erase(id);\n                    continue;\n                }\n\n                lock.unlock();\n\n                this-&gt;scheduleEvent([timer, this]() mutable {\n                    if (timer-&gt;isCancelled()) {\n                        std::lock_guard&lt;std::mutex&gt; lock_(_timersMutex);\n                        int id = timer-&gt;getId();\n                        _timersById.erase(id);\n                        return;\n                    }\n                    timer-&gt;getCallback()();\n\n                    std::lock_guard&lt;std::mutex&gt; lock_(_timersMutex);\n                    if (timer-&gt;isRepeating()) {\n                        timer-&gt;update();\n                        _timers.push(timer);\n                        _timersCondition.notify_one();\n                    }\n                    else {\n                        int id = timer-&gt;getId();\n                        _timersById.erase(id);\n                    }\n                });\n            }\n        });\n\n        FunctionFactory ff(this-&gt;context());\n        Object global = this-&gt;context().getGlobalObject();\n\n        global.defineProperty(\"setInterval\", ff.newFunction([this](Function func, std::chrono::milliseconds millis) {\n            return setInterval([func]() mutable {\n                func.call&lt;void&gt;();\n            }, millis);\n        }), PropFlags::Enumerable);\n\n        global.defineProperty(\"setTimeout\", ff.newFunction([this](Function func, std::chrono::milliseconds millis) {\n            return setTimeout([func]() mutable {\n                func.call&lt;void&gt;();\n            }, millis);\n        }), PropFlags::Enumerable);\n\n        global.defineProperty(\"clearInterval\", ff.newFunction([this](int id) {\n            clearInterval(id);\n        }), PropFlags::Enumerable);\n\n        global.defineProperty(\"clearTimeout\", ff.newFunction([this](int id) {\n            clearTimeout(id);\n        }), PropFlags::Enumerable);\n\n        global.defineProperty(\"sleep\", ff.newFunction([this](int millis) {\n            auto [promise, resolve, _] = Promise::create(this-&gt;context());\n            setTimeout([resolve_ = resolve]() mutable {\n                static_cast&lt;Function&amp;&gt;(resolve_).call&lt;void&gt;();\n            }, std::chrono::milliseconds(millis));\n            return promise;\n        }));\n    }\n\n    ~TimersFeature() {\n        {\n            std::scoped_lock lock(_timersMutex);\n            _timers = {};\n        }\n        _stop = true;\n        _timersCondition.notify_one();\n\n        if (_timerThread.joinable()) {\n            _timerThread.join();\n        }\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/dir_10e7d6e7bc593e38e57ffe1bab5ed259/","title":"Dir src/jac/machine","text":"<p>FileList &gt; jac &gt; machine</p>"},{"location":"doxygen/dir_10e7d6e7bc593e38e57ffe1bab5ed259/#files","title":"Files","text":"Type Name file atom.h file class.h file context.cpp file context.h file funcUtil.h file functionFactory.h file machine.cpp file machine.h file plugins.h file stringView.h file traits.h file values.h"},{"location":"doxygen/dir_10e7d6e7bc593e38e57ffe1bab5ed259/#directories","title":"Directories","text":"Type Name dir internal <p>The documentation for this class was generated from the following file <code>src/jac/machine/</code></p>"},{"location":"doxygen/atom_8h/","title":"File atom.h","text":"<p>FileList &gt; jac &gt; machine &gt; atom.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quickjs.h&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"internal/declarations.h\"</code></li> <li><code>#include \"context.h\"</code></li> <li><code>#include \"stringView.h\"</code></li> </ul>"},{"location":"doxygen/atom_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/atom_8h/#classes","title":"Classes","text":"Type Name class Atom A wrapper around JSAtom with RAII. In the context of QuickJS, Atom is used to represent identifiers of properties, variables, functions, etc. <p>The documentation for this class was generated from the following file <code>src/jac/machine/atom.h</code></p>"},{"location":"doxygen/atom_8h_source/","title":"File atom.h","text":"<p>File List &gt; jac &gt; machine &gt; atom.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;quickjs.h&gt;\n\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n\n#include \"internal/declarations.h\"\n\n#include \"context.h\"\n#include \"stringView.h\"\n\n\nnamespace jac {\n\n\ntemplate&lt;typename T=int&gt;\nconstexpr bool static_false() {\n    return false;\n};\n\n\nclass Atom {\nprotected:\n    ContextRef _ctx;\n    JSAtom _atom;\npublic:\n    Atom(ContextRef ctx, JSAtom atom) : _ctx(ctx), _atom(atom) {}\n    Atom(const Atom &amp;other):\n        _ctx(other._ctx),\n        _atom(JS_DupAtom(_ctx, other._atom))\n    {}\n    Atom(Atom &amp;&amp;other) : _ctx(other._ctx), _atom(other._atom) {\n        other._atom = JS_ATOM_NULL;\n        other._ctx = nullptr;\n    }\n\n    Atom&amp; operator=(const Atom &amp;other) {\n        if (_ctx) {\n            JS_FreeAtom(_ctx, _atom);\n        }\n        _atom = JS_DupAtom(_ctx, other._atom);\n        _ctx = other._ctx;\n\n        return *this;\n    }\n\n    Atom&amp; operator=(Atom &amp;&amp;other) {\n        if (_ctx) {\n            JS_FreeAtom(_ctx, _atom);\n        }\n        _atom = other._atom;\n        _ctx = other._ctx;\n        other._atom = JS_ATOM_NULL;\n        other._ctx = nullptr;\n        return *this;\n    }\n\n    ~Atom() {\n        if (_ctx) {\n            JS_FreeAtom(_ctx, _atom);\n        }\n    }\n\n    StringView toString() const {\n        return { _ctx, JS_AtomToCString(_ctx, _atom) };\n    }\n\n    std::pair&lt;ContextRef, JSAtom&gt; loot() {\n        JSAtom atom_ = _atom;\n        ContextRef ctx_ = this-&gt;_ctx;\n        _ctx = nullptr;\n        _atom = JS_ATOM_NULL;\n        return {ctx_, atom_};\n    }\n\n    JSAtom&amp; get() {\n        return _atom;\n    }\n\n    static Atom create(ContextRef ctx, uint32_t value) {\n        return { ctx, JS_NewAtomUInt32(ctx, value) };\n    }\n\n    static Atom create(ContextRef ctx, const char* value) {\n        return { ctx, JS_NewAtom(ctx, value) };\n    }\n\n    static Atom create(ContextRef ctx, std::string value) {\n        return create(ctx, value.c_str());\n    }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Atom&amp; val) {\n        os &lt;&lt; val.toString().c_str();\n        return os;\n    }\n};\n\n\n}  // namespace jac\n</code></pre>"},{"location":"doxygen/class_8h/","title":"File class.h","text":"<p>FileList &gt; jac &gt; machine &gt; class.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quickjs.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"funcUtil.h\"</code></li> <li><code>#include \"values.h\"</code></li> </ul>"},{"location":"doxygen/class_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac namespace ProtoBuilder namespace detail"},{"location":"doxygen/class_8h/#classes","title":"Classes","text":"Type Name class Class &lt;class Builder&gt; struct Callable A base class for javascript classes with callable instances. struct LifetimeHandles A base class used to add handles for lifetime events of an instance. struct Opaque &lt;typename T&gt;A base class for javascript classes with opaque data. struct Properties A base class for javascript classes with added properties. struct SgnUnwrap&lt; Res(Args...)&gt; &lt;typename Res, Args&gt; struct is_base_of_template_impl &lt;Base, typename Derived&gt; struct check &lt;A, class Void&gt; struct check&lt; A, std::void_t&lt; A&lt; Derived &gt; &gt; &gt; &lt;A&gt; struct is_base_of_template &lt;Base, typename Derived&gt;Checks if a type is derived from a template class. <p>The documentation for this class was generated from the following file <code>src/jac/machine/class.h</code></p>"},{"location":"doxygen/class_8h_source/","title":"File class.h","text":"<p>File List &gt; jac &gt; machine &gt; class.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;quickjs.h&gt;\n\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\n#include \"funcUtil.h\"\n#include \"values.h\"\n\n\nnamespace jac {\n\n\ntemplate&lt;typename Sgn&gt;\nstruct SgnUnwrap;\n\ntemplate&lt;typename Res, typename... Args&gt;\nstruct SgnUnwrap&lt;Res(Args...)&gt; {\n    using ResType = Res;\n    using ArgTypes = std::tuple&lt;Args...&gt;;\n\n    template&lt;class Class&gt;\n    SgnUnwrap(Res (Class::*)(Args...)) {}\n    template&lt;class Class&gt;\n    SgnUnwrap(Res (Class::*)(Args...) const) {}\n};\ntemplate&lt;class Class, typename Res, typename... Args&gt;\nSgnUnwrap(Res (Class::*)(Args...)) -&gt; SgnUnwrap&lt;Res(Args...)&gt;;\ntemplate&lt;class Class, typename Res, typename... Args&gt;\nSgnUnwrap(Res (Class::*)(Args...) const) -&gt; SgnUnwrap&lt;Res(Args...)&gt;;\n\nnamespace detail {\n    template&lt;template &lt;typename...&gt; class Base, typename Derived&gt;\n    struct is_base_of_template_impl {\n        template&lt;typename... Ts&gt;\n        static constexpr void is_callable(Base&lt;Ts...&gt;*);\n\n        template&lt;typename T&gt;\n        using is_callable_t = decltype(is_callable(std::declval&lt;T*&gt;()));\n\n        template&lt;template&lt;class...&gt; class A, class Void = void&gt;\n        struct check : std::false_type {};\n\n        template&lt;template&lt;class...&gt; class A&gt;\n        struct check&lt;A, std::void_t&lt;A&lt;Derived&gt;&gt;&gt; : std::true_type {};\n\n        using value_t = check&lt;is_callable_t&gt;;\n    };\n} // namespace detail\n\ntemplate&lt;template &lt;typename...&gt; class Base, typename Derived&gt;\nstruct is_base_of_template : detail::is_base_of_template_impl&lt;Base, Derived&gt;::value_t {};\n\ntemplate&lt;template &lt;typename...&gt; class Base, typename Derived&gt;\nusing is_base_of_template_t = typename is_base_of_template&lt;Base, Derived&gt;::type;\n\ntemplate&lt;template &lt;typename...&gt; class Base, typename Derived&gt;\ninline constexpr bool is_base_of_template_v = is_base_of_template&lt;Base, Derived&gt;::value;\n\n\nnamespace ProtoBuilder {\n\n    template&lt;typename T&gt;\n    struct Opaque {\n        using OpaqueType = T;\n        static inline JSClassID classId;\n\n        static T* constructOpaque(ContextRef /*ctx*/, std::vector&lt;ValueWeak&gt; /*args*/) {\n            throw Exception::create(Exception::Type::TypeError, \"Class cannot be instantiated\");\n        }\n\n        static void destroyOpaque(JSRuntime* /*rt*/, T* ptr) noexcept {\n            delete ptr;\n        }\n\n        static T* getOpaque(ContextRef /*ctx*/, ValueWeak thisVal) {\n            T* ptr = static_cast&lt;T*&gt;(JS_GetOpaque(thisVal.getVal(), classId));\n            if (!ptr) {\n                throw Exception::create(Exception::Type::TypeError, \"Invalid opaque data\");\n            }\n            return ptr;\n        }\n\n        template&lt;typename Sgn, Sgn member&gt;\n        static Value callMember(ContextRef ctx, ValueWeak funcObj, ValueWeak thisVal, std::vector&lt;ValueWeak&gt; argv) {\n            const SgnUnwrap Unwrap_(member);\n\n            return [&amp;]&lt;typename Res, typename... Args&gt;(SgnUnwrap&lt;Res(Args...)&gt;) {\n                auto f = [&amp;](Args... args) -&gt; Res {\n                    T* ptr = static_cast&lt;T*&gt;(JS_GetOpaque(funcObj.getVal(), classId));\n                    return (ptr-&gt;*member)(args...);\n                };\n\n                return processCall&lt;decltype(f), Res, Args...&gt;(ctx, thisVal, argv, f);\n            }(Unwrap_);\n        }\n\n\n        template&lt;typename U, U(T::*member)&gt;\n        static void addPropMember(ContextRef ctx, Object proto, std::string name, PropFlags flags = PropFlags::Default) {\n            using GetRaw = JSValue(*)(JSContext* ctx_, JSValueConst thisVal);\n            using SetRaw = JSValue(*)(JSContext* ctx_, JSValueConst thisVal, JSValueConst val);\n\n            GetRaw get = [](JSContext* ctx_, JSValueConst thisVal) -&gt; JSValue {\n                T* ptr = static_cast&lt;T*&gt;(JS_GetOpaque(thisVal, classId));\n                return Value::from(ctx_, ptr-&gt;*member).loot().second;\n            };\n            SetRaw set = [](JSContext* ctx_, JSValueConst thisVal, JSValueConst val) -&gt; JSValue {\n                T* ptr = static_cast&lt;T*&gt;(JS_GetOpaque(thisVal, classId));\n                ptr-&gt;*member = ValueWeak(ctx_, val).to&lt;U&gt;();\n                return JS_UNDEFINED;\n            };\n\n            JSValue getter = JS_NewCFunction2(ctx, reinterpret_cast&lt;JSCFunction*&gt;(reinterpret_cast&lt;void*&gt;(get)), (\"get \" + name).c_str(), 0, JS_CFUNC_getter, 0); // NOLINT\n            JSValue setter = JS_NewCFunction2(ctx, reinterpret_cast&lt;JSCFunction*&gt;(reinterpret_cast&lt;void*&gt;(set)), (\"set \" + name).c_str(), 1, JS_CFUNC_setter, 0); // NOLINT\n\n            Atom atom = Atom(ctx, JS_NewAtom(ctx, name.c_str()));\n            JS_DefinePropertyGetSet(ctx, proto.getVal(), atom.get(), getter, setter, static_cast&lt;int&gt;(flags));\n        }\n\n\n        template&lt;typename Sgn, Sgn member&gt;\n        static void addMethodMember(ContextRef ctx, Object proto, std::string name, PropFlags flags = PropFlags::Default) {\n            using MethodRaw = JSValue(*)(JSContext* ctx, JSValueConst thisVal, int argc, JSValueConst *argv);\n\n            const SgnUnwrap Unwrap_(member);\n\n            [&amp;]&lt;typename Res, typename... Args&gt;(SgnUnwrap&lt;Res(Args...)&gt;) {\n                MethodRaw func = [](JSContext* ctx_, JSValueConst thisVal, int argc, JSValueConst* argv) -&gt; JSValue {\n                    T* ptr = static_cast&lt;T*&gt;(JS_GetOpaque(thisVal, classId));\n\n                    auto f = [ptr](Args... args) -&gt; Res {\n                        return (ptr-&gt;*member)(args...);\n                    };\n\n                    return propagateExceptions(ctx_, [&amp;]() -&gt; JSValue {\n                        return processCallRaw&lt;decltype(f), Res, Args...&gt;(ctx_, thisVal, argc, argv, f);\n                    });\n                };\n\n                JSValue funcVal = JS_NewCFunction(ctx, static_cast&lt;JSCFunction*&gt;(func), name.c_str(), 0);\n\n                Atom atom = Atom(ctx, JS_NewAtom(ctx, name.c_str()));\n                JS_DefinePropertyValue(ctx, proto.getVal(), atom.get(), funcVal, static_cast&lt;int&gt;(flags));\n            }(Unwrap_);\n        }\n    };\n\n    struct LifetimeHandles {\n        static void postConstruction(ContextRef ctx, Object thisVal, std::vector&lt;ValueWeak&gt; args) {\n            // do nothing\n        }\n    };\n\n    struct Callable {\n        static Value callFunction(ContextRef /*ctx*/, ValueWeak /*funcObj*/, ValueWeak /*thisVal*/, std::vector&lt;ValueWeak&gt; /*args*/) {\n            throw Exception::create(Exception::Type::TypeError, \"Class cannot be called as a function\");\n        }\n\n        static Value callConstructor(ContextRef /*ctx*/, ValueWeak /*funcObj*/, ValueWeak /*target*/, std::vector&lt;ValueWeak&gt; /*args*/) {\n            throw Exception::create(Exception::Type::TypeError, \"Class cannot be called as a constructor\");\n        }\n    };\n\n    struct Properties {\n        static void addProperties(ContextRef ctx, Object proto) {}\n    };\n} // namespace ProtoBuilder\n\n\ntemplate&lt;class Builder&gt;\nclass Class {\n    static inline JSClassID classId;\n    static inline JSClassDef classDef;\n    static inline std::string className;\n    static inline bool isConstructor;\n\n    static JSValue constructor_impl(JSContext* ctx, JSValueConst thisVal, int argc, JSValueConst *argv) noexcept {\n        return propagateExceptions(ctx, [&amp;]() -&gt; JSValue {\n            Value proto = Value::undefined(ctx);\n            if (JS_IsUndefined(thisVal)) {\n                proto = Value(ctx, JS_GetClassProto(ctx, classId));\n            }\n            else {\n                proto = Value(ctx, JS_GetPropertyStr(ctx, thisVal, \"prototype\"));\n            }\n            Object obj(ctx, JS_NewObjectProtoClass(ctx, proto.getVal(), classId));\n\n            if constexpr (std::is_base_of_v&lt;ProtoBuilder::Callable, Builder&gt;) {\n                JS_SetConstructorBit(ctx, obj.getVal(), isConstructor);\n            }\n\n            constexpr bool isPbOpaque = is_base_of_template_v&lt;ProtoBuilder::Opaque, Builder&gt;;\n            constexpr bool isPbConstructor = std::is_base_of_v&lt;ProtoBuilder::LifetimeHandles, Builder&gt;;\n\n            if constexpr (isPbOpaque || isPbConstructor) {\n                std::vector&lt;ValueWeak&gt; args;\n                for (int i = 0; i &lt; argc; i++) {\n                    args.emplace_back(ctx, argv[i]);\n                }\n\n                if constexpr (isPbOpaque) {\n                    auto instance = Builder::constructOpaque(ctx, args);\n                    JS_SetOpaque(obj.getVal(), instance);\n                }\n\n                if constexpr (isPbConstructor) {\n                    Builder::postConstruction(ctx, obj, args);\n                }\n            }\n\n            return obj.loot().second;\n        });\n    }\n\npublic:\n    static void init(std::string name, bool isCtor = false) {\n        if (classId != 0) {\n            if (className != name || isConstructor != isCtor) {\n                throw std::runtime_error(\"Class already initialized with different name or constructor flag\");\n            }\n            return;\n        }\n        JS_NewClassID(&amp;classId);\n\n        className = name;\n        isConstructor = isCtor;\n\n        JSClassFinalizer* finalizer = nullptr;\n        JSClassCall* call = nullptr;\n\n        if constexpr (is_base_of_template_v&lt;ProtoBuilder::Opaque, Builder&gt;) {\n            Builder::classId = classId;\n            finalizer = [](JSRuntime* rt, JSValue val) noexcept {\n                static_assert(noexcept(Builder::destroyOpaque(rt, static_cast&lt;typename Builder::OpaqueType*&gt;(nullptr))));\n                Builder::destroyOpaque(rt, static_cast&lt;typename Builder::OpaqueType*&gt;(JS_GetOpaque(val, classId)));\n            };\n        }\n\n        if constexpr (std::is_base_of_v&lt;ProtoBuilder::Callable, Builder&gt;) {\n            call = [](JSContext* ctx, JSValueConst funcObj, JSValueConst thisVal, int argc, JSValueConst* argv, int flags) noexcept -&gt; JSValue {\n                std::vector&lt;ValueWeak&gt; args;\n                args.reserve(argc);\n                for (int i = 0; i &lt; argc; i++) {\n                    args.emplace_back(ctx, argv[i]);\n                }\n\n                return propagateExceptions(ctx, [&amp;]() -&gt; JSValue {\n                    if (flags &amp; JS_CALL_FLAG_CONSTRUCTOR) {\n                        return Builder::callConstructor(ctx, ValueWeak(ctx, funcObj), ValueWeak(ctx, thisVal), args).loot().second;\n                    } else {\n                        return Builder::callFunction(ctx, ValueWeak(ctx, funcObj), ValueWeak(ctx, thisVal), args).loot().second;\n                    }\n\n                    return JS_UNDEFINED;\n                });\n            };\n        }\n\n        classDef = {\n            .class_name = className.c_str(),\n            .finalizer = finalizer,\n            .gc_mark = nullptr,\n            .call = call,\n            .exotic = nullptr\n        };\n    }\n\n    static void initContext(ContextRef ctx) {\n        JSRuntime* rt = JS_GetRuntime(ctx);\n        if (!JS_IsRegisteredClass(rt, classId)) {\n            JS_NewClass(rt, classId, &amp;classDef);\n        }\n        auto proto = Object::create(ctx);\n\n\n        if constexpr (std::is_base_of_v&lt;ProtoBuilder::Properties, Builder&gt;) {\n            Builder::addProperties(ctx, proto);\n        }\n\n        Function ctor(ctx, JS_NewCFunction2(ctx, constructor_impl, className.c_str(), 0, JS_CFUNC_constructor, 0));\n        JS_SetConstructor(ctx, ctor.getVal(), proto.getVal());\n\n        JS_SetClassProto(ctx, classId, proto.loot().second);\n    }\n\n    static JSClassID getClassId() {\n        return classId;\n    }\n\n    static Object getProto(ContextRef ctx) {\n        JSRuntime* rt = JS_GetRuntime(ctx);\n        if (!JS_IsRegisteredClass(rt, classId)) {\n            JS_NewClass(rt, classId, &amp;classDef);\n        }\n        Value proto = Value(ctx, JS_GetClassProto(ctx, classId));\n        if (!JS_IsObject(proto.getVal())) {\n            initContext(ctx);\n            proto = Value(ctx, JS_GetClassProto(ctx, classId));\n        }\n        return proto.to&lt;Object&gt;();\n    }\n\n    static Function getConstructor(ContextRef ctx) {\n        Object proto = getProto(ctx);\n        return proto.get(\"constructor\").to&lt;Function&gt;();\n    }\n\n    template&lt;typename T, typename Bdr = Builder&gt;\n    static std::enable_if_t&lt;is_base_of_template_v&lt;ProtoBuilder::Opaque, Bdr&gt;\n            &amp;&amp; std::is_base_of_v&lt;typename Bdr::OpaqueType, T&gt;\n            &amp;&amp; std::is_same_v&lt;Bdr, Builder&gt;, Value&gt;\n        createInstance(ContextRef ctx, T* instance) {\n        Value proto = getProto(ctx);\n        Value obj(ctx, JS_NewObjectProtoClass(ctx, proto.getVal(), classId));\n        JS_SetOpaque(obj.getVal(), instance);\n        JS_SetConstructorBit(ctx, obj.getVal(), isConstructor);\n        return obj;\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/context_8cpp/","title":"File context.cpp","text":"<p>FileList &gt; jac &gt; machine &gt; context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"values.h\"</code></li> </ul>"},{"location":"doxygen/context_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace jac <p>The documentation for this class was generated from the following file <code>src/jac/machine/context.cpp</code></p>"},{"location":"doxygen/context_8cpp_source/","title":"File context.cpp","text":"<p>File List &gt; jac &gt; machine &gt; context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"values.h\"\n\n\nnamespace jac {\n\n\nException ContextRef::getException() {\n    try {\n        return { _ctx, JS_GetException(_ctx) };\n    }\n    catch (std::exception&amp; e) {\n        throw Exception::create(Exception::Type::InternalError, \"No exception\");\n    }\n}\n\nObject ContextRef::getGlobalObject() {\n    return { _ctx, JS_GetGlobalObject(_ctx) };\n}\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/context_8h/","title":"File context.h","text":"<p>FileList &gt; jac &gt; machine &gt; context.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quickjs.h&gt;</code></li> <li><code>#include \"internal/declarations.h\"</code></li> </ul>"},{"location":"doxygen/context_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/context_8h/#classes","title":"Classes","text":"Type Name class ContextRef A wrapper around JSContext* providing some related functionality. <p>The documentation for this class was generated from the following file <code>src/jac/machine/context.h</code></p>"},{"location":"doxygen/context_8h_source/","title":"File context.h","text":"<p>File List &gt; jac &gt; machine &gt; context.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;quickjs.h&gt;\n\n#include \"internal/declarations.h\"\n\n\nnamespace jac {\n\n\nclass ContextRef {\n    JSContext* _ctx;\n\npublic:\n    ContextRef(JSContext* ctx) : _ctx(ctx) {}\n\n    JSContext* get() { return _ctx; }\n\n    Exception getException();\n\n    Object getGlobalObject();\n\n    operator JSContext*() { return _ctx; }\n    operator JSContext*() const { return _ctx; }\n    operator bool() { return _ctx != nullptr; }\n    ContextRef&amp; operator=(JSContext* ctx) { _ctx = ctx; return *this; }\n};\n\n\n}  // namespace jac\n</code></pre>"},{"location":"doxygen/funcUtil_8h/","title":"File funcUtil.h","text":"<p>FileList &gt; jac &gt; machine &gt; funcUtil.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include &lt;quickjs.h&gt;</code></li> <li><code>#include \"values.h\"</code></li> </ul>"},{"location":"doxygen/funcUtil_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac <p>The documentation for this class was generated from the following file <code>src/jac/machine/funcUtil.h</code></p>"},{"location":"doxygen/funcUtil_8h_source/","title":"File funcUtil.h","text":"<p>File List &gt; jac &gt; machine &gt; funcUtil.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;exception&gt;\n#include &lt;quickjs.h&gt;\n\n#include \"values.h\"\n\nnamespace jac {\n\n\ntemplate&lt;typename Func&gt;\ninline JSValue propagateExceptions(ContextRef ctx, Func&amp; f) noexcept {\n    try {\n        return f();\n    }\n    catch (Exception&amp; e) {\n        return e.throwJS(ctx);\n    }\n    catch (std::exception&amp; e) {\n        return Exception::create(Exception::Type::InternalError, e.what()).throwJS(ctx);\n    }\n    catch (...) {\n        return Exception::create(Exception::Type::InternalError, \"unknown error\").throwJS(ctx);\n    }\n}\n\ntemplate&lt;typename Func&gt;\ninline JSValue propagateExceptions(ContextRef ctx, Func&amp;&amp; f) noexcept {\n    return propagateExceptions(ctx, f);\n}\n\ntemplate&lt;typename Func, typename Res, typename... Args&gt;\ninline JSValue processCallRaw(ContextRef ctx, JSValueConst, int argc, JSValueConst* argv, Func&amp; f) {\n    std::tuple&lt;Args...&gt; args = convertArgs&lt;Args...&gt;(ctx, argv, argc, std::make_index_sequence&lt;sizeof...(Args)&gt;());\n\n    if constexpr (std::is_same_v&lt;Res, void&gt;) {\n        std::apply(f, args);\n        return JS_UNDEFINED;\n    }\n    else {\n        return Value::from(ctx, std::apply(f, args)).loot().second;\n    }\n}\n\ntemplate&lt;typename Func, typename Res, typename... Args&gt;\ninline Value processCall(ContextRef ctx, ValueWeak, std::vector&lt;ValueWeak&gt; argv, Func&amp; f) {\n    std::tuple&lt;Args...&gt; args = convertArgs&lt;Args...&gt;(ctx, argv, std::make_index_sequence&lt;sizeof...(Args)&gt;());\n\n    if constexpr (std::is_same_v&lt;Res, void&gt;) {\n        std::apply(f, args);\n        return Value::undefined(ctx);\n    }\n    else {\n        return Value::from(ctx, std::apply(f, args));\n    }\n}\n\ntemplate&lt;typename Func, typename Res&gt;\ninline JSValue processCallVariadicRaw(ContextRef ctx, JSValueConst, int argc, JSValueConst* argv, Func&amp; f) {\n    std::vector&lt;ValueWeak&gt; args;\n    for (int i = 0; i &lt; argc; i++) {\n        args.emplace_back(ctx, argv[i]);\n    }\n\n    if constexpr (std::is_same_v&lt;Res, void&gt;) {\n        f(args);\n        return JS_UNDEFINED;\n    }\n    else {\n        return Value::from(ctx, f(args)).loot().second;\n    }\n}\n\ntemplate&lt;typename Func, typename Res&gt;\ninline Value processCallVariadic(ContextRef ctx, ValueWeak, std::vector&lt;ValueWeak&gt; argv, Func&amp; f) {\n    if constexpr (std::is_same_v&lt;Res, void&gt;) {\n        f(argv);\n        return Value::undefined(ctx);\n    }\n    else {\n        return Value::from(ctx, f(argv));\n    }\n}\n\ntemplate&lt;typename Func, typename Res, typename... Args&gt;\ninline Value processCallThis(ContextRef ctx, ValueWeak thisVal, std::vector&lt;ValueWeak&gt; argv, Func&amp; f) {\n    std::tuple&lt;Args...&gt; args = convertArgs&lt;Args...&gt;(ctx, argv, std::make_index_sequence&lt;sizeof...(Args)&gt;());\n\n    if constexpr (std::is_same_v&lt;Res, void&gt;) {\n        std::apply(f, std::tuple_cat(std::make_tuple(ctx, thisVal), args));\n        return Value::undefined(ctx);\n    }\n    else {\n        return Value::from(ctx, std::apply(f, std::tuple_cat(std::make_tuple(ctx, thisVal), args)));\n    }\n}\n\ntemplate&lt;typename Func, typename Res&gt;\ninline Value processCallThisVariadic(ContextRef ctx, ValueWeak thisVal, std::vector&lt;ValueWeak&gt; argv, Func&amp; f) {\n\n    if constexpr (std::is_same_v&lt;Res, void&gt;) {\n        f(ctx, thisVal, argv);\n        return Value::undefined(ctx);\n    }\n    else {\n        return Value::from(ctx, f(ctx, thisVal, argv));\n    }\n}\n\ntemplate&lt;typename... Args, std::size_t... Is&gt;\ninline std::tuple&lt;Args...&gt; convertArgs([[maybe_unused]]ContextRef ctx, std::vector&lt;ValueWeak&gt; argv, std::index_sequence&lt;Is...&gt;) {\n    if (argv.size() != sizeof...(Args)) {\n        throw Exception::create(Exception::Type::TypeError, \"invalid number of arguments\");\n    }\n\n    return std::make_tuple(argv[Is].to&lt;Args&gt;()...);\n}\n\ntemplate&lt;typename... Args, std::size_t... Is&gt;\ninline std::tuple&lt;Args...&gt; convertArgs([[maybe_unused]]ContextRef ctx, JSValueConst* argv, int argc, std::index_sequence&lt;Is...&gt;) {\n    if (argc != sizeof...(Args)) {\n        throw Exception::create(Exception::Type::TypeError, \"invalid number of arguments\");\n    }\n\n    return std::make_tuple(ValueWeak(ctx, argv[Is]).to&lt;Args&gt;()...);\n}\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/functionFactory_8h/","title":"File functionFactory.h","text":"<p>FileList &gt; jac &gt; machine &gt; functionFactory.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include \"class.h\"</code></li> <li><code>#include \"funcUtil.h\"</code></li> <li><code>#include \"values.h\"</code></li> </ul>"},{"location":"doxygen/functionFactory_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/functionFactory_8h/#classes","title":"Classes","text":"Type Name class FunctionFactory Various methods for wrapping C++ functions into javascript functions. <p>The documentation for this class was generated from the following file <code>src/jac/machine/functionFactory.h</code></p>"},{"location":"doxygen/functionFactory_8h_source/","title":"File functionFactory.h","text":"<p>File List &gt; jac &gt; machine &gt; functionFactory.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;functional&gt;\n\n#include \"class.h\"\n#include \"funcUtil.h\"\n#include \"values.h\"\n\n\nnamespace jac {\n\nclass FunctionFactory {\n\n    ContextRef _context;\n\n    template&lt;typename Func, typename Res, typename... Args&gt;\n    inline Function newFunctionHelper(Func&amp; func, std::function&lt;Res(Args...)&gt;);\n\n    template&lt;typename Func, typename Res&gt;\n    inline Function newFunctionVariadicHelper(Func&amp; func, std::function&lt;Res(std::vector&lt;ValueWeak&gt;)&gt;);\n\n    template&lt;typename Func, typename Res, typename... Args&gt;\n    inline Function newFunctionThisHelper(Func&amp; func, std::function&lt;Res(ContextRef, ValueWeak, Args...)&gt;);\n\n    template&lt;typename Func, typename Res&gt;\n    inline Function newFunctionThisVariadicHelper(Func&amp; func, std::function&lt;Res(ContextRef, ValueWeak, std::vector&lt;ValueWeak&gt;)&gt;);\npublic:\n    FunctionFactory(ContextRef context) : _context(context) {}\n\n    template&lt;class Func&gt;\n    Function newFunction(Func func) {\n        return newFunctionHelper(func, std::function(func));\n    }\n\n    template&lt;class Func&gt;\n    Function newFunctionVariadic(Func func) {\n        return newFunctionVariadicHelper(func, std::function(func));\n    }\n\n    template&lt;class Func&gt;\n    Function newFunctionThis(Func func) {\n        return newFunctionThisHelper(func, std::function(func));\n    }\n\n    template&lt;class Func&gt;\n    Function newFunctionThisVariadic(Func func) {\n        return newFunctionThisVariadicHelper(func, std::function(func));\n    }\n};\n\n\ntemplate&lt;typename Func, typename Res, typename... Args&gt;\ninline Function FunctionFactory::newFunctionHelper(Func&amp; func, std::function&lt;Res(Args...)&gt;) {\n    Func* funcPtr = new Func(std::move(func));\n\n    struct FuncProtoBuilder : public ProtoBuilder::Opaque&lt;Func&gt;, public ProtoBuilder::Callable {\n        static Value callFunction(ContextRef ctx, ValueWeak funcObj, ValueWeak thisVal, std::vector&lt;ValueWeak&gt; args) {\n            Func* ptr = ProtoBuilder::Opaque&lt;Func&gt;::getOpaque(ctx, funcObj);\n            return processCall&lt;Func, Res, Args...&gt;(ctx, thisVal, args, *ptr);\n        }\n    };\n\n    using FuncClass = Class&lt;FuncProtoBuilder&gt;;\n    FuncClass::init(\"CppFunction\");\n\n    return static_cast&lt;Value&gt;(FuncClass::createInstance(_context, funcPtr)).to&lt;Function&gt;();\n}\n\ntemplate&lt;class Func, typename Res&gt;\nFunction FunctionFactory::newFunctionVariadicHelper(Func&amp; func, std::function&lt;Res(std::vector&lt;ValueWeak&gt;)&gt;) {\n    Func* funcPtr = new Func(std::move(func));\n\n    struct FuncProtoBuilder : public ProtoBuilder::Opaque&lt;Func&gt;, public ProtoBuilder::Callable {\n        static Value callFunction(ContextRef ctx, ValueWeak funcObj, ValueWeak thisVal, std::vector&lt;ValueWeak&gt; args) {\n            Func* ptr = ProtoBuilder::Opaque&lt;Func&gt;::getOpaque(ctx, funcObj);\n            return processCallVariadic&lt;Func, Res&gt;(ctx, thisVal, args, *ptr);\n        }\n    };\n\n    using FuncClass = Class&lt;FuncProtoBuilder&gt;;\n    FuncClass::init(\"CppFunction\");\n\n    return static_cast&lt;Value&gt;(FuncClass::createInstance(_context, funcPtr)).to&lt;Function&gt;();\n}\n\ntemplate&lt;typename Func, typename Res, typename... Args&gt;\nFunction FunctionFactory::newFunctionThisHelper(Func&amp; func, std::function&lt;Res(ContextRef, ValueWeak, Args...)&gt;) {\n    Func* funcPtr = new Func(std::move(func));\n\n    struct FuncProtoBuilder : public ProtoBuilder::Opaque&lt;Func&gt;, public ProtoBuilder::Callable {\n        static Value callFunction(ContextRef ctx, ValueWeak funcObj, ValueWeak thisVal, std::vector&lt;ValueWeak&gt; args) {\n            Func* ptr = ProtoBuilder::Opaque&lt;Func&gt;::getOpaque(ctx, funcObj);\n            return processCallThis&lt;Func, Res, Args...&gt;(ctx, thisVal, args, *ptr);\n        }\n    };\n\n    using FuncClass = Class&lt;FuncProtoBuilder&gt;;\n    FuncClass::init(\"CppFunction\");\n\n    return static_cast&lt;Value&gt;(FuncClass::createInstance(_context, funcPtr)).to&lt;Function&gt;();\n}\n\ntemplate&lt;typename Func, typename Res&gt;\nFunction FunctionFactory::newFunctionThisVariadicHelper(Func&amp; func, std::function&lt;Res(ContextRef, ValueWeak, std::vector&lt;ValueWeak&gt;)&gt;) {\n    Func* funcPtr = new Func(std::move(func));\n\n    struct FuncProtoBuilder : public ProtoBuilder::Opaque&lt;Func&gt;, public ProtoBuilder::Callable {\n        static Value callFunction(ContextRef ctx, ValueWeak funcObj, ValueWeak thisVal, std::vector&lt;ValueWeak&gt; args) {\n            Func* ptr = ProtoBuilder::Opaque&lt;Func&gt;::getOpaque(ctx, funcObj);\n            return processCallThisVariadic&lt;Func, Res&gt;(ctx, thisVal, args, *ptr);\n        }\n    };\n\n    using FuncClass = Class&lt;FuncProtoBuilder&gt;;\n    FuncClass::init(\"CppFunction\");\n\n    return static_cast&lt;Value&gt;(FuncClass::createInstance(_context, funcPtr)).to&lt;Function&gt;();\n}\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/machine_8cpp/","title":"File machine.cpp","text":"<p>FileList &gt; jac &gt; machine &gt; machine.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"machine.h\"</code></li> </ul>"},{"location":"doxygen/machine_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace jac <p>The documentation for this class was generated from the following file <code>src/jac/machine/machine.cpp</code></p>"},{"location":"doxygen/machine_8cpp_source/","title":"File machine.cpp","text":"<p>File List &gt; jac &gt; machine &gt; machine.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"machine.h\"\n\n\nnamespace jac {\n\n\nModule::Module(ContextRef ctx, std::string name) : _ctx(ctx) {\n    _def = JS_NewCModule(ctx, name.c_str(), [](JSContext* context, JSModuleDef* def) {\n        Module&amp; mdl = base(context).findModule(def);\n\n        for (auto&amp; [exName, exVal] : mdl.exports) {\n            JS_SetModuleExport(context, def, exName.c_str(), exVal.loot().second);\n        }\n        return 0;\n    });\n    if (!_def) {\n        throw std::runtime_error(\"JS_NewCModule failed\");\n    }\n}\n\nvoid Module::addExport(std::string name, Value val) {\n    JS_AddModuleExport(_ctx, _def, name.c_str());\n    exports.emplace_back(name, val);\n}\n\nvoid MachineBase::initialize() {\n    // last in stack\n\n    _runtime = JS_NewRuntime();\n    _context = JS_NewContext(_runtime);\n\n    JS_SetContextOpaque(_context, this);\n    JS_SetInterruptHandler(_runtime, [](JSRuntime*, void* opaque) noexcept {\n        MachineBase&amp; base = *static_cast&lt;MachineBase*&gt;(opaque);\n        if (base._interrupt) {\n            base._interrupt = false;\n            return 1;\n        }\n        if (base._watchdogTimeout.count() &gt; 0) {\n            auto now = std::chrono::steady_clock::now();\n            if (now &gt; base._watchdogNext) {\n                base._watchdogNext = now + base._watchdogTimeout;\n                if (!base._wathdogCallback || base._wathdogCallback()) {\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    }, this);\n}\n\nValue MachineBase::eval(std::string code, std::string filename, EvalFlags flags /*= EvalFlags::Global*/) {\n    resetWatchdog();\n    Value bytecode(_context, JS_Eval(_context, code.c_str(), code.size(), filename.c_str(), static_cast&lt;int&gt;(flags | EvalFlags::CompileOnly)));\n    if (static_cast&lt;int&gt;(flags &amp; EvalFlags::CompileOnly) != 0) {\n        return bytecode;\n    }\n    code = \"\";\n    resetWatchdog();\n    return Value(_context, JS_EvalFunction(_context, bytecode.loot().second));\n}\n\nModule&amp; MachineBase::newModule(std::string name) {\n    Module mdl(_context, name);\n    JSModuleDef* def = mdl.get();\n    _modules.emplace(def, std::move(mdl));\n\n    return _modules.find(def)-&gt;second;\n}\n\nModule&amp; MachineBase::findModule(JSModuleDef* m) {\n    auto it = _modules.find(m);\n    if (it == _modules.end()) {\n        throw std::runtime_error(\"module not found\");\n    }\n    return it-&gt;second;\n}\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/machine_8h/","title":"File machine.h","text":"<p>FileList &gt; jac &gt; machine &gt; machine.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quickjs.h&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"values.h\"</code></li> </ul>"},{"location":"doxygen/machine_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/machine_8h/#classes","title":"Classes","text":"Type Name struct ComposeMachine&lt; Base &gt; &lt;class Base&gt; struct ComposeMachine&lt; Base, FirstFeature, MFeatures... &gt; &lt;class Base, FirstFeature, MFeatures&gt; class MachineBase class Module A wrapper around JSModuleDef that allows for easy exporting of values. <p>The documentation for this class was generated from the following file <code>src/jac/machine/machine.h</code></p>"},{"location":"doxygen/machine_8h_source/","title":"File machine.h","text":"<p>File List &gt; jac &gt; machine &gt; machine.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;quickjs.h&gt;\n\n#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\n#include \"values.h\"\n\n\nnamespace jac {\n\n\ntemplate&lt;class Base, template&lt;class&gt; class... MFeatures&gt;\nstruct ComposeMachine;\n\ntemplate&lt;class Base, template&lt;class&gt; class FirstFeature, template&lt;class&gt; class... MFeatures&gt;\nstruct ComposeMachine&lt;Base, FirstFeature, MFeatures...&gt; : public ComposeMachine&lt;FirstFeature&lt;Base&gt;, MFeatures...&gt; {};\n\ntemplate&lt;class Base&gt;\nstruct ComposeMachine&lt;Base&gt; : public Base {};\n\n\nenum class EvalFlags : int {\n    Global = JS_EVAL_TYPE_GLOBAL,\n    Module = JS_EVAL_TYPE_MODULE,\n\n    Strict = JS_EVAL_FLAG_STRICT,\n    CompileOnly = JS_EVAL_FLAG_COMPILE_ONLY,\n    BacktraceBarrier = JS_EVAL_FLAG_BACKTRACE_BARRIER\n};\n\ninline constexpr EvalFlags operator|(EvalFlags a, EvalFlags b) {\n    int res = static_cast&lt;int&gt;(a) | static_cast&lt;int&gt;(b);\n    if (res &amp; JS_EVAL_TYPE_GLOBAL &amp;&amp; res &amp; JS_EVAL_TYPE_MODULE) {\n        throw std::runtime_error(\"Cannot use both global and module eval flags\");\n    }\n    return static_cast&lt;EvalFlags&gt;(res);\n}\n\ninline constexpr EvalFlags operator&amp;(EvalFlags a, EvalFlags b) {\n    return static_cast&lt;EvalFlags&gt;(static_cast&lt;int&gt;(a) &amp; static_cast&lt;int&gt;(b));\n}\n\n\nclass MachineBase;\n\n\nclass Module {\n    ContextRef _ctx;\n    JSModuleDef *_def;\n\n    std::vector&lt;std::tuple&lt;std::string, Value&gt;&gt; exports;\n\n    inline MachineBase&amp; base() {\n        return *static_cast&lt;MachineBase*&gt;(JS_GetContextOpaque(_ctx));\n    }\n\n    static inline MachineBase&amp; base(ContextRef ctx) {\n        return *static_cast&lt;MachineBase*&gt;(JS_GetContextOpaque(ctx));\n    }\npublic:\n    Module(ContextRef ctx, std::string name);\n    Module&amp; operator=(const Module&amp;) = delete;\n    Module(const Module&amp;) = delete;\n    Module&amp; operator=(Module&amp;&amp; other) {\n        _ctx = other._ctx;\n        _def = other._def;\n        exports = std::move(other.exports);\n        other._def = nullptr;\n        return *this;\n    }\n    Module(Module&amp;&amp; other): _ctx(other._ctx), _def(other._def), exports(std::move(other.exports)) {\n        other._def = nullptr;\n    }\n\n    void addExport(std::string name, Value val);\n\n    JSModuleDef *get() {\n        return _def;\n    }\n};\n\n\nclass MachineBase {\nprivate:\n    std::unordered_map&lt;JSModuleDef*, Module&gt; _modules;\n    Module&amp; findModule(JSModuleDef* m);\n\n    bool _interrupt = false;\n\n    std::chrono::milliseconds _watchdogTimeout = std::chrono::milliseconds(0);\n    std::chrono::time_point&lt;std::chrono::steady_clock&gt; _watchdogNext;\n    std::function&lt;bool()&gt; _wathdogCallback;\n\n    JSRuntime* _runtime = nullptr;\n    ContextRef _context = nullptr;\npublic:\n    JSRuntime* runtime() {\n        return _runtime;\n    }\n\n    ContextRef context() {\n        return _context;\n    }\n\n    void initialize();\n\n    MachineBase() = default;\n    MachineBase(const MachineBase&amp;) = delete;\n    MachineBase(MachineBase&amp;&amp;) = delete;\n    MachineBase&amp; operator=(const MachineBase&amp;) = delete;\n    MachineBase&amp; operator=(MachineBase&amp;&amp;) = delete;\n\n    virtual ~MachineBase() {\n        _modules.clear();\n        if (_context) {\n            JS_FreeContext(_context);\n        }\n        if (_runtime) {\n            JS_FreeRuntime(_runtime);\n        }\n    }\n\n    Value eval(std::string code, std::string filename, EvalFlags flags = EvalFlags::Global);\n\n    Module&amp; newModule(std::string name);\n\n    void interruptRuntime() {\n        _interrupt = true;\n    }\n\n    void resetWatchdog() {\n        _watchdogNext = std::chrono::steady_clock::now() + _watchdogTimeout;\n    }\n\n    void setWatchdogTimeout(std::chrono::milliseconds timeout) {\n        _watchdogTimeout = timeout;\n    }\n\n    void setWatchdogHandler(std::function&lt;bool()&gt; callback) {\n        _wathdogCallback = callback;\n    }\n\n    friend class Module;\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/plugins_8h/","title":"File plugins.h","text":"<p>FileList &gt; jac &gt; machine &gt; plugins.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"doxygen/plugins_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/plugins_8h/#classes","title":"Classes","text":"Type Name class Plugin A base class for all plugins. class PluginHandle A handle which can be used to retrieve a plugin from a machine. class PluginHolderFeature &lt;typename Next&gt;An MFeature that allows for inserting plugins into the machine and retrieving them using PluginHandeles. class PluginManager A class for managing groups of plugins and initializing them all at once. <p>The documentation for this class was generated from the following file <code>src/jac/machine/plugins.h</code></p>"},{"location":"doxygen/plugins_8h_source/","title":"File plugins.h","text":"<p>File List &gt; jac &gt; machine &gt; plugins.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/machine/machine.h&gt;\n\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\n\nnamespace jac {\n\n\nclass Plugin {\npublic:\n    virtual ~Plugin() = default;\n};\n\n\nclass PluginHandle {\n    size_t _index;\npublic:\n    PluginHandle(size_t index) : _index(index) {}\n\n    size_t index() const {\n        return _index;\n    }\n\n    PluginHandle&amp; operator++() {\n        ++_index;\n        return *this;\n    }\n\n    PluginHandle operator++(int) {\n        PluginHandle copy = *this;\n        ++_index;\n        return copy;\n    }\n\n    PluginHandle operator+(size_t offset) {\n        return PluginHandle(_index + offset);\n    }\n\n    bool operator==(const PluginHandle&amp; other) const = default;\n};\n\n\ntemplate&lt;typename Next&gt;\nclass PluginHolderFeature : public Next {\nprivate:\n    std::vector&lt;std::unique_ptr&lt;Plugin&gt;&gt; _plugins;\npublic:\n    PluginHolderFeature() = default;\n\n    PluginHandle holdPlugin(std::unique_ptr&lt;Plugin&gt; plugin) {\n        _plugins.push_back(std::move(plugin));\n        return _plugins.size() - 1;\n    }\n\n    template&lt;typename Plugin_t = Plugin&gt;\n    Plugin_t&amp; getPlugin(PluginHandle handle) {\n        return dynamic_cast&lt;Plugin_t&amp;&gt;(*_plugins[handle.index()]);\n    }\n\n    PluginHandle pluginBegin() {\n        return 0;\n    }\n\n    PluginHandle pluginEnd() {\n        return _plugins.size();\n    }\n};\n\n\nclass PluginManager {\nprivate:\n    std::vector&lt;std::unique_ptr&lt;Plugin&gt;(*)(MachineBase&amp;)&gt; _plugins;\npublic:\n    PluginManager() = default;\n\n\n    template&lt;typename Plugin_t&gt;\n    size_t addPlugin() {\n        _plugins.push_back(+[](MachineBase&amp; machine) -&gt; std::unique_ptr&lt;Plugin&gt; {\n            return std::make_unique&lt;Plugin_t&gt;(machine);\n        });\n\n        return _plugins.size() - 1;\n    }\n\n    template&lt;typename Machine&gt;\n    PluginHandle initialize(Machine&amp; machine) {\n        PluginHandle first = machine.pluginBegin();\n\n        for (auto&amp; plugin : _plugins) {\n            machine.holdPlugin(plugin(machine));\n        }\n\n        return first;\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/dir_f815192ecbd68c2ad40e839ff65387cf/","title":"Dir src/jac/machine/internal","text":"<p>FileList &gt; internal</p>"},{"location":"doxygen/dir_f815192ecbd68c2ad40e839ff65387cf/#files","title":"Files","text":"Type Name file declarations.h <p>The documentation for this class was generated from the following file <code>src/jac/machine/internal/</code></p>"},{"location":"doxygen/declarations_8h/","title":"File declarations.h","text":"<p>FileList &gt; internal &gt; declarations.h</p> <p>Go to the source code of this file</p>"},{"location":"doxygen/declarations_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac <p>The documentation for this class was generated from the following file <code>src/jac/machine/internal/declarations.h</code></p>"},{"location":"doxygen/declarations_8h_source/","title":"File declarations.h","text":"<p>File List &gt; internal &gt; declarations.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n\nnamespace jac {\n\n\ntemplate&lt;bool managed&gt;\nclass ValueWrapper;\ntemplate&lt;bool managed&gt;\nclass ObjectWrapper;\ntemplate&lt;bool managed&gt;\nclass ArrayWrapper;\ntemplate&lt;bool managed&gt;\nclass FunctionWrapper;\ntemplate&lt;bool managed&gt;\nclass PromiseWrapper;\ntemplate&lt;bool managed&gt;\nclass ExceptionWrapper;\ntemplate&lt;bool managed&gt;\nclass ArrayBufferWrapper;\n\n\nusing Value = ValueWrapper&lt;true&gt;;        // value/strong reference\nusing ValueWeak = ValueWrapper&lt;false&gt;;  // weak reference\n\nusing Object = ObjectWrapper&lt;true&gt;;\nusing ObjectWeak = ObjectWrapper&lt;false&gt;;\n\nusing Function = FunctionWrapper&lt;true&gt;;\nusing FunctionWeak = FunctionWrapper&lt;false&gt;;\n\nusing Array = ArrayWrapper&lt;true&gt;;\nusing ArrayWeak = ArrayWrapper&lt;false&gt;;\n\nusing Promise = PromiseWrapper&lt;true&gt;;\nusing PromiseWeak = PromiseWrapper&lt;false&gt;;\n\nusing Exception = ExceptionWrapper&lt;true&gt;;\nusing ExceptionWeak = ExceptionWrapper&lt;false&gt;;\n\nusing ArrayBuffer = ArrayBufferWrapper&lt;true&gt;;\nusing ArrayBufferWeak = ArrayBufferWrapper&lt;false&gt;;\n\n\n}  // namespace jac\n</code></pre>"},{"location":"doxygen/stringView_8h/","title":"File stringView.h","text":"<p>FileList &gt; jac &gt; machine &gt; stringView.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quickjs.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include \"context.h\"</code></li> </ul>"},{"location":"doxygen/stringView_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/stringView_8h/#classes","title":"Classes","text":"Type Name class StringView A wrapper around QuickJS C-string with automatic memory management. <p>The documentation for this class was generated from the following file <code>src/jac/machine/stringView.h</code></p>"},{"location":"doxygen/stringView_8h_source/","title":"File stringView.h","text":"<p>File List &gt; jac &gt; machine &gt; stringView.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;quickjs.h&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n\n#include \"context.h\"\n\n\nnamespace jac {\n\n\nclass StringView : public std::basic_string_view&lt;char&gt; {\n    using basic_string_view = std::basic_string_view&lt;char&gt;;\n\n    ContextRef _ctx = nullptr;\npublic:\n    StringView(StringView &amp;&amp;other) : basic_string_view(other), _ctx(other._ctx) {\n        other._ctx = nullptr;\n    }\n\n    StringView &amp;operator=(StringView &amp;&amp;other) {\n        if (_ctx) {\n            JS_FreeCString(_ctx, data());\n        }\n        basic_string_view::operator=(other);\n        _ctx = other._ctx;\n        other._ctx = nullptr;\n        return *this;\n    }\n\n    StringView(const basic_string_view &amp;other) = delete;\n    StringView(const StringView &amp;other) = delete;\n    StringView &amp;operator=(const StringView &amp;other) = delete;\n\n    const char* c_str() const {\n        return data();\n    }\n\n    StringView() = default;\n\n    StringView(ContextRef ctx, const char* str) : basic_string_view(str), _ctx(ctx) {}\n\n    ~StringView() {\n        if (_ctx) {\n            JS_FreeCString(_ctx, data());\n        }\n    }\n\n    operator std::string() const {\n        return std::string(data(), size());\n    }\n};\n\n\n}  // namespace jac\n</code></pre>"},{"location":"doxygen/traits_8h/","title":"File traits.h","text":"<p>FileList &gt; jac &gt; machine &gt; traits.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"context.h\"</code></li> <li><code>#include \"stringView.h\"</code></li> <li><code>#include \"values.h\"</code></li> </ul>"},{"location":"doxygen/traits_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac namespace detail"},{"location":"doxygen/traits_8h/#classes","title":"Classes","text":"Type Name struct ConvTraits &lt;typename T, typename En&gt; struct ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt; &lt;typename T&gt; struct ConvTraits&lt; bool &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>src/jac/machine/traits.h</code></p>"},{"location":"doxygen/traits_8h_source/","title":"File traits.h","text":"<p>File List &gt; jac &gt; machine &gt; traits.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#include \"context.h\"\n#include \"stringView.h\"\n#include \"values.h\"\n\n\nnamespace jac {\n\n\ntemplate&lt;typename T, typename En = T&gt;\nstruct ConvTraits {\n    static void from(ContextRef, ValueWeak) {\n        static_assert(sizeof(T) == 0, \"No conversion defined\");\n    }\n\n    static void to(ContextRef, T) {\n        static_assert(sizeof(T) == 0, \"No conversion defined\");\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;bool&gt; {\n    static bool from(ContextRef ctx, ValueWeak val) {\n        return JS_ToBool(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef ctx, bool val) {\n        return Value(ctx, JS_NewBool(ctx, val));\n    }\n};\n\nnamespace detail {\n\n    template&lt;typename T&gt;\n    constexpr bool is_leq_i32 = (std::is_signed_v&lt;T&gt; &amp;&amp; sizeof(T) &lt;= sizeof(int32_t))\n                             || (std::is_unsigned_v&lt;T&gt; &amp;&amp; sizeof(T) &lt; sizeof(int32_t));\n\n} // namespace detail\n\n\ntemplate&lt;typename T&gt;\nstruct ConvTraits&lt;T, std::enable_if_t&lt;\n       std::is_integral_v&lt;T&gt;\n    &amp;&amp; detail::is_leq_i32&lt;T&gt;\n, T&gt;&gt; {\n    static T from(ContextRef ctx, ValueWeak val) {\n        int32_t res;\n        int ex = JS_ToInt32(ctx, &amp;res, val.getVal());\n        if (ex &lt; 0) {\n            throw Exception::create(Exception::Type::TypeError, \"Failed to convert to int\");\n        }\n        return res;\n    }\n\n    static Value to(ContextRef ctx, T val) {\n        return Value(ctx, JS_NewInt32(ctx, val));\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct ConvTraits&lt;T, std::enable_if_t&lt;\n       std::is_floating_point_v&lt;T&gt;\n    &amp;&amp; sizeof(T) &lt;= sizeof(double)\n, T&gt;&gt; {\n    static T from(ContextRef ctx, ValueWeak val) {\n        double res;\n        int ex = JS_ToFloat64(ctx, &amp;res, val.getVal());\n        if (ex &lt; 0) {\n            throw Exception::create(Exception::Type::TypeError, \"Failed to convert to double\");\n        }\n        return res;\n    }\n\n    static Value to(ContextRef ctx, T val) {\n        return Value(ctx, JS_NewFloat64(ctx, val));\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct ConvTraits&lt;T, std::enable_if_t&lt;\n       std::is_integral_v&lt;T&gt;\n    &amp;&amp; sizeof(T) &lt;= sizeof(int64_t)\n    &amp;&amp; !detail::is_leq_i32&lt;T&gt;\n, T&gt;&gt; {\n    static T from(ContextRef ctx, ValueWeak val) {\n        int64_t res = 0;\n        int ex = JS_ToInt64(ctx, &amp;res, val.getVal());\n        if (ex &lt; 0) {\n            throw Exception::create(Exception::Type::TypeError, \"Failed to convert to int\");\n        }\n        return res;\n    }\n\n    static Value to(ContextRef ctx, T val) {\n        return Value(ctx, JS_NewInt64(ctx, val));\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;const char*&gt; {\n    static Value to(ContextRef ctx, const char* val) {\n        return Value(ctx, JS_NewString(ctx, val));\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;char*&gt; : public ConvTraits&lt;const char*&gt; {};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;StringView&gt; {\n    static StringView from(ContextRef ctx, ValueWeak val) {\n        const char* str = JS_ToCString(ctx, val.getVal());\n        if (!str) {\n            throw Exception::create(Exception::Type::TypeError, \"Failed to convert to string\");\n        }\n        return StringView(ctx, str);\n    }\n\n    static Value to(ContextRef ctx, StringView val) {\n        return ConvTraits&lt;const char*&gt;::to(ctx, val.c_str());\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;std::string&gt; {\n    static std::string from(ContextRef ctx, ValueWeak val) {\n        return std::string(ConvTraits&lt;StringView&gt;::from(ctx, val));\n    }\n\n    static Value to(ContextRef ctx, const std::string&amp; val) {\n        return ConvTraits&lt;const char*&gt;::to(ctx, val.c_str());\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;ValueWeak&gt; {\n    static ValueWeak from(ContextRef, ValueWeak val) {\n        return val;\n    }\n\n    static Value to(ContextRef ctx, ValueWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Value(ctx, val.getVal());\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;Value&gt; {\n    static Value from(ContextRef ctx, ValueWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Value(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef, Value val) {\n        return val;\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;ObjectWeak&gt; {\n    static ObjectWeak from(ContextRef ctx, ValueWeak val) {\n        return ObjectWeak(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef ctx, ObjectWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Value(ctx, val.getVal());\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;Object&gt; {\n    static Object from(ContextRef ctx, ValueWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Object(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef, Object val) {\n        return static_cast&lt;Value&gt;(val);\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;FunctionWeak&gt; {\n    static FunctionWeak from(ContextRef ctx, ValueWeak val) {\n        return FunctionWeak(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef ctx, FunctionWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Value(ctx, val.getVal());\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;Function&gt; {\n    static Function from(ContextRef ctx, ValueWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Function(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef, Function val) {\n        return static_cast&lt;Value&gt;(val);\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;ArrayWeak&gt; {\n    static ArrayWeak from(ContextRef ctx, ValueWeak val) {\n        return ArrayWeak(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef ctx, ArrayWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Value(ctx, val.getVal());\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;Array&gt; {\n    static Array from(ContextRef ctx, ValueWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Array(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef, Array val) {\n        return static_cast&lt;Value&gt;(val);\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;PromiseWeak&gt; {\n    static PromiseWeak from(ContextRef ctx, ValueWeak val) {\n        return PromiseWeak(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef ctx, PromiseWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Value(ctx, val.getVal());\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;Promise&gt; {\n    static Promise from(ContextRef ctx, ValueWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Promise(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef, Promise val) {\n        return static_cast&lt;Value&gt;(val);\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;ExceptionWeak&gt; {\n    static ExceptionWeak from(ContextRef ctx, ValueWeak val) {\n        return ExceptionWeak(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef ctx, ExceptionWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Value(ctx, val.getVal());\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;Exception&gt; {\n    static Exception from(ContextRef ctx, ValueWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Exception(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef, Exception val) {\n        return static_cast&lt;Value&gt;(val);\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;ArrayBuffer&gt; {\n    static ArrayBuffer from(ContextRef ctx, ValueWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return ArrayBuffer(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef, ArrayBuffer val) {\n        return static_cast&lt;Value&gt;(val);\n    }\n};\n\ntemplate&lt;&gt;\nstruct ConvTraits&lt;ArrayBufferWeak&gt; {\n    static ArrayBufferWeak from(ContextRef ctx, ValueWeak val) {\n        return ArrayBufferWeak(ctx, val.getVal());\n    }\n\n    static Value to(ContextRef ctx, ArrayBufferWeak val) {\n        JS_DupValue(ctx, val.getVal());\n        return Value(ctx, val.getVal());\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct ConvTraits&lt;std::vector&lt;T&gt;&gt; {\n    static std::vector&lt;T&gt; from(ContextRef, ValueWeak val) {\n        auto arr = val.to&lt;Array&gt;();\n        std::vector&lt;T&gt; res;\n        for (int i = 0; i &lt; arr.length(); i++) {\n            try {\n                res.push_back(arr.get(i).to&lt;T&gt;());\n            }\n            catch (Exception&amp; e) {\n                throw Exception::create(Exception::Type::TypeError, \"Failed to convert array element\");\n            }\n        }\n        return res;\n    }\n\n    static Value to(ContextRef ctx, const std::vector&lt;T&gt;&amp; val) {\n        Array arr = Array::create(ctx);\n        for (size_t i = 0; i &lt; val.size(); i++) {\n            arr.set(i, val[i]);\n        }\n        return arr;\n    }\n};\n\ntemplate&lt;typename... Args&gt;\nstruct ConvTraits&lt;std::tuple&lt;Args...&gt;&gt; {\n    template&lt;std::size_t... Is&gt;\n    static std::tuple&lt;Args...&gt; unwrapHelper(ContextRef, ValueWeak val, std::index_sequence&lt;Is...&gt;) {\n        auto arr = val.to&lt;Array&gt;();\n        if (arr.length() &lt; static_cast&lt;int&gt;(sizeof...(Args))) {\n            throw Exception::create(Exception::Type::TypeError, \"Tuple size mismatch\");\n        }\n        return std::make_tuple(arr.get&lt;Args&gt;(Is)...);\n    }\n\n    static std::tuple&lt;Args...&gt; from(ContextRef ctx, ValueWeak val) {\n        return unwrapHelper(ctx, val, std::index_sequence_for&lt;Args...&gt;{});\n    }\n\n    template&lt;std::size_t... Is&gt;\n    static Value wrapHelper(ContextRef ctx, const std::tuple&lt;Args...&gt;&amp; val, std::index_sequence&lt;Is...&gt;) {\n        Array arr = Array::create(ctx);\n        (arr.set(Is, std::get&lt;Is&gt;(val)), ...);\n        return arr;\n    }\n\n    static Value to(ContextRef ctx, std::tuple&lt;Args...&gt; val) {\n        return wrapHelper(ctx, val, std::index_sequence_for&lt;Args...&gt;{});\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/values_8h/","title":"File values.h","text":"<p>FileList &gt; jac &gt; machine &gt; values.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quickjs.h&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"atom.h\"</code></li> <li><code>#include \"context.h\"</code></li> <li><code>#include \"internal/declarations.h\"</code></li> <li><code>#include \"stringView.h\"</code></li> <li><code>#include \"traits.h\"</code></li> </ul>"},{"location":"doxygen/values_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/values_8h/#classes","title":"Classes","text":"Type Name class ArrayBufferWrapper &lt;managed&gt;A wrapper for JSValue with ArrayBuffer type with RAII. class ArrayWrapper &lt;managed&gt;A wrapper for JSValue with Array type with RAII. class ExceptionWrapper &lt;managed&gt;An exception wrapper which can either wrap a JSValue or contain an exception description and can be thrown into JS as a specific Error type. class FunctionWrapper &lt;managed&gt;A wrapper for JSValue with Function type with RAII. class ObjectWrapper &lt;managed&gt;A wrapper for JSValue with Object type with RAII. class PromiseWrapper &lt;managed&gt;A wrapper for JSValue with Promise type with RAII. class ValueWrapper &lt;managed&gt;A wrapper around JSValue with RAII. <p>The documentation for this class was generated from the following file <code>src/jac/machine/values.h</code></p>"},{"location":"doxygen/values_8h_source/","title":"File values.h","text":"<p>File List &gt; jac &gt; machine &gt; values.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;quickjs.h&gt;\n#include &lt;span&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\n#include \"atom.h\"\n#include \"context.h\"\n#include \"internal/declarations.h\"\n#include \"stringView.h\"\n\n\nnamespace jac {\n\n\nenum class PropFlags : int {\n    Default = 0,\n    Configurable = JS_PROP_CONFIGURABLE,\n    Writable = JS_PROP_WRITABLE,\n    Enumerable = JS_PROP_ENUMERABLE,\n    C_W_E = JS_PROP_C_W_E\n};\n\ninline constexpr PropFlags operator|(PropFlags a, PropFlags b) {\n    return static_cast&lt;PropFlags&gt;(static_cast&lt;int&gt;(a) | static_cast&lt;int&gt;(b));\n}\n\ninline constexpr PropFlags operator&amp;(PropFlags a, PropFlags b) {\n    return static_cast&lt;PropFlags&gt;(static_cast&lt;int&gt;(a) &amp; static_cast&lt;int&gt;(b));\n}\n\n\ntemplate&lt;typename T&gt;\nT fromValue(ContextRef ctx, ValueWeak val);\n\ntemplate&lt;typename T&gt;\nValue toValue(ContextRef ctx, T val);\n\n\ntemplate&lt;bool managed&gt;\nclass ValueWrapper {\nprotected:\n    ContextRef _ctx;\n    JSValue _val;\npublic:\n    ValueWrapper(ContextRef ctx, JSValue val);\n    ValueWrapper(const ValueWrapper &amp;other):\n        _ctx(other._ctx),\n        _val(managed ? JS_DupValue(_ctx, other._val) : other._val)\n    {}\n    ValueWrapper(ValueWrapper &amp;&amp;other) : _ctx(other._ctx), _val(other._val) {\n        other._ctx = nullptr;\n        other._val = JS_UNDEFINED;\n    }\n\n    ValueWrapper&amp; operator=(const ValueWrapper &amp;other) {\n        if (managed) {\n            if (_ctx) {\n                JS_FreeValue(_ctx, _val);\n            }\n            _val = JS_DupValue(_ctx, other._val);\n        }\n        else {\n            _val = other._val;\n        }\n        _ctx = other._ctx;\n        return *this;\n    }\n\n    ValueWrapper&amp; operator=(ValueWrapper &amp;&amp;other) {\n        if (managed &amp;&amp; _ctx) {\n            JS_FreeValue(_ctx, _val);\n        }\n        _val = other._val;\n        _ctx = other._ctx;\n        other._val = JS_UNDEFINED;\n        other._ctx = nullptr;\n        return *this;\n    }\n\n    operator ValueWeak() {\n        return ValueWeak(_ctx, _val);\n    }\n\n    ~ValueWrapper() {\n        if (managed &amp;&amp; _ctx) {\n            JS_FreeValue(_ctx, _val);\n        }\n    }\n\n    std::pair&lt;ContextRef, JSValue&gt; loot() {\n        JSValue ret_ = _val;\n        ContextRef ctx_ = this-&gt;_ctx;\n        _ctx = nullptr;\n        _val = JS_UNDEFINED;\n        return {ctx_, ret_};\n    }\n\n    JSValue&amp; getVal() {\n        return _val;\n    }\n\n    bool isUndefined() {\n        return JS_IsUndefined(_val);\n    }\n\n    bool isNull() {\n        return JS_IsNull(_val);\n    }\n\n    bool isObject() {\n        return JS_IsObject(_val);\n    }\n\n    bool isArray() {\n        return JS_IsArray(_ctx, _val);\n    }\n\n    bool isFunction() {\n        return JS_IsFunction(_ctx, _val);\n    }\n\n    StringView toString() {\n        return to&lt;StringView&gt;();\n    }\n\n    template&lt;typename T&gt;\n    T to() {\n        return fromValue&lt;T&gt;(_ctx, *this);\n    }\n\n    Value stringify(int indent = 0) {\n        auto idt = Value::from(_ctx, indent);\n        return Value(_ctx, JS_JSONStringify(_ctx, _val, JS_UNDEFINED, idt.getVal()));\n    }\n\n    template&lt;typename T&gt;\n    static Value from(ContextRef ctx, T val) {\n        return toValue(ctx, val);\n    }\n\n    static Value fromJSON(ContextRef ctx, std::string json, std::string filename = \"&lt;json&gt;\", bool extended = false) {\n        return Value(ctx, JS_ParseJSON2(ctx, json.c_str(), json.size(), filename.c_str(), extended ? JS_PARSE_JSON_EXT : 0));\n    }\n\n    static Value undefined(ContextRef ctx) {\n        return ValueWrapper(ctx, JS_UNDEFINED);\n    }\n\n    static Value null(ContextRef ctx) {\n        return ValueWrapper(ctx, JS_NULL);\n    }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ValueWrapper&amp; val) {\n        os &lt;&lt; val.toString();\n        return os;\n    }\n};\n\n\ntemplate&lt;bool managed&gt;\nclass ExceptionWrapper : public ValueWrapper&lt;managed&gt;, public std::exception {\npublic:\n    enum class Type {\n        Any,\n        Error,\n        SyntaxError,\n        TypeError,\n        ReferenceError,\n        RangeError,\n        InternalError\n    };\nprivate:\n    std::string _message;\n    Type _type;\n\n    ExceptionWrapper(Type type, std::string message) : ValueWrapper&lt;managed&gt;(nullptr, JS_UNDEFINED), _message(std::move(message)), _type(type) {}\nprotected:\n    using ValueWrapper&lt;managed&gt;::_val;\n    using ValueWrapper&lt;managed&gt;::_ctx;\npublic:\n    ExceptionWrapper(ValueWrapper&lt;managed&gt; value) : ValueWrapper&lt;managed&gt;(std::move(value)), _type(Type::Any) {\n        _message = this-&gt;toString();\n    }\n    ExceptionWrapper(ContextRef ctx, JSValue val) : ExceptionWrapper(ValueWrapper&lt;managed&gt;(ctx, val)) {}\n\n    std::string stackTrace() noexcept;\n\n    const char* what() const noexcept override {\n        return _message.c_str();\n    }\n\n    static Exception create(Type type, std::string message) {\n        return ExceptionWrapper(type, message);\n    }\n\n    JSValue throwJS(ContextRef ctx);\n};\n\n\ntemplate&lt;bool managed&gt;\nclass ObjectWrapper : public ValueWrapper&lt;managed&gt; {\nprotected:\n    using ValueWrapper&lt;managed&gt;::_val;\n    using ValueWrapper&lt;managed&gt;::_ctx;\npublic:\n    ObjectWrapper(ValueWrapper&lt;managed&gt; value) : ValueWrapper&lt;managed&gt;(std::move(value)) {\n        if (!this-&gt;isObject()) {\n            throw Exception::create(Exception::Type::TypeError, \"not an object\");\n        }\n    }\n    ObjectWrapper(ContextRef ctx, JSValue val) : ObjectWrapper(ValueWrapper&lt;managed&gt;(ctx, val)) {}\n\n    template&lt;typename T = Value&gt;\n    T get(Atom prop) {\n        Value val(_ctx, JS_GetProperty(_ctx, _val, prop.get()));\n        return val.to&lt;T&gt;();\n    }\n\n    template&lt;typename T = Value&gt;\n    T get(const std::string&amp; name) {\n        return get&lt;T&gt;(Atom::create(_ctx, name.c_str()));\n    }\n\n    template&lt;typename T = Value&gt;\n    T get(uint32_t idx) {\n        return get&lt;T&gt;(Atom::create(_ctx, idx));\n    }\n\n    template&lt;typename T&gt;\n    void set(Atom prop, T val) {\n        if (JS_SetProperty(_ctx, _val, prop.get(), toValue(_ctx, val).loot().second) &lt; 0) {\n            throw _ctx.getException();\n        }\n    }\n\n    template&lt;typename T&gt;\n    void set(const std::string&amp; name, T val) {\n        set(Atom::create(_ctx, name.c_str()), val);\n    }\n\n    template&lt;typename T&gt;\n    void set(uint32_t idx, T val) {\n        set(Atom::create(_ctx, idx), val);\n    }\n\n    template&lt;typename Res, typename... Args&gt;\n    Res invoke(Atom key, Args... args);\n\n    template&lt;typename Res, typename... Args&gt;\n    Res invoke(const std::string&amp; key, Args... args) {\n        return invoke&lt;Res&gt;(Atom::create(_ctx, key.c_str()), args...);\n    }\n\n    template&lt;typename Res, typename... Args&gt;\n    Res invoke(uint32_t idx, Args... args) {\n        return invoke&lt;Res&gt;(Atom::create(_ctx, idx), args...);\n    }\n\n    template&lt;typename Id&gt;\n    void defineProperty(Id id, Value value, PropFlags flags = PropFlags::Default) {\n        Atom atom = Atom::create(_ctx, id);\n        if (JS_DefinePropertyValue(_ctx, _val, atom.get(), value.loot().second, static_cast&lt;int&gt;(flags)) &lt; 0) {\n            throw _ctx.getException();\n        }\n    }\n\n    template&lt;typename Id&gt;\n    bool hasProperty(Id id) {\n        Atom atom = Atom::create(_ctx, id);\n        int res = JS_HasProperty(_ctx, _val, atom.get());\n        if (res &lt; 0) {\n            throw _ctx.getException();\n        }\n        return res;\n    }\n\n    template&lt;typename Id&gt;\n    void deleteProperty(Id id) {\n        Atom atom = Atom::create(_ctx, id);\n        if (JS_DeleteProperty(_ctx, _val, atom.get(), 0) &lt; 0) {\n            throw _ctx.getException();\n        }\n    }\n\n    Object getPrototype() {\n        return Object(_ctx, JS_GetPrototype(this-&gt;_ctx, this-&gt;_val));\n    }\n\n    void setPrototype(Object proto) {\n        if (JS_SetPrototype(this-&gt;_ctx, this-&gt;_val, proto.getVal()) &lt; 0) {\n            throw _ctx.getException();\n        }\n    }\n\n    static Object create(ContextRef ctx) {\n        return Object(ctx, JS_NewObject(ctx));\n    }\n};\n\n\ntemplate&lt;bool managed&gt;\nclass FunctionWrapper : public ObjectWrapper&lt;managed&gt; {\nprotected:\n    using ObjectWrapper&lt;managed&gt;::_val;\n    using ObjectWrapper&lt;managed&gt;::_ctx;\npublic:\n    FunctionWrapper(ObjectWrapper&lt;managed&gt; value) : ObjectWrapper&lt;managed&gt;(std::move(value)) {\n        if (!this-&gt;isFunction()) {\n            throw Exception::create(Exception::Type::TypeError, \"not a function\");\n        }\n    }\n    FunctionWrapper(ContextRef ctx, JSValue val) : FunctionWrapper(ObjectWrapper&lt;managed&gt;(ctx, val)) {}\n\n    template&lt;typename Res, typename... Args&gt;\n    Res callThis(Value thisVal, Args... args) {\n        std::vector&lt;JSValue&gt; vals;\n        vals.reserve(sizeof...(Args));\n        try {\n            (vals.push_back(toValue(_ctx, args).loot().second), ...);\n            Value ret(_ctx, JS_Call(_ctx, _val, thisVal.getVal(), vals.size(), vals.data()));\n\n            for (auto &amp;v : vals) {\n                JS_FreeValue(_ctx, v);\n            }\n            vals.clear();\n\n            return ret.to&lt;Res&gt;();\n        } catch (Exception &amp;e) {\n            for (auto &amp;v : vals) {\n                JS_FreeValue(_ctx, v);\n            }\n            throw e;\n        }\n    }\n\n    template&lt;typename Res, typename... Args&gt;\n    Res call(Args... args) {\n        return callThis&lt;Res&gt;(Value::undefined(_ctx), args...);\n    }\n\n    template&lt;typename... Args&gt;\n    Value callConstructor(Args... args) {\n        std::vector&lt;JSValue&gt; vals;\n        vals.reserve(sizeof...(Args));\n        try {\n            (vals.push_back(toValue(_ctx, args).loot().second), ...);\n            Value ret(_ctx, JS_CallConstructor(_ctx, _val, vals.size(), vals.data()));\n\n            for (auto &amp;v : vals) {\n                JS_FreeValue(_ctx, v);\n            }\n            vals.clear();\n\n            return ret;\n        } catch (Exception &amp;e) {\n            for (auto &amp;v : vals) {\n                JS_FreeValue(_ctx, v);\n            }\n            throw e;\n        }\n    }\n};\n\n\ntemplate&lt;bool managed&gt;\nclass ArrayWrapper : public ObjectWrapper&lt;managed&gt; {\nprotected:\n    using ObjectWrapper&lt;managed&gt;::_val;\n    using ObjectWrapper&lt;managed&gt;::_ctx;\npublic:\n    ArrayWrapper(ObjectWrapper&lt;managed&gt; value) : ObjectWrapper&lt;managed&gt;(std::move(value)) {\n        if (!this-&gt;isArray()) {\n            throw Exception::create(Exception::Type::TypeError, \"not an array\");\n        }\n    }\n    ArrayWrapper(ContextRef ctx, JSValue val) : ArrayWrapper(ObjectWrapper&lt;managed&gt;(ctx, val)) {}\n\n    int length() {\n        return this-&gt;template get&lt;int&gt;(\"length\");\n    }\n\n    static Array create(ContextRef ctx) {\n        return Array(ctx, JS_NewArray(ctx));\n    }\n};\n\n\ntemplate&lt;bool managed&gt;\nclass PromiseWrapper : public ObjectWrapper&lt;managed&gt; {\nprotected:\n    using ObjectWrapper&lt;managed&gt;::_val;\n    using ObjectWrapper&lt;managed&gt;::_ctx;\npublic:\n    PromiseWrapper(ObjectWrapper&lt;managed&gt; value) : ObjectWrapper&lt;managed&gt;(std::move(value)) {\n        // TODO: check if value is Promise\n        // not implemented, because a convenient check is not a part of QuickJS API\n        // different type being converted to promise may cause hard to find errors\n    }\n    PromiseWrapper(ContextRef ctx, JSValue val) : PromiseWrapper(ObjectWrapper&lt;managed&gt;(ctx, val)) {}\n\n    static std::tuple&lt;Promise, Function, Function&gt; create(ContextRef ctx) {\n        JSValue functions[2];\n        JSValue promise = JS_NewPromiseCapability(ctx, functions);\n        return std::make_tuple(Promise(ctx, promise), Function(ctx, functions[0]), Function(ctx, functions[1]));\n    }\n};\n\n\ntemplate&lt;bool managed&gt;\nclass ArrayBufferWrapper : public ObjectWrapper&lt;managed&gt; {\nprotected:\n    using ObjectWrapper&lt;managed&gt;::_val;\n    using ObjectWrapper&lt;managed&gt;::_ctx;\n\n    static void freeArrayBuffer(JSRuntime*, void*, void *ptr) {\n        delete[] static_cast&lt;uint8_t*&gt;(ptr);\n    }\npublic:\n    ArrayBufferWrapper(ObjectWrapper&lt;managed&gt; value) : ObjectWrapper&lt;managed&gt;(std::move(value)) {\n        // TODO: check if value is ArrayBuffer\n        // not implemented, because a convenient check is not a part of QuickJS API\n        // different type being converted to promise may cause hard to find errors\n        // methods of ArrayBufferWrapper will throw exceptions if the type is not ArrayBuffer\n    }\n    ArrayBufferWrapper(ContextRef ctx, JSValue val) : ArrayBufferWrapper(ObjectWrapper&lt;managed&gt;(ctx, val)) {}\n\n    uint8_t* data() {\n        return static_cast&lt;uint8_t*&gt;(JS_GetArrayBuffer(_ctx, nullptr, _val));\n    }\n\n    size_t size() {\n        size_t size;\n        JS_GetArrayBuffer(_ctx, &amp;size, _val);\n        return size;\n    }\n\n    template&lt;typename T&gt;\n    std::span&lt;T&gt; typedView() {\n        if (size() % sizeof(T) != 0) {\n            throw Exception::create(Exception::Type::TypeError, \"size is not a multiple of the element size\");\n        }\n        size_t size;\n        T* ptr = static_cast&lt;T*&gt;(JS_GetArrayBuffer(_ctx, &amp;size, _val));\n        return std::span&lt;T&gt;(ptr, size / sizeof(T));\n    }\n\n    static ArrayBuffer create(ContextRef ctx, size_t size) {\n        return ArrayBuffer(ctx, JS_NewArrayBuffer(ctx, new uint8_t[size]{}, size, freeArrayBuffer, nullptr, false));\n    }\n\n    static ArrayBuffer create(ContextRef ctx, std::span&lt;const uint8_t&gt; data) {\n        return ArrayBuffer(ctx, JS_NewArrayBufferCopy(ctx, data.data(), data.size()));\n    }\n};\n\ntemplate&lt;bool managed&gt;\nValueWrapper&lt;managed&gt;::ValueWrapper(ContextRef ctx, JSValue val) : _ctx(ctx), _val(val) {\n    if (JS_IsException(_val)) {\n        throw ctx.getException();\n    }\n}\n\ntemplate&lt;bool managed&gt;\ntemplate&lt;typename Res, typename... Args&gt;\nRes ObjectWrapper&lt;managed&gt;::invoke(Atom key, Args... args) {\n    return get&lt;Function&gt;(key).template callThis&lt;Res&gt;(*this, args...);\n};\n\n\ntemplate&lt;bool managed&gt;\nstd::string ExceptionWrapper&lt;managed&gt;::stackTrace() noexcept {\n    try {\n        ObjectWeak obj(*this);\n        return obj.get(\"stack\").toString();\n    } catch (std::exception &amp;e) {\n        return \"failed to get stack trace: \" + std::string(e.what());\n    }\n}\n\n\ntemplate&lt;bool managed&gt;\nJSValue ExceptionWrapper&lt;managed&gt;::throwJS(ContextRef ctx) {\n    if (_type == Type::Any) {\n        auto [_, val] = ValueWrapper&lt;managed&gt;::loot();\n        return JS_Throw(ctx, val);\n    }\n\n\n    if (_type == Type::Error) {\n        ObjectWeak errObj(ctx, JS_NewError(ctx));\n        errObj.set(\"message\", _message);\n\n        return JS_Throw(ctx, errObj.getVal());\n    }\n\n    switch (_type) {\n        case Type::SyntaxError:\n            return JS_ThrowSyntaxError(ctx, \"%s\", _message.c_str());\n        case Type::TypeError:\n            return JS_ThrowTypeError(ctx, \"%s\", _message.c_str());\n        case Type::ReferenceError:\n            return JS_ThrowReferenceError(ctx, \"%s\", _message.c_str());\n        case Type::RangeError:\n            return JS_ThrowRangeError(ctx, \"%s\", _message.c_str());\n        case Type::InternalError:\n            return JS_ThrowInternalError(ctx, \"%s\", _message.c_str());\n        default:\n            return JS_Throw(ctx, JS_NewError(ctx));\n    }\n}\n\n\n} // namespace jac\n\n\n#include \"traits.h\"\n\n\nnamespace jac {\n\n\ntemplate&lt;typename T&gt;\nT fromValue([[maybe_unused]] ContextRef ctx, [[maybe_unused]] ValueWeak val) {\n    if constexpr (std::is_same_v&lt;T, void&gt;) {\n        return;\n    }\n    else {\n        return ConvTraits&lt;T&gt;::from(ctx, val);\n    }\n}\n\ntemplate&lt;typename T&gt;\nValue toValue([[maybe_unused]] ContextRef ctx, [[maybe_unused]] T value) {\n    if constexpr (std::is_same_v&lt;T, void&gt;) {\n        return Value::undefined(ctx);\n    }\n\n    auto val = ConvTraits&lt;T&gt;::to(ctx, value);\n\n    return val;\n}\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace jac <ul> <li>namespace ProtoBuilder </li> <li>namespace detail </li> </ul> </li> <li>namespace noal </li> <li>namespace std </li> </ul>"},{"location":"doxygen/classes/","title":"Class Index","text":""},{"location":"doxygen/classes/#a","title":"a","text":"<ul> <li>ArrayBufferWrapper (jac)</li> <li>ArrayWrapper (jac)</li> <li>Atom (jac)</li> </ul>"},{"location":"doxygen/classes/#b","title":"b","text":"<ul> <li>BasicStreamFeature (jac)</li> </ul>"},{"location":"doxygen/classes/#c","title":"c","text":"<ul> <li>Callable (jac::ProtoBuilder)</li> <li>callableany (noal)</li> <li>callableany&lt; Func, Res(Args...)&gt; (noal)</li> <li>check (jac::detail::is_base_of_template_impl)</li> <li>check&lt; A, std::void_t&lt; A&lt; Derived &gt; &gt; &gt; (jac::detail::is_base_of_template_impl)</li> <li>Class (jac)</li> <li>CompareTimer</li> <li>ComposeMachine (jac)</li> <li>ComposeMachine&lt; Base &gt; (jac)</li> <li>ComposeMachine&lt; Base, FirstFeature, MFeatures... &gt; (jac)</li> <li>ContextRef (jac)</li> <li>ConvTraits (jac)</li> <li>ConvTraits&lt; bool &gt; (jac)</li> <li>ConvTraits&lt; std::chrono::milliseconds &gt; (jac)</li> <li>ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt; (jac)</li> </ul>"},{"location":"doxygen/classes/#e","title":"e","text":"<ul> <li>EventLoopFeature (jac)</li> <li>EventLoopTerminal (jac)</li> <li>EventQueueFeature (jac)</li> <li>ExceptionWrapper (jac)</li> </ul>"},{"location":"doxygen/classes/#f","title":"f","text":"<ul> <li>File (jac)</li> <li>FileProtoBuilder (jac)</li> <li>FilesystemFeature (jac)</li> <li>Fs</li> <li>funcptr (noal)</li> <li>function (noal)</li> <li>function&lt; Res(Args...), dataSize &gt; (noal)</li> <li>FunctionFactory (jac)</li> <li>FunctionWrapper (jac)</li> </ul>"},{"location":"doxygen/classes/#i","title":"i","text":"<ul> <li>is_base_of_template (jac)</li> <li>is_base_of_template_impl (jac::detail)</li> </ul>"},{"location":"doxygen/classes/#l","title":"l","text":"<ul> <li>LifetimeHandles (jac::ProtoBuilder)</li> </ul>"},{"location":"doxygen/classes/#m","title":"m","text":"<ul> <li>MachineBase (jac)</li> <li>memberconstfuncptr (noal)</li> <li>memberfuncptr (noal)</li> <li>Module (jac)</li> <li>ModuleLoaderFeature (jac)</li> </ul>"},{"location":"doxygen/classes/#o","title":"o","text":"<ul> <li>ObjectWrapper (jac)</li> <li>Opaque (jac::ProtoBuilder)</li> <li>OsWritable (jac)</li> </ul>"},{"location":"doxygen/classes/#p","title":"p","text":"<ul> <li>Path (jac::FilesystemFeature)</li> <li>Plugin (jac)</li> <li>PluginHandle (jac)</li> <li>PluginHolderFeature (jac)</li> <li>PluginManager (jac)</li> <li>PromiseWrapper (jac)</li> <li>Properties (jac::ProtoBuilder)</li> </ul>"},{"location":"doxygen/classes/#r","title":"r","text":"<ul> <li>Readable (jac)</li> <li>ReadableProtoBuilder (jac)</li> <li>ReadableRef (jac)</li> </ul>"},{"location":"doxygen/classes/#s","title":"s","text":"<ul> <li>SgnUnwrap (jac)</li> <li>SgnUnwrap&lt; Res(Args...)&gt; (jac)</li> <li>signatureHelper (noal)</li> <li>signatureHelper&lt; Res(Func::*)(Args...) &amp; &gt; (noal)</li> <li>signatureHelper&lt; Res(Func::*)(Args...) const &amp; &gt; (noal)</li> <li>signatureHelper&lt; Res(Func::*)(Args...) const &gt; (noal)</li> <li>signatureHelper&lt; Res(Func::*)(Args...)&gt; (noal)</li> <li>Stdio</li> <li>StdioFeature (jac)</li> <li>StringView (jac)</li> </ul>"},{"location":"doxygen/classes/#t","title":"t","text":"<ul> <li>Timer</li> <li>TimersFeature (jac)</li> </ul>"},{"location":"doxygen/classes/#v","title":"v","text":"<ul> <li>ValueWrapper (jac)</li> </ul>"},{"location":"doxygen/classes/#w","title":"w","text":"<ul> <li>Writable (jac)</li> <li>WritableProtoBuilder (jac)</li> <li>WritableRef (jac)</li> </ul>"},{"location":"doxygen/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class jac::ValueWrapper A wrapper around JSValue with RAII. <ul> <li>class jac::ExceptionWrapper An exception wrapper which can either wrap a JSValue or contain an exception description and can be thrown into JS as a specific Error type. </li> <li>class jac::ObjectWrapper A wrapper for JSValue with Object type with RAII. <ul> <li>class jac::ArrayBufferWrapper A wrapper for JSValue with ArrayBuffer type with RAII. </li> <li>class jac::ArrayWrapper A wrapper for JSValue with Array type with RAII. </li> <li>class jac::FunctionWrapper A wrapper for JSValue with Function type with RAII. </li> <li>class jac::PromiseWrapper A wrapper for JSValue with Promise type with RAII. </li> </ul> </li> </ul> </li> <li>class jac::Atom A wrapper around JSAtom with RAII. In the context of QuickJS, Atom is used to represent identifiers of properties, variables, functions, etc.</li> <li>class jac::Class </li> <li>class jac::ContextRef A wrapper around JSContext* providing some related functionality. </li> <li>class jac::File </li> <li>class jac::FilesystemFeature::Path </li> <li>class jac::FunctionFactory Various methods for wrapping C++ functions into javascript functions. </li> <li>class jac::MachineBase </li> <li>class jac::Module A wrapper around JSModuleDef that allows for easy exporting of values. </li> <li>class jac::Writable <ul> <li>class jac::OsWritable </li> <li>class jac::WritableRef </li> </ul> </li> <li>class jac::Plugin A base class for all plugins. </li> <li>class jac::PluginHandle A handle which can be used to retrieve a plugin from a machine. </li> <li>class jac::PluginManager A class for managing groups of plugins and initializing them all at once. </li> <li>class jac::Readable <ul> <li>class jac::ReadableRef </li> </ul> </li> <li>class jac::FilesystemFeature::Fs </li> <li>class jac::StdioFeature::Stdio </li> <li>class jac::TimersFeature::CompareTimer </li> <li>class jac::TimersFeature::Timer </li> <li>class noal::callableany </li> <li>class noal::callableany&lt; Func, Res(Args...)&gt; </li> <li>class noal::funcptr </li> <li>class noal::function </li> <li>class noal::function&lt; Res(Args...), dataSize &gt; </li> <li>class noal::memberconstfuncptr </li> <li>class noal::memberfuncptr </li> <li>struct jac::ComposeMachine </li> <li>struct jac::ConvTraits </li> <li>struct jac::ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt; </li> <li>struct jac::ConvTraits&lt; bool &gt; </li> <li>struct jac::ConvTraits&lt; std::chrono::milliseconds &gt; </li> <li>struct jac::ProtoBuilder::Opaque A base class for javascript classes with opaque data. </li> <li>struct jac::ProtoBuilder::Properties A base class for javascript classes with added properties. <ul> <li>struct jac::FileProtoBuilder </li> <li>struct jac::ReadableProtoBuilder </li> <li>struct jac::WritableProtoBuilder </li> </ul> </li> <li>struct jac::ProtoBuilder::Callable A base class for javascript classes with callable instances. </li> <li>struct jac::ProtoBuilder::LifetimeHandles A base class used to add handles for lifetime events of an instance. </li> <li>struct jac::SgnUnwrap </li> <li>struct jac::SgnUnwrap&lt; Res(Args...)&gt; </li> <li>struct jac::detail::is_base_of_template_impl </li> <li>struct noal::signatureHelper </li> <li>struct noal::signatureHelper&lt; Res(Func::*)(Args...) &amp; &gt; </li> <li>struct noal::signatureHelper&lt; Res(Func::*)(Args...) const &amp; &gt; </li> <li>struct noal::signatureHelper&lt; Res(Func::*)(Args...) const &gt; </li> <li>struct noal::signatureHelper&lt; Res(Func::*)(Args...)&gt; </li> <li>class Next <ul> <li>class jac::BasicStreamFeature </li> <li>class jac::EventLoopFeature </li> <li>class jac::EventLoopTerminal </li> <li>class jac::EventQueueFeature </li> <li>class jac::FilesystemFeature </li> <li>class jac::ModuleLoaderFeature </li> <li>class jac::PluginHolderFeature An MFeature that allows for inserting plugins into the machine and retrieving them using PluginHandeles. </li> <li>class jac::StdioFeature </li> <li>class jac::TimersFeature </li> </ul> </li> <li>class std::exception <ul> <li>class jac::ExceptionWrapper An exception wrapper which can either wrap a JSValue or contain an exception description and can be thrown into JS as a specific Error type. </li> </ul> </li> <li>class std::basic_string_view&lt; char &gt; <ul> <li>class jac::StringView A wrapper around QuickJS C-string with automatic memory management. </li> </ul> </li> <li>class Base <ul> <li>struct jac::ComposeMachine&lt; Base &gt; </li> </ul> </li> <li>class std::false_type <ul> <li>struct jac::detail::is_base_of_template_impl::check <ul> <li>struct jac::is_base_of_template Checks if a type is derived from a template class. </li> </ul> </li> <li>struct jac::detail::is_base_of_template_impl::check <ul> <li>struct jac::is_base_of_template Checks if a type is derived from a template class. </li> </ul> </li> </ul> </li> <li>class std::true_type <ul> <li>struct jac::detail::is_base_of_template_impl::check&lt; A, std::void_t&lt; A&lt; Derived &gt; &gt; &gt; </li> </ul> </li> </ul>"},{"location":"doxygen/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"doxygen/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"doxygen/class_members/","title":"Class Members","text":""},{"location":"doxygen/class_members/#a","title":"a","text":"<ul> <li>ArrayBufferWrapper (jac::ArrayBufferWrapper)</li> <li>ArrayWrapper (jac::ArrayWrapper)</li> <li>Atom (jac::Atom)</li> <li>addProperties (jac::FileProtoBuilder, jac::ProtoBuilder::Properties, jac::ReadableProtoBuilder, jac::WritableProtoBuilder)</li> <li>addExport (jac::Module)</li> <li>addPlugin (jac::PluginManager)</li> <li>addMethodMember (jac::ProtoBuilder::Opaque)</li> <li>addPropMember (jac::ProtoBuilder::Opaque)</li> <li>ArgTypes (jac::SgnUnwrap&lt; Res(Args...)&gt;)</li> </ul>"},{"location":"doxygen/class_members/#b","title":"b","text":"<ul> <li>BasicStreamFeature (jac::BasicStreamFeature)</li> <li>basename (jac::FilesystemFeature::Path)</li> <li>base (jac::Module)</li> <li>basic_string_view (jac::StringView)</li> </ul>"},{"location":"doxygen/class_members/#c","title":"c","text":"<ul> <li>create (jac::ArrayBufferWrapper, jac::ArrayWrapper, jac::Atom, jac::ExceptionWrapper, jac::ObjectWrapper, jac::PromiseWrapper)</li> <li>classDef (jac::Class)</li> <li>classId (jac::Class, jac::ProtoBuilder::Opaque)</li> <li>className (jac::Class)</li> <li>constructor_impl (jac::Class)</li> <li>createInstance (jac::Class)</li> <li>ContextRef (jac::ContextRef)</li> <li>close (jac::File)</li> <li>call (jac::FunctionWrapper, noal::callableany&lt; Func, Res(Args...)&gt;, noal::funcptr, noal::function&lt; Res(Args...), dataSize &gt;, noal::memberconstfuncptr, noal::memberfuncptr)</li> <li>callConstructor (jac::FunctionWrapper, jac::ProtoBuilder::Callable)</li> <li>callThis (jac::FunctionWrapper)</li> <li>context (jac::MachineBase)</li> <li>callFunction (jac::ProtoBuilder::Callable)</li> <li>callMember (jac::ProtoBuilder::Opaque)</li> <li>constructOpaque (jac::ProtoBuilder::Opaque)</li> <li>c_str (jac::StringView)</li> <li>clearInterval (jac::TimersFeature)</li> <li>clearTimeout (jac::TimersFeature)</li> <li>clearTimer (jac::TimersFeature)</li> <li>createTimer (jac::TimersFeature)</li> <li>cancel (jac::TimersFeature::Timer)</li> <li>cancelled (jac::TimersFeature::Timer)</li> <li>callableany (noal::callableany&lt; Func, Res(Args...)&gt;)</li> </ul>"},{"location":"doxygen/class_members/#d","title":"d","text":"<ul> <li>data (jac::ArrayBufferWrapper, noal::function&lt; Res(Args...), dataSize &gt;)</li> <li>dirname (jac::FilesystemFeature::Path)</li> <li>defineProperty (jac::ObjectWrapper)</li> <li>deleteProperty (jac::ObjectWrapper)</li> <li>destroyOpaque (jac::ProtoBuilder::Opaque)</li> </ul>"},{"location":"doxygen/class_members/#e","title":"e","text":"<ul> <li>evalModuleWithEventLoop (jac::EventLoopFeature)</li> <li>evalWithEventLoopCommon (jac::EventLoopFeature)</li> <li>exit (jac::EventLoopFeature)</li> <li>ExceptionWrapper (jac::ExceptionWrapper)</li> <li>eval (jac::MachineBase)</li> <li>exports (jac::Module)</li> <li>evalFile (jac::ModuleLoaderFeature)</li> <li>evalFileWithEventLoop (jac::ModuleLoaderFeature)</li> <li>exists (jac::FilesystemFeature::Fs)</li> <li>err (jac::StdioFeature::Stdio)</li> </ul>"},{"location":"doxygen/class_members/#f","title":"f","text":"<ul> <li>freeArrayBuffer (jac::ArrayBufferWrapper)</li> <li>from (jac::ConvTraits, jac::ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt;, jac::ConvTraits&lt; bool &gt;, jac::ConvTraits&lt; std::chrono::milliseconds &gt;, jac::ValueWrapper)</li> <li>File (jac::File)</li> <li>FileClass (jac::FilesystemFeature)</li> <li>FilesystemFeature (jac::FilesystemFeature)</li> <li>fs (jac::FilesystemFeature)</li> <li>FunctionFactory (jac::FunctionFactory)</li> <li>FunctionWrapper (jac::FunctionWrapper)</li> <li>findModule (jac::MachineBase)</li> <li>fromJSON (jac::ValueWrapper)</li> <li>Fs (jac::FilesystemFeature::Fs)</li> <li>func (noal::callableany&lt; Func, Res(Args...)&gt;)</li> <li>funcptr (noal::funcptr)</li> <li>function (noal::function&lt; Res(Args...), dataSize &gt;)</li> </ul>"},{"location":"doxygen/class_members/#g","title":"g","text":"<ul> <li>get (jac::Atom, jac::ContextRef, jac::Module, jac::ObjectWrapper, jac::Readable, jac::ReadableRef)</li> <li>getClassId (jac::Class)</li> <li>getConstructor (jac::Class)</li> <li>getProto (jac::Class)</li> <li>getException (jac::ContextRef)</li> <li>getGlobalObject (jac::ContextRef)</li> <li>getExitCode (jac::EventLoopFeature)</li> <li>getEvent (jac::EventQueueFeature)</li> <li>getPrototype (jac::ObjectWrapper)</li> <li>getPlugin (jac::PluginHolderFeature)</li> <li>getOpaque (jac::ProtoBuilder::Opaque)</li> <li>getVal (jac::ValueWrapper)</li> <li>getCallback (jac::TimersFeature::Timer)</li> <li>getEndTime (jac::TimersFeature::Timer)</li> <li>getId (jac::TimersFeature::Timer)</li> </ul>"},{"location":"doxygen/class_members/#h","title":"h","text":"<ul> <li>hasProperty (jac::ObjectWrapper)</li> <li>holdPlugin (jac::PluginHolderFeature)</li> </ul>"},{"location":"doxygen/class_members/#i","title":"i","text":"<ul> <li>initialize (jac::BasicStreamFeature, jac::EventLoopFeature, jac::FilesystemFeature, jac::MachineBase, jac::ModuleLoaderFeature, jac::PluginManager, jac::StdioFeature, jac::TimersFeature)</li> <li>init (jac::Class)</li> <li>initContext (jac::Class)</li> <li>isConstructor (jac::Class)</li> <li>isOpen (jac::File)</li> <li>interruptRuntime (jac::MachineBase)</li> <li>invoke (jac::ObjectWrapper)</li> <li>index (jac::PluginHandle)</li> <li>isArray (jac::ValueWrapper)</li> <li>isFunction (jac::ValueWrapper)</li> <li>isNull (jac::ValueWrapper)</li> <li>isObject (jac::ValueWrapper)</li> <li>isUndefined (jac::ValueWrapper)</li> <li>is_callable (jac::detail::is_base_of_template_impl)</li> <li>is_callable_t (jac::detail::is_base_of_template_impl)</li> <li>isDirectory (jac::FilesystemFeature::Fs)</li> <li>isFile (jac::FilesystemFeature::Fs)</li> <li>in (jac::StdioFeature::Stdio)</li> <li>isCancelled (jac::TimersFeature::Timer)</li> <li>isRepeating (jac::TimersFeature::Timer)</li> </ul>"},{"location":"doxygen/class_members/#j","title":"j","text":"<ul> <li>join (jac::FilesystemFeature::Path)</li> </ul>"},{"location":"doxygen/class_members/#k","title":"k","text":"<ul> <li>kill (jac::EventLoopFeature)</li> </ul>"},{"location":"doxygen/class_members/#l","title":"l","text":"<ul> <li>length (jac::ArrayWrapper)</li> <li>loot (jac::Atom, jac::ValueWrapper)</li> <li>loadCode (jac::FilesystemFeature::Fs)</li> </ul>"},{"location":"doxygen/class_members/#m","title":"m","text":"<ul> <li>MachineBase (jac::MachineBase)</li> <li>Module (jac::Module)</li> <li>moduleLoaderCbk (jac::ModuleLoaderFeature)</li> <li>mkdir (jac::FilesystemFeature::Fs)</li> <li>memberconstfuncptr (noal::memberconstfuncptr)</li> <li>memberfuncptr (noal::memberfuncptr)</li> </ul>"},{"location":"doxygen/class_members/#n","title":"n","text":"<ul> <li>notifyEventLoop (jac::EventQueueFeature)</li> <li>normalize (jac::FilesystemFeature::Path)</li> <li>newFunction (jac::FunctionFactory)</li> <li>newFunctionHelper (jac::FunctionFactory)</li> <li>newFunctionThis (jac::FunctionFactory)</li> <li>newFunctionThisHelper (jac::FunctionFactory)</li> <li>newFunctionThisVariadic (jac::FunctionFactory)</li> <li>newFunctionThisVariadicHelper (jac::FunctionFactory)</li> <li>newFunctionVariadic (jac::FunctionFactory)</li> <li>newFunctionVariadicHelper (jac::FunctionFactory)</li> <li>newModule (jac::MachineBase)</li> <li>nextId (jac::TimersFeature)</li> <li>null (jac::ValueWrapper)</li> </ul>"},{"location":"doxygen/class_members/#o","title":"o","text":"<ul> <li>operator= (jac::Atom, jac::ContextRef, jac::MachineBase, jac::Module, jac::StringView, jac::ValueWrapper, noal::function&lt; Res(Args...), dataSize &gt;)</li> <li>operator JSContext * (jac::ContextRef)</li> <li>operator bool (jac::ContextRef, noal::function&lt; Res(Args...), dataSize &gt;)</li> <li>onEventLoop (jac::EventLoopFeature)</li> <li>ObjectWrapper (jac::ObjectWrapper)</li> <li>OsWritable (jac::OsWritable)</li> <li>operator+ (jac::PluginHandle)</li> <li>operator++ (jac::PluginHandle)</li> <li>operator== (jac::PluginHandle)</li> <li>OpaqueType (jac::ProtoBuilder::Opaque)</li> <li>operator ValueWeak (jac::ValueWrapper)</li> <li>open (jac::FilesystemFeature::Fs)</li> <li>out (jac::StdioFeature::Stdio)</li> <li>operator() (jac::TimersFeature::CompareTimer, noal::callableany&lt; Func, Res(Args...)&gt;, noal::funcptr, noal::function&lt; Res(Args...), dataSize &gt;, noal::memberconstfuncptr, noal::memberfuncptr)</li> <li>operator&lt; (jac::TimersFeature::Timer)</li> </ul>"},{"location":"doxygen/class_members/#p","title":"p","text":"<ul> <li>path_ (jac::File)</li> <li>Path (jac::FilesystemFeature::Path)</li> <li>path (jac::FilesystemFeature)</li> <li>PluginHandle (jac::PluginHandle)</li> <li>PluginHolderFeature (jac::PluginHolderFeature)</li> <li>pluginBegin (jac::PluginHolderFeature)</li> <li>pluginEnd (jac::PluginHolderFeature)</li> <li>PluginManager (jac::PluginManager)</li> <li>PromiseWrapper (jac::PromiseWrapper)</li> <li>postConstruction (jac::ProtoBuilder::LifetimeHandles)</li> </ul>"},{"location":"doxygen/class_members/#r","title":"r","text":"<ul> <li>ReadableClass (jac::BasicStreamFeature)</li> <li>runEventLoop (jac::EventLoopFeature)</li> <li>runOnEventLoop (jac::EventLoopFeature, jac::EventLoopTerminal)</li> <li>read (jac::File, jac::Readable, jac::ReadableRef)</li> <li>resetWatchdog (jac::MachineBase)</li> <li>runtime (jac::MachineBase)</li> <li>ReadableRef (jac::ReadableRef)</li> <li>ResType (jac::SgnUnwrap&lt; Res(Args...)&gt;)</li> <li>readdir (jac::FilesystemFeature::Fs)</li> <li>rm (jac::FilesystemFeature::Fs)</li> <li>rmdir (jac::FilesystemFeature::Fs)</li> </ul>"},{"location":"doxygen/class_members/#s","title":"s","text":"<ul> <li>size (jac::ArrayBufferWrapper)</li> <li>scheduleEvent (jac::EventQueueFeature)</li> <li>stackTrace (jac::ExceptionWrapper)</li> <li>setCodeDir (jac::FilesystemFeature)</li> <li>setWorkingDir (jac::FilesystemFeature)</li> <li>setWatchdogHandler (jac::MachineBase)</li> <li>setWatchdogTimeout (jac::MachineBase)</li> <li>set (jac::ObjectWrapper)</li> <li>setPrototype (jac::ObjectWrapper)</li> <li>SgnUnwrap (jac::SgnUnwrap&lt; Res(Args...)&gt;)</li> <li>stdio (jac::StdioFeature)</li> <li>StringView (jac::StringView)</li> <li>string (jac::StringView)</li> <li>setInterval (jac::TimersFeature)</li> <li>setTimeout (jac::TimersFeature)</li> <li>stringify (jac::ValueWrapper)</li> <li>Sign (noal::function&lt; Res(Args...), dataSize &gt;)</li> </ul>"},{"location":"doxygen/class_members/#t","title":"t","text":"<ul> <li>typedView (jac::ArrayBufferWrapper)</li> <li>toString (jac::Atom, jac::ValueWrapper)</li> <li>to (jac::ConvTraits, jac::ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt;, jac::ConvTraits&lt; bool &gt;, jac::ConvTraits&lt; std::chrono::milliseconds &gt;, jac::ValueWrapper)</li> <li>Type (jac::ExceptionWrapper)</li> <li>throwJS (jac::ExceptionWrapper)</li> <li>Timer (jac::TimersFeature::Timer)</li> <li>type (noal::signatureHelper&lt; Res(Func::*)(Args...) &amp; &gt;, noal::signatureHelper&lt; Res(Func::*)(Args...) const &amp; &gt;, noal::signatureHelper&lt; Res(Func::*)(Args...) const &gt;, noal::signatureHelper&lt; Res(Func::*)(Args...)&gt;)</li> </ul>"},{"location":"doxygen/class_members/#u","title":"u","text":"<ul> <li>undefined (jac::ValueWrapper)</li> <li>update (jac::TimersFeature::Timer)</li> </ul>"},{"location":"doxygen/class_members/#v","title":"v","text":"<ul> <li>ValueWrapper (jac::ValueWrapper)</li> <li>value_t (jac::detail::is_base_of_template_impl)</li> </ul>"},{"location":"doxygen/class_members/#w","title":"w","text":"<ul> <li>WritableClass (jac::BasicStreamFeature)</li> <li>what (jac::ExceptionWrapper)</li> <li>write (jac::File, jac::OsWritable, jac::Writable, jac::WritableRef)</li> <li>WritableRef (jac::WritableRef)</li> </ul>"},{"location":"doxygen/class_members/#_1","title":"~","text":"<ul> <li>~Atom (jac::Atom)</li> <li>~EventQueueFeature (jac::EventQueueFeature)</li> <li>~File (jac::File)</li> <li>~MachineBase (jac::MachineBase)</li> <li>~Plugin (jac::Plugin)</li> <li>~Readable (jac::Readable)</li> <li>~StringView (jac::StringView)</li> <li>~TimersFeature (jac::TimersFeature)</li> <li>~ValueWrapper (jac::ValueWrapper)</li> <li>~Writable (jac::Writable)</li> </ul>"},{"location":"doxygen/class_members/#_","title":"_","text":"<ul> <li>_atom (jac::Atom)</li> <li>_ctx (jac::Atom, jac::ContextRef, jac::Module, jac::StringView, jac::ValueWrapper)</li> <li>_error (jac::EventLoopFeature)</li> <li>_exitCode (jac::EventLoopFeature)</li> <li>_shouldExit (jac::EventLoopFeature)</li> <li>_scheduledFunctions (jac::EventQueueFeature)</li> <li>_scheduledFunctionsCondition (jac::EventQueueFeature)</li> <li>_scheduledFunctionsMutex (jac::EventQueueFeature)</li> <li>_message (jac::ExceptionWrapper)</li> <li>_type (jac::ExceptionWrapper)</li> <li>_file (jac::File)</li> <li>_codeDir (jac::FilesystemFeature)</li> <li>_workingDir (jac::FilesystemFeature)</li> <li>_feature (jac::FilesystemFeature::Path, jac::FilesystemFeature::Fs)</li> <li>_context (jac::FunctionFactory, jac::MachineBase)</li> <li>_interrupt (jac::MachineBase)</li> <li>_modules (jac::MachineBase)</li> <li>_runtime (jac::MachineBase)</li> <li>_watchdogNext (jac::MachineBase)</li> <li>_watchdogTimeout (jac::MachineBase)</li> <li>_wathdogCallback (jac::MachineBase)</li> <li>_def (jac::Module)</li> <li>_stream (jac::OsWritable)</li> <li>_index (jac::PluginHandle)</li> <li>_plugins (jac::PluginHolderFeature, jac::PluginManager)</li> <li>_ptr (jac::ReadableRef, jac::WritableRef)</li> <li>_stop (jac::TimersFeature)</li> <li>_timerThread (jac::TimersFeature)</li> <li>_timers (jac::TimersFeature)</li> <li>_timersById (jac::TimersFeature)</li> <li>_timersCondition (jac::TimersFeature)</li> <li>_timersMutex (jac::TimersFeature)</li> <li>_val (jac::ValueWrapper)</li> <li>_callback (jac::TimersFeature::Timer)</li> <li>_duration (jac::TimersFeature::Timer)</li> <li>_id (jac::TimersFeature::Timer)</li> <li>_isRepeating (jac::TimersFeature::Timer)</li> <li>_startTime (jac::TimersFeature::Timer)</li> <li>_func (noal::funcptr, noal::memberconstfuncptr, noal::memberfuncptr)</li> <li>_self (noal::memberconstfuncptr, noal::memberfuncptr)</li> </ul>"},{"location":"doxygen/class_member_functions/","title":"Class Member Functions","text":""},{"location":"doxygen/class_member_functions/#a","title":"a","text":"<ul> <li>ArrayBufferWrapper (jac::ArrayBufferWrapper)</li> <li>ArrayWrapper (jac::ArrayWrapper)</li> <li>Atom (jac::Atom)</li> <li>addProperties (jac::FileProtoBuilder, jac::ProtoBuilder::Properties, jac::ReadableProtoBuilder, jac::WritableProtoBuilder)</li> <li>addExport (jac::Module)</li> <li>addPlugin (jac::PluginManager)</li> <li>addMethodMember (jac::ProtoBuilder::Opaque)</li> <li>addPropMember (jac::ProtoBuilder::Opaque)</li> </ul>"},{"location":"doxygen/class_member_functions/#b","title":"b","text":"<ul> <li>BasicStreamFeature (jac::BasicStreamFeature)</li> <li>basename (jac::FilesystemFeature::Path)</li> <li>base (jac::Module)</li> </ul>"},{"location":"doxygen/class_member_functions/#c","title":"c","text":"<ul> <li>create (jac::ArrayBufferWrapper, jac::ArrayWrapper, jac::Atom, jac::ExceptionWrapper, jac::ObjectWrapper, jac::PromiseWrapper)</li> <li>constructor_impl (jac::Class)</li> <li>createInstance (jac::Class)</li> <li>ContextRef (jac::ContextRef)</li> <li>close (jac::File)</li> <li>call (jac::FunctionWrapper, noal::callableany&lt; Func, Res(Args...)&gt;, noal::funcptr, noal::memberconstfuncptr, noal::memberfuncptr)</li> <li>callConstructor (jac::FunctionWrapper, jac::ProtoBuilder::Callable)</li> <li>callThis (jac::FunctionWrapper)</li> <li>context (jac::MachineBase)</li> <li>callFunction (jac::ProtoBuilder::Callable)</li> <li>callMember (jac::ProtoBuilder::Opaque)</li> <li>constructOpaque (jac::ProtoBuilder::Opaque)</li> <li>c_str (jac::StringView)</li> <li>clearInterval (jac::TimersFeature)</li> <li>clearTimeout (jac::TimersFeature)</li> <li>clearTimer (jac::TimersFeature)</li> <li>createTimer (jac::TimersFeature)</li> <li>cancel (jac::TimersFeature::Timer)</li> <li>callableany (noal::callableany&lt; Func, Res(Args...)&gt;)</li> </ul>"},{"location":"doxygen/class_member_functions/#d","title":"d","text":"<ul> <li>data (jac::ArrayBufferWrapper)</li> <li>dirname (jac::FilesystemFeature::Path)</li> <li>defineProperty (jac::ObjectWrapper)</li> <li>deleteProperty (jac::ObjectWrapper)</li> <li>destroyOpaque (jac::ProtoBuilder::Opaque)</li> </ul>"},{"location":"doxygen/class_member_functions/#e","title":"e","text":"<ul> <li>evalModuleWithEventLoop (jac::EventLoopFeature)</li> <li>evalWithEventLoopCommon (jac::EventLoopFeature)</li> <li>exit (jac::EventLoopFeature)</li> <li>ExceptionWrapper (jac::ExceptionWrapper)</li> <li>eval (jac::MachineBase)</li> <li>evalFile (jac::ModuleLoaderFeature)</li> <li>evalFileWithEventLoop (jac::ModuleLoaderFeature)</li> <li>exists (jac::FilesystemFeature::Fs)</li> </ul>"},{"location":"doxygen/class_member_functions/#f","title":"f","text":"<ul> <li>freeArrayBuffer (jac::ArrayBufferWrapper)</li> <li>from (jac::ConvTraits, jac::ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt;, jac::ConvTraits&lt; bool &gt;, jac::ConvTraits&lt; std::chrono::milliseconds &gt;, jac::ValueWrapper)</li> <li>File (jac::File)</li> <li>FilesystemFeature (jac::FilesystemFeature)</li> <li>FunctionFactory (jac::FunctionFactory)</li> <li>FunctionWrapper (jac::FunctionWrapper)</li> <li>findModule (jac::MachineBase)</li> <li>fromJSON (jac::ValueWrapper)</li> <li>Fs (jac::FilesystemFeature::Fs)</li> <li>funcptr (noal::funcptr)</li> <li>function (noal::function&lt; Res(Args...), dataSize &gt;)</li> </ul>"},{"location":"doxygen/class_member_functions/#g","title":"g","text":"<ul> <li>get (jac::Atom, jac::ContextRef, jac::Module, jac::ObjectWrapper, jac::Readable, jac::ReadableRef)</li> <li>getClassId (jac::Class)</li> <li>getConstructor (jac::Class)</li> <li>getProto (jac::Class)</li> <li>getException (jac::ContextRef)</li> <li>getGlobalObject (jac::ContextRef)</li> <li>getExitCode (jac::EventLoopFeature)</li> <li>getEvent (jac::EventQueueFeature)</li> <li>getPrototype (jac::ObjectWrapper)</li> <li>getPlugin (jac::PluginHolderFeature)</li> <li>getOpaque (jac::ProtoBuilder::Opaque)</li> <li>getVal (jac::ValueWrapper)</li> <li>getCallback (jac::TimersFeature::Timer)</li> <li>getEndTime (jac::TimersFeature::Timer)</li> <li>getId (jac::TimersFeature::Timer)</li> </ul>"},{"location":"doxygen/class_member_functions/#h","title":"h","text":"<ul> <li>hasProperty (jac::ObjectWrapper)</li> <li>holdPlugin (jac::PluginHolderFeature)</li> </ul>"},{"location":"doxygen/class_member_functions/#i","title":"i","text":"<ul> <li>initialize (jac::BasicStreamFeature, jac::EventLoopFeature, jac::FilesystemFeature, jac::MachineBase, jac::ModuleLoaderFeature, jac::PluginManager, jac::StdioFeature, jac::TimersFeature)</li> <li>init (jac::Class)</li> <li>initContext (jac::Class)</li> <li>isOpen (jac::File)</li> <li>interruptRuntime (jac::MachineBase)</li> <li>invoke (jac::ObjectWrapper)</li> <li>index (jac::PluginHandle)</li> <li>isArray (jac::ValueWrapper)</li> <li>isFunction (jac::ValueWrapper)</li> <li>isNull (jac::ValueWrapper)</li> <li>isObject (jac::ValueWrapper)</li> <li>isUndefined (jac::ValueWrapper)</li> <li>is_callable (jac::detail::is_base_of_template_impl)</li> <li>isDirectory (jac::FilesystemFeature::Fs)</li> <li>isFile (jac::FilesystemFeature::Fs)</li> <li>isCancelled (jac::TimersFeature::Timer)</li> <li>isRepeating (jac::TimersFeature::Timer)</li> </ul>"},{"location":"doxygen/class_member_functions/#j","title":"j","text":"<ul> <li>join (jac::FilesystemFeature::Path)</li> </ul>"},{"location":"doxygen/class_member_functions/#k","title":"k","text":"<ul> <li>kill (jac::EventLoopFeature)</li> </ul>"},{"location":"doxygen/class_member_functions/#l","title":"l","text":"<ul> <li>length (jac::ArrayWrapper)</li> <li>loot (jac::Atom, jac::ValueWrapper)</li> <li>loadCode (jac::FilesystemFeature::Fs)</li> </ul>"},{"location":"doxygen/class_member_functions/#m","title":"m","text":"<ul> <li>MachineBase (jac::MachineBase)</li> <li>Module (jac::Module)</li> <li>moduleLoaderCbk (jac::ModuleLoaderFeature)</li> <li>mkdir (jac::FilesystemFeature::Fs)</li> <li>memberconstfuncptr (noal::memberconstfuncptr)</li> <li>memberfuncptr (noal::memberfuncptr)</li> </ul>"},{"location":"doxygen/class_member_functions/#n","title":"n","text":"<ul> <li>notifyEventLoop (jac::EventQueueFeature)</li> <li>normalize (jac::FilesystemFeature::Path)</li> <li>newFunction (jac::FunctionFactory)</li> <li>newFunctionHelper (jac::FunctionFactory)</li> <li>newFunctionThis (jac::FunctionFactory)</li> <li>newFunctionThisHelper (jac::FunctionFactory)</li> <li>newFunctionThisVariadic (jac::FunctionFactory)</li> <li>newFunctionThisVariadicHelper (jac::FunctionFactory)</li> <li>newFunctionVariadic (jac::FunctionFactory)</li> <li>newFunctionVariadicHelper (jac::FunctionFactory)</li> <li>newModule (jac::MachineBase)</li> <li>null (jac::ValueWrapper)</li> </ul>"},{"location":"doxygen/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (jac::Atom, jac::ContextRef, jac::MachineBase, jac::Module, jac::StringView, jac::ValueWrapper, noal::function&lt; Res(Args...), dataSize &gt;)</li> <li>operator JSContext * (jac::ContextRef)</li> <li>operator bool (jac::ContextRef, noal::function&lt; Res(Args...), dataSize &gt;)</li> <li>onEventLoop (jac::EventLoopFeature)</li> <li>ObjectWrapper (jac::ObjectWrapper)</li> <li>OsWritable (jac::OsWritable)</li> <li>operator+ (jac::PluginHandle)</li> <li>operator++ (jac::PluginHandle)</li> <li>operator== (jac::PluginHandle)</li> <li>operator ValueWeak (jac::ValueWrapper)</li> <li>open (jac::FilesystemFeature::Fs)</li> <li>operator() (jac::TimersFeature::CompareTimer, noal::callableany&lt; Func, Res(Args...)&gt;, noal::funcptr, noal::function&lt; Res(Args...), dataSize &gt;, noal::memberconstfuncptr, noal::memberfuncptr)</li> <li>operator&lt; (jac::TimersFeature::Timer)</li> </ul>"},{"location":"doxygen/class_member_functions/#p","title":"p","text":"<ul> <li>Path (jac::FilesystemFeature::Path)</li> <li>PluginHandle (jac::PluginHandle)</li> <li>PluginHolderFeature (jac::PluginHolderFeature)</li> <li>pluginBegin (jac::PluginHolderFeature)</li> <li>pluginEnd (jac::PluginHolderFeature)</li> <li>PluginManager (jac::PluginManager)</li> <li>PromiseWrapper (jac::PromiseWrapper)</li> <li>postConstruction (jac::ProtoBuilder::LifetimeHandles)</li> </ul>"},{"location":"doxygen/class_member_functions/#r","title":"r","text":"<ul> <li>runEventLoop (jac::EventLoopFeature)</li> <li>runOnEventLoop (jac::EventLoopFeature, jac::EventLoopTerminal)</li> <li>read (jac::File, jac::Readable, jac::ReadableRef)</li> <li>resetWatchdog (jac::MachineBase)</li> <li>runtime (jac::MachineBase)</li> <li>ReadableRef (jac::ReadableRef)</li> <li>readdir (jac::FilesystemFeature::Fs)</li> <li>rm (jac::FilesystemFeature::Fs)</li> <li>rmdir (jac::FilesystemFeature::Fs)</li> </ul>"},{"location":"doxygen/class_member_functions/#s","title":"s","text":"<ul> <li>size (jac::ArrayBufferWrapper)</li> <li>scheduleEvent (jac::EventQueueFeature)</li> <li>stackTrace (jac::ExceptionWrapper)</li> <li>setCodeDir (jac::FilesystemFeature)</li> <li>setWorkingDir (jac::FilesystemFeature)</li> <li>setWatchdogHandler (jac::MachineBase)</li> <li>setWatchdogTimeout (jac::MachineBase)</li> <li>set (jac::ObjectWrapper)</li> <li>setPrototype (jac::ObjectWrapper)</li> <li>SgnUnwrap (jac::SgnUnwrap&lt; Res(Args...)&gt;)</li> <li>StringView (jac::StringView)</li> <li>string (jac::StringView)</li> <li>setInterval (jac::TimersFeature)</li> <li>setTimeout (jac::TimersFeature)</li> <li>stringify (jac::ValueWrapper)</li> </ul>"},{"location":"doxygen/class_member_functions/#t","title":"t","text":"<ul> <li>typedView (jac::ArrayBufferWrapper)</li> <li>toString (jac::Atom, jac::ValueWrapper)</li> <li>to (jac::ConvTraits, jac::ConvTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;detail::is_leq_i32&lt; T &gt;, T &gt; &gt;, jac::ConvTraits&lt; bool &gt;, jac::ConvTraits&lt; std::chrono::milliseconds &gt;, jac::ValueWrapper)</li> <li>throwJS (jac::ExceptionWrapper)</li> <li>Timer (jac::TimersFeature::Timer)</li> </ul>"},{"location":"doxygen/class_member_functions/#u","title":"u","text":"<ul> <li>undefined (jac::ValueWrapper)</li> <li>update (jac::TimersFeature::Timer)</li> </ul>"},{"location":"doxygen/class_member_functions/#v","title":"v","text":"<ul> <li>ValueWrapper (jac::ValueWrapper)</li> </ul>"},{"location":"doxygen/class_member_functions/#w","title":"w","text":"<ul> <li>what (jac::ExceptionWrapper)</li> <li>write (jac::File, jac::OsWritable, jac::Writable, jac::WritableRef)</li> <li>WritableRef (jac::WritableRef)</li> </ul>"},{"location":"doxygen/class_member_functions/#_1","title":"~","text":"<ul> <li>~Atom (jac::Atom)</li> <li>~EventQueueFeature (jac::EventQueueFeature)</li> <li>~File (jac::File)</li> <li>~MachineBase (jac::MachineBase)</li> <li>~Plugin (jac::Plugin)</li> <li>~Readable (jac::Readable)</li> <li>~StringView (jac::StringView)</li> <li>~TimersFeature (jac::TimersFeature)</li> <li>~ValueWrapper (jac::ValueWrapper)</li> <li>~Writable (jac::Writable)</li> </ul>"},{"location":"doxygen/class_member_variables/","title":"Class Member Variables","text":""},{"location":"doxygen/class_member_variables/#c","title":"c","text":"<ul> <li>classDef (jac::Class)</li> <li>classId (jac::Class, jac::ProtoBuilder::Opaque)</li> <li>className (jac::Class)</li> <li>cancelled (jac::TimersFeature::Timer)</li> <li>call (noal::function&lt; Res(Args...), dataSize &gt;)</li> </ul>"},{"location":"doxygen/class_member_variables/#d","title":"d","text":"<ul> <li>data (noal::function&lt; Res(Args...), dataSize &gt;)</li> </ul>"},{"location":"doxygen/class_member_variables/#e","title":"e","text":"<ul> <li>exports (jac::Module)</li> <li>err (jac::StdioFeature::Stdio)</li> </ul>"},{"location":"doxygen/class_member_variables/#f","title":"f","text":"<ul> <li>fs (jac::FilesystemFeature)</li> <li>func (noal::callableany&lt; Func, Res(Args...)&gt;)</li> </ul>"},{"location":"doxygen/class_member_variables/#i","title":"i","text":"<ul> <li>isConstructor (jac::Class)</li> <li>in (jac::StdioFeature::Stdio)</li> </ul>"},{"location":"doxygen/class_member_variables/#n","title":"n","text":"<ul> <li>nextId (jac::TimersFeature)</li> </ul>"},{"location":"doxygen/class_member_variables/#o","title":"o","text":"<ul> <li>out (jac::StdioFeature::Stdio)</li> </ul>"},{"location":"doxygen/class_member_variables/#p","title":"p","text":"<ul> <li>path_ (jac::File)</li> <li>path (jac::FilesystemFeature)</li> </ul>"},{"location":"doxygen/class_member_variables/#s","title":"s","text":"<ul> <li>stdio (jac::StdioFeature)</li> </ul>"},{"location":"doxygen/class_member_variables/#_","title":"_","text":"<ul> <li>_atom (jac::Atom)</li> <li>_ctx (jac::Atom, jac::ContextRef, jac::Module, jac::StringView, jac::ValueWrapper)</li> <li>_error (jac::EventLoopFeature)</li> <li>_exitCode (jac::EventLoopFeature)</li> <li>_shouldExit (jac::EventLoopFeature)</li> <li>_scheduledFunctions (jac::EventQueueFeature)</li> <li>_scheduledFunctionsCondition (jac::EventQueueFeature)</li> <li>_scheduledFunctionsMutex (jac::EventQueueFeature)</li> <li>_message (jac::ExceptionWrapper)</li> <li>_type (jac::ExceptionWrapper)</li> <li>_file (jac::File)</li> <li>_codeDir (jac::FilesystemFeature)</li> <li>_workingDir (jac::FilesystemFeature)</li> <li>_feature (jac::FilesystemFeature::Path, jac::FilesystemFeature::Fs)</li> <li>_context (jac::FunctionFactory, jac::MachineBase)</li> <li>_interrupt (jac::MachineBase)</li> <li>_modules (jac::MachineBase)</li> <li>_runtime (jac::MachineBase)</li> <li>_watchdogNext (jac::MachineBase)</li> <li>_watchdogTimeout (jac::MachineBase)</li> <li>_wathdogCallback (jac::MachineBase)</li> <li>_def (jac::Module)</li> <li>_stream (jac::OsWritable)</li> <li>_index (jac::PluginHandle)</li> <li>_plugins (jac::PluginHolderFeature, jac::PluginManager)</li> <li>_ptr (jac::ReadableRef, jac::WritableRef)</li> <li>_stop (jac::TimersFeature)</li> <li>_timerThread (jac::TimersFeature)</li> <li>_timers (jac::TimersFeature)</li> <li>_timersById (jac::TimersFeature)</li> <li>_timersCondition (jac::TimersFeature)</li> <li>_timersMutex (jac::TimersFeature)</li> <li>_val (jac::ValueWrapper)</li> <li>_callback (jac::TimersFeature::Timer)</li> <li>_duration (jac::TimersFeature::Timer)</li> <li>_id (jac::TimersFeature::Timer)</li> <li>_isRepeating (jac::TimersFeature::Timer)</li> <li>_startTime (jac::TimersFeature::Timer)</li> <li>_func (noal::funcptr, noal::memberconstfuncptr, noal::memberfuncptr)</li> <li>_self (noal::memberconstfuncptr, noal::memberfuncptr)</li> </ul>"},{"location":"doxygen/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"doxygen/class_member_typedefs/#a","title":"a","text":"<ul> <li>ArgTypes (jac::SgnUnwrap&lt; Res(Args...)&gt;)</li> </ul>"},{"location":"doxygen/class_member_typedefs/#b","title":"b","text":"<ul> <li>basic_string_view (jac::StringView)</li> </ul>"},{"location":"doxygen/class_member_typedefs/#f","title":"f","text":"<ul> <li>FileClass (jac::FilesystemFeature)</li> </ul>"},{"location":"doxygen/class_member_typedefs/#i","title":"i","text":"<ul> <li>is_callable_t (jac::detail::is_base_of_template_impl)</li> </ul>"},{"location":"doxygen/class_member_typedefs/#o","title":"o","text":"<ul> <li>OpaqueType (jac::ProtoBuilder::Opaque)</li> </ul>"},{"location":"doxygen/class_member_typedefs/#r","title":"r","text":"<ul> <li>ReadableClass (jac::BasicStreamFeature)</li> <li>ResType (jac::SgnUnwrap&lt; Res(Args...)&gt;)</li> </ul>"},{"location":"doxygen/class_member_typedefs/#s","title":"s","text":"<ul> <li>Sign (noal::function&lt; Res(Args...), dataSize &gt;)</li> </ul>"},{"location":"doxygen/class_member_typedefs/#t","title":"t","text":"<ul> <li>type (noal::signatureHelper&lt; Res(Func::*)(Args...) &amp; &gt;, noal::signatureHelper&lt; Res(Func::*)(Args...) const &amp; &gt;, noal::signatureHelper&lt; Res(Func::*)(Args...) const &gt;, noal::signatureHelper&lt; Res(Func::*)(Args...)&gt;)</li> </ul>"},{"location":"doxygen/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_t (jac::detail::is_base_of_template_impl)</li> </ul>"},{"location":"doxygen/class_member_typedefs/#w","title":"w","text":"<ul> <li>WritableClass (jac::BasicStreamFeature)</li> </ul>"},{"location":"doxygen/class_member_enums/","title":"Class Member Enums","text":""},{"location":"doxygen/class_member_enums/#t","title":"t","text":"<ul> <li>Type (jac::ExceptionWrapper)</li> </ul>"},{"location":"doxygen/namespace_members/","title":"Namespace Members","text":""},{"location":"doxygen/namespace_members/#a","title":"a","text":"<ul> <li>Array (jac)</li> <li>ArrayBuffer (jac)</li> <li>ArrayBufferWeak (jac)</li> <li>ArrayWeak (jac)</li> </ul>"},{"location":"doxygen/namespace_members/#c","title":"c","text":"<ul> <li>convertArgs (jac)</li> <li>callableany (noal)</li> </ul>"},{"location":"doxygen/namespace_members/#e","title":"e","text":"<ul> <li>EvalFlags (jac)</li> <li>Exception (jac)</li> <li>ExceptionWeak (jac)</li> </ul>"},{"location":"doxygen/namespace_members/#f","title":"f","text":"<ul> <li>Function (jac)</li> <li>FunctionWeak (jac)</li> <li>fromValue (jac)</li> <li>function (noal)</li> </ul>"},{"location":"doxygen/namespace_members/#i","title":"i","text":"<ul> <li>initializeIo (jac)</li> <li>is_base_of_template_t (jac)</li> <li>is_base_of_template_v (jac)</li> <li>is_leq_i32 (jac::detail)</li> <li>invoker (noal)</li> </ul>"},{"location":"doxygen/namespace_members/#o","title":"o","text":"<ul> <li>Object (jac)</li> <li>ObjectWeak (jac)</li> <li>operator&amp; (jac)</li> <li>operator| (jac)</li> </ul>"},{"location":"doxygen/namespace_members/#p","title":"p","text":"<ul> <li>Promise (jac)</li> <li>PromiseWeak (jac)</li> <li>PropFlags (jac)</li> <li>processCall (jac)</li> <li>processCallRaw (jac)</li> <li>processCallThis (jac)</li> <li>processCallThisVariadic (jac)</li> <li>processCallVariadic (jac)</li> <li>processCallVariadicRaw (jac)</li> <li>propagateExceptions (jac)</li> </ul>"},{"location":"doxygen/namespace_members/#s","title":"s","text":"<ul> <li>SgnUnwrap (jac)</li> <li>static_false (jac)</li> </ul>"},{"location":"doxygen/namespace_members/#t","title":"t","text":"<ul> <li>toValue (jac)</li> </ul>"},{"location":"doxygen/namespace_members/#v","title":"v","text":"<ul> <li>Value (jac)</li> <li>ValueWeak (jac)</li> </ul>"},{"location":"doxygen/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"doxygen/namespace_member_functions/#c","title":"c","text":"<ul> <li>convertArgs (jac)</li> <li>callableany (noal)</li> </ul>"},{"location":"doxygen/namespace_member_functions/#f","title":"f","text":"<ul> <li>fromValue (jac)</li> <li>function (noal)</li> </ul>"},{"location":"doxygen/namespace_member_functions/#i","title":"i","text":"<ul> <li>initializeIo (jac)</li> <li>invoker (noal)</li> </ul>"},{"location":"doxygen/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator&amp; (jac)</li> <li>operator| (jac)</li> </ul>"},{"location":"doxygen/namespace_member_functions/#p","title":"p","text":"<ul> <li>processCall (jac)</li> <li>processCallRaw (jac)</li> <li>processCallThis (jac)</li> <li>processCallThisVariadic (jac)</li> <li>processCallVariadic (jac)</li> <li>processCallVariadicRaw (jac)</li> <li>propagateExceptions (jac)</li> </ul>"},{"location":"doxygen/namespace_member_functions/#s","title":"s","text":"<ul> <li>SgnUnwrap (jac)</li> <li>static_false (jac)</li> </ul>"},{"location":"doxygen/namespace_member_functions/#t","title":"t","text":"<ul> <li>toValue (jac)</li> </ul>"},{"location":"doxygen/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"doxygen/namespace_member_variables/#i","title":"i","text":"<ul> <li>is_base_of_template_v (jac)</li> <li>is_leq_i32 (jac::detail)</li> </ul>"},{"location":"doxygen/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"doxygen/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>Array (jac)</li> <li>ArrayBuffer (jac)</li> <li>ArrayBufferWeak (jac)</li> <li>ArrayWeak (jac)</li> </ul>"},{"location":"doxygen/namespace_member_typedefs/#e","title":"e","text":"<ul> <li>Exception (jac)</li> <li>ExceptionWeak (jac)</li> </ul>"},{"location":"doxygen/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>Function (jac)</li> <li>FunctionWeak (jac)</li> </ul>"},{"location":"doxygen/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>is_base_of_template_t (jac)</li> </ul>"},{"location":"doxygen/namespace_member_typedefs/#o","title":"o","text":"<ul> <li>Object (jac)</li> <li>ObjectWeak (jac)</li> </ul>"},{"location":"doxygen/namespace_member_typedefs/#p","title":"p","text":"<ul> <li>Promise (jac)</li> <li>PromiseWeak (jac)</li> </ul>"},{"location":"doxygen/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>Value (jac)</li> <li>ValueWeak (jac)</li> </ul>"},{"location":"doxygen/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"doxygen/namespace_member_enums/#e","title":"e","text":"<ul> <li>EvalFlags (jac)</li> </ul>"},{"location":"doxygen/namespace_member_enums/#p","title":"p","text":"<ul> <li>PropFlags (jac)</li> </ul>"},{"location":"doxygen/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"doxygen/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"doxygen/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"doxygen/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}